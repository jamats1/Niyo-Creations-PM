"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-beautiful-dnd";
exports.ids = ["vendor-chunks/react-beautiful-dnd"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable),\n/* harmony export */   resetServerContext: () => (/* binding */ resetServerContext),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/es/index.js\");\n/* harmony import */ var use_memo_one__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! use-memo-one */ \"(ssr)/./node_modules/use-memo-one/dist/use-memo-one.esm.js\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n\n\n\n\nvar isProduction = \"development\" === \"production\";\nvar spacesAndTabs = /[ \\t]{2,}/g;\nvar lineStartWithSpaces = /^[ \\t]*/gm;\nvar clean = function clean(value) {\n    return value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\n};\nvar getDevMessage = function getDevMessage(message) {\n    return clean(\"\\n  %creact-beautiful-dnd\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77‚Äç This is a development only message. It will be removed in production builds.\\n\");\n};\nvar getFormattedMessage = function getFormattedMessage(message) {\n    return [\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\n};\nvar isDisabledFlag = \"__react-beautiful-dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    var _console;\n    if (isProduction) {\n        return;\n    }\n    if (false) {}\n    (_console = console)[type].apply(_console, getFormattedMessage(message));\n}\nvar warning = log.bind(null, \"warn\");\nvar error = log.bind(null, \"error\");\nfunction noop() {}\nfunction getOptions(shared, fromBinding) {\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, shared, {}, fromBinding);\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    var unbindings = bindings.map(function(binding) {\n        var options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach(function(unbind) {\n            unbind();\n        });\n    };\n}\nvar isProduction$1 = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction RbdInvariant(message) {\n    this.message = message;\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction$1) {\n        throw new RbdInvariant(prefix);\n    } else {\n        throw new RbdInvariant(prefix + \": \" + (message || \"\"));\n    }\n}\nvar ErrorBoundary = function(_React$Component) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ErrorBoundary, _React$Component);\n    function ErrorBoundary() {\n        var _this;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _React$Component.call.apply(_React$Component, [\n            this\n        ].concat(args)) || this;\n        _this.callbacks = null;\n        _this.unbind = noop;\n        _this.onWindowError = function(event) {\n            var callbacks = _this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(\"\\n        An error was caught by our window 'error' event listener while a drag was occurring.\\n        The active drag has been aborted.\\n      \") : 0;\n            }\n            var err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        _this.getCallbacks = function() {\n            if (!_this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return _this.callbacks;\n        };\n        _this.setCallbacks = function(callbacks) {\n            _this.callbacks = callbacks;\n        };\n        return _this;\n    }\n    var _proto = ErrorBoundary.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    };\n    _proto.componentDidCatch = function componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.unbind();\n    };\n    _proto.render = function render() {\n        return this.props.children(this.setCallbacks);\n    };\n    return ErrorBoundary;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\nvar dragHandleUsageInstructions = \"\\n  Press space bar to start a drag.\\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\\n  Some screen readers may require you to be in focus mode or to use your pass through key\\n\";\nvar position = function position(index) {\n    return index + 1;\n};\nvar onDragStart = function onDragStart(start) {\n    return \"\\n  You have lifted an item in position \" + position(start.source.index) + \"\\n\";\n};\nvar withLocation = function withLocation(source, destination) {\n    var isInHomeList = source.droppableId === destination.droppableId;\n    var startPosition = position(source.index);\n    var endPosition = position(destination.index);\n    if (isInHomeList) {\n        return \"\\n      You have moved the item from position \" + startPosition + \"\\n      to position \" + endPosition + \"\\n    \";\n    }\n    return \"\\n    You have moved the item from position \" + startPosition + \"\\n    in list \" + source.droppableId + \"\\n    to list \" + destination.droppableId + \"\\n    in position \" + endPosition + \"\\n  \";\n};\nvar withCombine = function withCombine(id, source, combine) {\n    var inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return \"\\n      The item \" + id + \"\\n      has been combined with \" + combine.draggableId;\n    }\n    return \"\\n      The item \" + id + \"\\n      in list \" + source.droppableId + \"\\n      has been combined with \" + combine.draggableId + \"\\n      in list \" + combine.droppableId + \"\\n    \";\n};\nvar onDragUpdate = function onDragUpdate(update) {\n    var location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    var combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nvar returnedToStart = function returnedToStart(source) {\n    return \"\\n  The item has returned to its starting position\\n  of \" + position(source.index) + \"\\n\";\n};\nvar onDragEnd = function onDragEnd(result) {\n    if (result.reason === \"CANCEL\") {\n        return \"\\n      Movement cancelled.\\n      \" + returnedToStart(result.source) + \"\\n    \";\n    }\n    var location = result.destination;\n    var combine = result.combine;\n    if (location) {\n        return \"\\n      You have dropped the item.\\n      \" + withLocation(result.source, location) + \"\\n    \";\n    }\n    if (combine) {\n        return \"\\n      You have dropped the item.\\n      \" + withCombine(result.draggableId, result.source, combine) + \"\\n    \";\n    }\n    return \"\\n    The item has been dropped while not over a drop area.\\n    \" + returnedToStart(result.source) + \"\\n  \";\n};\nvar preset = {\n    dragHandleUsageInstructions: dragHandleUsageInstructions,\n    onDragStart: onDragStart,\n    onDragUpdate: onDragUpdate,\n    onDragEnd: onDragEnd\n};\nvar origin = {\n    x: 0,\n    y: 0\n};\nvar add = function add(point1, point2) {\n    return {\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    };\n};\nvar subtract = function subtract(point1, point2) {\n    return {\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    };\n};\nvar isEqual = function isEqual(point1, point2) {\n    return point1.x === point2.x && point1.y === point2.y;\n};\nvar negate = function negate(point) {\n    return {\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    };\n};\nvar patch = function patch(line, value, otherValue) {\n    var _ref;\n    if (otherValue === void 0) {\n        otherValue = 0;\n    }\n    return _ref = {}, _ref[line] = value, _ref[line === \"x\" ? \"y\" : \"x\"] = otherValue, _ref;\n};\nvar distance = function distance(point1, point2) {\n    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n};\nvar closest = function closest(target, points) {\n    return Math.min.apply(Math, points.map(function(point) {\n        return distance(target, point);\n    }));\n};\nvar apply = function apply(fn) {\n    return function(point) {\n        return {\n            x: fn(point.x),\n            y: fn(point.y)\n        };\n    };\n};\nvar executeClip = function(frame, subject) {\n    var result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nvar offsetByPosition = function offsetByPosition(spacing, point) {\n    return {\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    };\n};\nvar getCorners = function getCorners(spacing) {\n    return [\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\n};\nvar noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nvar scroll = function scroll(target, frame) {\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nvar increase = function increase(target, axis, withPlaceholder) {\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        var _extends2;\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));\n    }\n    return target;\n};\nvar clip = function clip(target, frame) {\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(target);\n};\nvar getSubject = function(_ref) {\n    var page = _ref.page, withPlaceholder = _ref.withPlaceholder, axis = _ref.axis, frame = _ref.frame;\n    var scrolled = scroll(page.marginBox, frame);\n    var increased = increase(scrolled, axis, withPlaceholder);\n    var clipped = clip(increased, frame);\n    return {\n        page: page,\n        withPlaceholder: withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = function(droppable, newScroll) {\n    !droppable.frame ?  true ? invariant(false) : 0 : void 0;\n    var scrollable = droppable.frame;\n    var scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    var scrollDisplacement = negate(scrollDiff);\n    var frame = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, scrollable, {\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    });\n    var subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame: frame\n    });\n    var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n        frame: frame,\n        subject: subject\n    });\n    return result;\n};\nfunction isInteger(value) {\n    if (Number.isInteger) {\n        return Number.isInteger(value);\n    }\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n}\nfunction values(map) {\n    if (Object.values) {\n        return Object.values(map);\n    }\n    return Object.keys(map).map(function(key) {\n        return map[key];\n    });\n}\nfunction findIndex(list, predicate) {\n    if (list.findIndex) {\n        return list.findIndex(predicate);\n    }\n    for(var i = 0; i < list.length; i++){\n        if (predicate(list[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction find(list, predicate) {\n    if (list.find) {\n        return list.find(predicate);\n    }\n    var index = findIndex(list, predicate);\n    if (index !== -1) {\n        return list[index];\n    }\n    return undefined;\n}\nfunction toArray(list) {\n    return Array.prototype.slice.call(list);\n}\nvar toDroppableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppables) {\n    return droppables.reduce(function(previous, current) {\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {});\n});\nvar toDraggableMap = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(draggables) {\n    return draggables.reduce(function(previous, current) {\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {});\n});\nvar toDroppableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppables) {\n    return values(droppables);\n});\nvar toDraggableList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(draggables) {\n    return values(draggables);\n});\nvar getDraggablesInsideDroppable = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppableId, draggables) {\n    var result = toDraggableList(draggables).filter(function(draggable) {\n        return droppableId === draggable.descriptor.droppableId;\n    }).sort(function(a, b) {\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(remove, list) {\n    return list.filter(function(item) {\n        return item.descriptor.id !== remove.descriptor.id;\n    });\n});\nvar moveToNextCombine = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, draggable = _ref.draggable, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    var location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        var at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, previousImpact, {\n            at: at\n        });\n    }\n    var all = previousImpact.displaced.all;\n    var closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    var withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        var last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    var indexOfClosest = findIndex(withoutDraggable, function(d) {\n        return d.descriptor.id === closestId;\n    });\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    var proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    var before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = function(draggable, destination) {\n    return draggable.descriptor.droppableId === destination.descriptor.id;\n};\nvar noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nvar emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nvar noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar isWithin = function(lowerBound, upperBound) {\n    return function(value) {\n        return lowerBound <= value && value <= upperBound;\n    };\n};\nvar isPartiallyVisibleThroughFrame = function(frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function(subject) {\n        var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = function(frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function(subject) {\n        var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nvar vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nvar horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = function(axis) {\n    return function(frame) {\n        var isWithinVertical = isWithin(frame.top, frame.bottom);\n        var isWithinHorizontal = isWithin(frame.left, frame.right);\n        return function(subject) {\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\n};\nvar getDroppableDisplaced = function getDroppableDisplaced(target, destination) {\n    var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nvar isVisibleInDroppable = function isVisibleInDroppable(target, destination, isVisibleThroughFrameFn) {\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nvar isVisibleInViewport = function isVisibleInViewport(target, viewport, isVisibleThroughFrameFn) {\n    return isVisibleThroughFrameFn(viewport)(target);\n};\nvar isVisible = function isVisible(_ref) {\n    var toBeDisplaced = _ref.target, destination = _ref.destination, viewport = _ref.viewport, withDroppableDisplacement = _ref.withDroppableDisplacement, isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;\n    var displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nvar isPartiallyVisible = function isPartiallyVisible(args) {\n    return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, args, {\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    }));\n};\nvar isTotallyVisible = function isTotallyVisible(args) {\n    return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, args, {\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    }));\n};\nvar isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis(args) {\n    return isVisible((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, args, {\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    }));\n};\nvar getShouldAnimate = function getShouldAnimate(id, last, forceShouldAnimate) {\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    var invisible = last.invisible, visible = last.visible;\n    if (invisible[id]) {\n        return false;\n    }\n    var previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    var marginBox = draggable.page.marginBox;\n    var expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups(_ref) {\n    var afterDragging = _ref.afterDragging, destination = _ref.destination, displacedBy = _ref.displacedBy, viewport = _ref.viewport, forceShouldAnimate = _ref.forceShouldAnimate, last = _ref.last;\n    return afterDragging.reduce(function process(groups, draggable) {\n        var target = getTarget(draggable, displacedBy);\n        var id = draggable.descriptor.id;\n        groups.all.push(id);\n        var isVisible = isPartiallyVisible({\n            target: target,\n            destination: destination,\n            viewport: viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        var displacement = {\n            draggableId: id,\n            shouldAnimate: shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd(_ref) {\n    var insideDestination = _ref.insideDestination, inHomeList = _ref.inHomeList, displacedBy = _ref.displacedBy, destination = _ref.destination;\n    var newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList: inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy: displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact(_ref2) {\n    var draggable = _ref2.draggable, insideDestination = _ref2.insideDestination, destination = _ref2.destination, viewport = _ref2.viewport, displacedBy = _ref2.displacedBy, last = _ref2.last, index = _ref2.index, forceShouldAnimate = _ref2.forceShouldAnimate;\n    var inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination: insideDestination,\n            inHomeList: inHomeList,\n            displacedBy: displacedBy,\n            destination: destination\n        });\n    }\n    var match = find(insideDestination, function(item) {\n        return item.descriptor.index === index;\n    });\n    if (!match) {\n        return goAtEnd({\n            insideDestination: insideDestination,\n            inHomeList: inHomeList,\n            displacedBy: displacedBy,\n            destination: destination\n        });\n    }\n    var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    var sliceFrom = insideDestination.indexOf(match);\n    var impacted = withoutDragging.slice(sliceFrom);\n    var displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination: destination,\n        displacedBy: displacedBy,\n        last: last,\n        viewport: viewport.frame,\n        forceShouldAnimate: forceShouldAnimate\n    });\n    return {\n        displaced: displaced,\n        displacedBy: displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, destination = _ref.destination, draggables = _ref.draggables, combine = _ref.combine, afterCritical = _ref.afterCritical;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    var combineId = combine.draggableId;\n    var combineWith = draggables[combineId];\n    var combineWithIndex = combineWith.descriptor.index;\n    var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, insideDestination = _ref.insideDestination, location = _ref.location;\n    if (!insideDestination.length) {\n        return null;\n    }\n    var currentIndex = location.index;\n    var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    var firstIndex = insideDestination[0].descriptor.index;\n    var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    var upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, draggable = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        var _newIndex = fromReorder({\n            isMovingForward: isMovingForward,\n            isInHomeList: isInHomeList,\n            location: wasAt.destination,\n            insideDestination: insideDestination\n        });\n        if (_newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable: draggable,\n            insideDestination: insideDestination,\n            destination: destination,\n            viewport: viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: _newIndex\n        });\n    }\n    var newIndex = fromCombine({\n        isMovingForward: isMovingForward,\n        destination: destination,\n        displaced: previousImpact.displaced,\n        draggables: draggables,\n        combine: wasAt.combine,\n        afterCritical: afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable: draggable,\n        insideDestination: insideDestination,\n        destination: destination,\n        viewport: viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = function(_ref) {\n    var displaced = _ref.displaced, afterCritical = _ref.afterCritical, combineWith = _ref.combineWith, displacedBy = _ref.displacedBy;\n    var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = function(_ref) {\n    var afterCritical = _ref.afterCritical, impact = _ref.impact, draggables = _ref.draggables;\n    var combine = tryGetCombine(impact);\n    !combine ?  true ? invariant(false) : 0 : void 0;\n    var combineWith = combine.draggableId;\n    var center = draggables[combineWith].page.borderBox.center;\n    var displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical: afterCritical,\n        combineWith: combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nvar distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter(axis, box) {\n    return box.margin[axis.start] + box.borderBox[axis.size] / 2;\n};\nvar distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter(axis, box) {\n    return box.margin[axis.end] + box.borderBox[axis.size] / 2;\n};\nvar getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter(axis, target, isMoving) {\n    return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\n};\nvar goAfter = function goAfter(_ref) {\n    var axis = _ref.axis, moveRelativeTo = _ref.moveRelativeTo, isMoving = _ref.isMoving;\n    return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goBefore = function goBefore(_ref2) {\n    var axis = _ref2.axis, moveRelativeTo = _ref2.moveRelativeTo, isMoving = _ref2.isMoving;\n    return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\n};\nvar goIntoStart = function goIntoStart(_ref3) {\n    var axis = _ref3.axis, moveInto = _ref3.moveInto, isMoving = _ref3.isMoving;\n    return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\n};\nvar whenReordering = function(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, draggables = _ref.draggables, droppable = _ref.droppable, afterCritical = _ref.afterCritical;\n    var insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    var draggablePage = draggable.page;\n    var axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis: axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    var displaced = impact.displaced, displacedBy = impact.displacedBy;\n    var closestAfter = displaced.all[0];\n    if (closestAfter) {\n        var closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis: axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        var withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis: axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    var last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis: axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis: axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = function(droppable, point) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nvar getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, droppable = _ref.droppable, draggables = _ref.draggables, afterCritical = _ref.afterCritical;\n    var original = draggable.page.borderBox.center;\n    var at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact: impact,\n            draggable: draggable,\n            draggables: draggables,\n            droppable: droppable,\n            afterCritical: afterCritical\n        });\n    }\n    return whenCombining({\n        impact: impact,\n        draggables: draggables,\n        afterCritical: afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = function(args) {\n    var withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    var droppable = args.droppable;\n    var withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = function(viewport, newScroll) {\n    var diff = subtract(newScroll, viewport.scroll.initial);\n    var displacement = negate(diff);\n    var frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    var updated = {\n        frame: frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement: displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map(function(id) {\n        return draggables[id];\n    });\n}\nfunction tryGetVisible(id, groups) {\n    for(var i = 0; i < groups.length; i++){\n        var displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = function(_ref) {\n    var impact = _ref.impact, viewport = _ref.viewport, destination = _ref.destination, draggables = _ref.draggables, maxScrollChange = _ref.maxScrollChange;\n    var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    var last = impact.displaced;\n    var withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables(last.all, draggables),\n        destination: destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last: last,\n        forceShouldAnimate: false\n    });\n    var withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last: last,\n        forceShouldAnimate: false\n    });\n    var invisible = {};\n    var visible = {};\n    var groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach(function(id) {\n        var displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    var newImpact = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, impact, {\n        displaced: {\n            all: last.all,\n            invisible: invisible,\n            visible: visible\n        }\n    });\n    return newImpact;\n};\nvar withViewportDisplacement = function(viewport, point) {\n    return add(viewport.scroll.diff.displacement, point);\n};\nvar getClientFromPageBorderBoxCenter = function(_ref) {\n    var pageBorderBoxCenter = _ref.pageBorderBoxCenter, draggable = _ref.draggable, viewport = _ref.viewport;\n    var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    var offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = function(_ref) {\n    var draggable = _ref.draggable, destination = _ref.destination, newPageBorderBoxCenter = _ref.newPageBorderBoxCenter, viewport = _ref.viewport, withDroppableDisplacement = _ref.withDroppableDisplacement, _ref$onlyOnMainAxis = _ref.onlyOnMainAxis, onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;\n    var changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    var shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    var args = {\n        target: shifted,\n        destination: destination,\n        withDroppableDisplacement: withDroppableDisplacement,\n        viewport: viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, draggable = _ref.draggable, destination = _ref.destination, draggables = _ref.draggables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, previousClientSelection = _ref.previousClientSelection, afterCritical = _ref.afterCritical;\n    if (!destination.isEnabled) {\n        return null;\n    }\n    var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    var isInHomeList = isHomeOf(draggable, destination);\n    var impact = moveToNextCombine({\n        isMovingForward: isMovingForward,\n        draggable: draggable,\n        destination: destination,\n        insideDestination: insideDestination,\n        previousImpact: previousImpact\n    }) || moveToNextIndex({\n        isMovingForward: isMovingForward,\n        isInHomeList: isInHomeList,\n        draggable: draggable,\n        draggables: draggables,\n        destination: destination,\n        insideDestination: insideDestination,\n        previousImpact: previousImpact,\n        viewport: viewport,\n        afterCritical: afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact: impact,\n        draggable: draggable,\n        droppable: destination,\n        draggables: draggables,\n        afterCritical: afterCritical\n    });\n    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable: draggable,\n        destination: destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        var clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter: pageBorderBoxCenter,\n            draggable: draggable,\n            viewport: viewport\n        });\n        return {\n            clientSelection: clientSelection,\n            impact: impact,\n            scrollJumpRequest: null\n        };\n    }\n    var distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    var cautious = speculativelyIncrease({\n        impact: impact,\n        viewport: viewport,\n        destination: destination,\n        draggables: draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nvar getKnownActive = function getKnownActive(droppable) {\n    var rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, pageBorderBoxCenter = _ref.pageBorderBoxCenter, source = _ref.source, droppables = _ref.droppables, viewport = _ref.viewport;\n    var active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    var axis = source.axis;\n    var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    var candidates = toDroppableList(droppables).filter(function(droppable) {\n        return droppable !== source;\n    }).filter(function(droppable) {\n        return droppable.isEnabled;\n    }).filter(function(droppable) {\n        return Boolean(droppable.subject.active);\n    }).filter(function(droppable) {\n        return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable));\n    }).filter(function(droppable) {\n        var activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter(function(droppable) {\n        var activeOfTarget = getKnownActive(droppable);\n        var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort(function(a, b) {\n        var first = getKnownActive(a)[axis.crossAxisStart];\n        var second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter(function(droppable, index, array) {\n        return getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    var contains = candidates.filter(function(droppable) {\n        var isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort(function(a, b) {\n            return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n        })[0];\n    }\n    return candidates.sort(function(a, b) {\n        var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nvar getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter(draggable, afterCritical) {\n    var original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nvar getCurrentPageBorderBox = function getCurrentPageBorderBox(draggable, afterCritical) {\n    var original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = function(_ref) {\n    var pageBorderBoxCenter = _ref.pageBorderBoxCenter, viewport = _ref.viewport, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;\n    var sorted = insideDestination.filter(function(draggable) {\n        return isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination: destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        });\n    }).sort(function(a, b) {\n        var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function getDisplacedBy(axis, displaceBy) {\n    var displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nvar getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables) {\n    var axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    var availableSpace = droppable.subject.page.contentBox[axis.size];\n    var insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    var spaceUsed = insideDroppable.reduce(function(sum, dimension) {\n        return sum + dimension.client.marginBox[axis.size];\n    }, 0);\n    var requiredSpace = spaceUsed + placeholderSize[axis.line];\n    var needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nvar withMaxScroll = function withMaxScroll(frame, max) {\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, frame, {\n        scroll: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, frame.scroll, {\n            max: max\n        })\n    });\n};\nvar addPlaceholder = function addPlaceholder(droppable, draggable, draggables) {\n    var frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    var placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    var requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    var added = {\n        placeholderSize: placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        var _subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n            subject: _subject\n        });\n    }\n    var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    var newFrame = withMaxScroll(frame, maxScroll);\n    var subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n        subject: subject,\n        frame: newFrame\n    });\n};\nvar removePlaceholder = function removePlaceholder(droppable) {\n    var added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    var frame = droppable.frame;\n    if (!frame) {\n        var _subject2 = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n            subject: _subject2\n        });\n    }\n    var oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    var newFrame = withMaxScroll(frame, oldMaxScroll);\n    var subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppable, {\n        subject: subject,\n        frame: newFrame\n    });\n};\nvar moveToNewDroppable = function(_ref) {\n    var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, moveRelativeTo = _ref.moveRelativeTo, insideDestination = _ref.insideDestination, draggable = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        var proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable: draggable,\n            droppable: destination,\n            draggables: draggables,\n            afterCritical: afterCritical\n        });\n        var withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        var isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable: draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    var proposedIndex = function() {\n        var relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    }();\n    var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable: draggable,\n        insideDestination: insideDestination,\n        destination: destination,\n        viewport: viewport,\n        displacedBy: displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = function(_ref) {\n    var isMovingForward = _ref.isMovingForward, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, draggable = _ref.draggable, isOver = _ref.isOver, draggables = _ref.draggables, droppables = _ref.droppables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var destination = getBestCrossAxisDroppable({\n        isMovingForward: isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables: droppables,\n        viewport: viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    var moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport: viewport,\n        destination: destination,\n        insideDestination: insideDestination,\n        afterCritical: afterCritical\n    });\n    var impact = moveToNewDroppable({\n        previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n        destination: destination,\n        draggable: draggable,\n        draggables: draggables,\n        moveRelativeTo: moveRelativeTo,\n        insideDestination: insideDestination,\n        viewport: viewport,\n        afterCritical: afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact: impact,\n        draggable: draggable,\n        droppable: destination,\n        draggables: draggables,\n        afterCritical: afterCritical\n    });\n    var clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter: pageBorderBoxCenter,\n        draggable: draggable,\n        viewport: viewport\n    });\n    return {\n        clientSelection: clientSelection,\n        impact: impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = function(impact) {\n    var at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nvar getDroppableOver = function getDroppableOver(impact, droppables) {\n    var id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = function(_ref) {\n    var state = _ref.state, type = _ref.type;\n    var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);\n    var isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    var home = state.dimensions.droppables[state.critical.droppable.id];\n    var isOver = isActuallyOver || home;\n    var direction = isOver.axis.direction;\n    var isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    var isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    var draggable = state.dimensions.draggables[state.critical.draggable.id];\n    var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    var _state$dimensions = state.dimensions, draggables = _state$dimensions.draggables, droppables = _state$dimensions.droppables;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward: isMovingForward,\n        previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n        draggable: draggable,\n        destination: isOver,\n        draggables: draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward: isMovingForward,\n        previousPageBorderBoxCenter: previousPageBorderBoxCenter,\n        draggable: draggable,\n        isOver: isOver,\n        draggables: draggables,\n        droppables: droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    var isWithinVertical = isWithin(frame.top, frame.bottom);\n    var isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway(_ref) {\n    var pageBorderBox = _ref.pageBorderBox, draggable = _ref.draggable, candidates = _ref.candidates;\n    var startCenter = draggable.page.borderBox.center;\n    var sorted = candidates.map(function(candidate) {\n        var axis = candidate.axis;\n        var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort(function(a, b) {\n        return b.distance - a.distance;\n    });\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver$1(_ref2) {\n    var pageBorderBox = _ref2.pageBorderBox, draggable = _ref2.draggable, droppables = _ref2.droppables;\n    var candidates = toDroppableList(droppables).filter(function(item) {\n        if (!item.isEnabled) {\n            return false;\n        }\n        var active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        var axis = item.axis;\n        var childCenter = active.center[axis.crossAxisLine];\n        var crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        var isStartContained = isContained(crossAxisStart);\n        var isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox: pageBorderBox,\n        draggable: draggable,\n        candidates: candidates\n    });\n}\nvar offsetRectByPosition = function offsetRectByPosition(rect, point) {\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(offsetByPosition(rect, point));\n};\nvar withDroppableScroll = function(droppable, area) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced(_ref) {\n    var displaced = _ref.displaced, id = _ref.id;\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex(_ref) {\n    var draggable = _ref.draggable, closest = _ref.closest, inHomeList = _ref.inHomeList;\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = function(_ref2) {\n    var targetRect = _ref2.pageBorderBoxWithDroppableScroll, draggable = _ref2.draggable, destination = _ref2.destination, insideDestination = _ref2.insideDestination, last = _ref2.last, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;\n    var axis = destination.axis;\n    var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    var displacement = displacedBy.value;\n    var targetStart = targetRect[axis.start];\n    var targetEnd = targetRect[axis.end];\n    var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    var closest = find(withoutDragging, function(child) {\n        var id = child.descriptor.id;\n        var childCenter = child.page.borderBox.center[axis.line];\n        var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        var isDisplaced = getIsDisplaced({\n            displaced: last,\n            id: id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    });\n    var newIndex = atIndex({\n        draggable: draggable,\n        closest: closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable: draggable,\n        insideDestination: insideDestination,\n        destination: destination,\n        viewport: viewport,\n        last: last,\n        displacedBy: displacedBy,\n        index: newIndex\n    });\n};\nvar combineThresholdDivisor = 4;\nvar getCombineImpact = function(_ref) {\n    var draggable = _ref.draggable, targetRect = _ref.pageBorderBoxWithDroppableScroll, previousImpact = _ref.previousImpact, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    var axis = destination.axis;\n    var displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    var displacement = displacedBy.value;\n    var targetStart = targetRect[axis.start];\n    var targetEnd = targetRect[axis.end];\n    var withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    var combineWith = find(withoutDragging, function(child) {\n        var id = child.descriptor.id;\n        var childRect = child.page.borderBox;\n        var childSize = childRect[axis.size];\n        var threshold = childSize / combineThresholdDivisor;\n        var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        var isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id: id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    var impact = {\n        displacedBy: displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = function(_ref) {\n    var pageOffset = _ref.pageOffset, draggable = _ref.draggable, draggables = _ref.draggables, droppables = _ref.droppables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    var destinationId = getDroppableOver$1({\n        pageBorderBox: pageBorderBox,\n        draggable: draggable,\n        droppables: droppables\n    });\n    if (!destinationId) {\n        return noImpact;\n    }\n    var destination = droppables[destinationId];\n    var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,\n        draggable: draggable,\n        previousImpact: previousImpact,\n        destination: destination,\n        insideDestination: insideDestination,\n        afterCritical: afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll: pageBorderBoxWithDroppableScroll,\n        draggable: draggable,\n        destination: destination,\n        insideDestination: insideDestination,\n        last: previousImpact.displaced,\n        viewport: viewport,\n        afterCritical: afterCritical\n    });\n};\nvar patchDroppableMap = function(droppables, updated) {\n    var _extends2;\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));\n};\nvar clearUnusedPlaceholder = function clearUnusedPlaceholder(_ref) {\n    var previousImpact = _ref.previousImpact, impact = _ref.impact, droppables = _ref.droppables;\n    var last = whatIsDraggedOver(previousImpact);\n    var now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    var lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    var updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = function(_ref2) {\n    var draggable = _ref2.draggable, draggables = _ref2.draggables, droppables = _ref2.droppables, previousImpact = _ref2.previousImpact, impact = _ref2.impact;\n    var cleaned = clearUnusedPlaceholder({\n        previousImpact: previousImpact,\n        impact: impact,\n        droppables: droppables\n    });\n    var isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    var droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    var patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = function(_ref) {\n    var state = _ref.state, forcedClientSelection = _ref.clientSelection, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport, forcedImpact = _ref.impact, scrollJumpRequest = _ref.scrollJumpRequest;\n    var viewport = forcedViewport || state.viewport;\n    var dimensions = forcedDimensions || state.dimensions;\n    var clientSelection = forcedClientSelection || state.current.client.selection;\n    var offset = subtract(clientSelection, state.initial.client.selection);\n    var client = {\n        offset: offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    var page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    var current = {\n        client: client,\n        page: page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"COLLECTING\"\n        }, state, {\n            dimensions: dimensions,\n            viewport: viewport,\n            current: current\n        });\n    }\n    var draggable = dimensions.draggables[state.critical.draggable.id];\n    var newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable: draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport: viewport,\n        afterCritical: state.afterCritical\n    });\n    var withUpdatedPlaceholders = recomputePlaceholders({\n        draggable: draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state, {\n        current: current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport: viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    });\n    return result;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map(function(id) {\n        return draggables[id];\n    });\n}\nvar recompute = function(_ref) {\n    var impact = _ref.impact, viewport = _ref.viewport, draggables = _ref.draggables, destination = _ref.destination, forceShouldAnimate = _ref.forceShouldAnimate;\n    var last = impact.displaced;\n    var afterDragging = getDraggables$1(last.all, draggables);\n    var displaced = getDisplacementGroups({\n        afterDragging: afterDragging,\n        destination: destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate: forceShouldAnimate,\n        last: last\n    });\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, impact, {\n        displaced: displaced\n    });\n};\nvar getClientBorderBoxCenter = function(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, droppable = _ref.droppable, draggables = _ref.draggables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact: impact,\n        draggable: draggable,\n        draggables: draggables,\n        droppable: droppable,\n        afterCritical: afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter: pageBorderBoxCenter,\n        draggable: draggable,\n        viewport: viewport\n    });\n};\nvar refreshSnap = function(_ref) {\n    var state = _ref.state, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport;\n    !(state.movementMode === \"SNAP\") ?  true ? invariant(false) : 0 : void 0;\n    var needsVisibilityCheck = state.impact;\n    var viewport = forcedViewport || state.viewport;\n    var dimensions = forcedDimensions || state.dimensions;\n    var draggables = dimensions.draggables, droppables = dimensions.droppables;\n    var draggable = draggables[state.critical.draggable.id];\n    var isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    var destination = droppables[isOver];\n    var impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport: viewport,\n        destination: destination,\n        draggables: draggables\n    });\n    var clientSelection = getClientBorderBoxCenter({\n        impact: impact,\n        draggable: draggable,\n        droppable: destination,\n        draggables: draggables,\n        viewport: viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact: impact,\n        clientSelection: clientSelection,\n        state: state,\n        dimensions: dimensions,\n        viewport: viewport\n    });\n};\nvar getHomeLocation = function(descriptor) {\n    return {\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    };\n};\nvar getLiftEffect = function(_ref) {\n    var draggable = _ref.draggable, home = _ref.home, draggables = _ref.draggables, viewport = _ref.viewport;\n    var displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    var insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    var rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    var afterDragging = insideHome.slice(rawIndex + 1);\n    var effected = afterDragging.reduce(function(previous, item) {\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    var afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy: displacedBy,\n        effected: effected\n    };\n    var displaced = getDisplacementGroups({\n        afterDragging: afterDragging,\n        destination: home,\n        displacedBy: displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    var impact = {\n        displaced: displaced,\n        displacedBy: displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact: impact,\n        afterCritical: afterCritical\n    };\n};\nvar patchDimensionMap = function(dimensions, updated) {\n    return {\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    };\n};\nvar start = function start(key) {\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar finish = function finish(key) {\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = function(_ref) {\n    var draggable = _ref.draggable, offset$1 = _ref.offset, initialWindowScroll = _ref.initialWindowScroll;\n    var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.offset)(draggable.client, offset$1);\n    var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, initialWindowScroll);\n    var moved = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, draggable, {\n        placeholder: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, draggable.placeholder, {\n            client: client\n        }),\n        client: client,\n        page: page\n    });\n    return moved;\n};\nvar getFrame = function(droppable) {\n    var frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = function(_ref) {\n    var additions = _ref.additions, updatedDroppables = _ref.updatedDroppables, viewport = _ref.viewport;\n    var windowScrollChange = viewport.scroll.diff.value;\n    return additions.map(function(draggable) {\n        var droppableId = draggable.descriptor.droppableId;\n        var modified = updatedDroppables[droppableId];\n        var frame = getFrame(modified);\n        var droppableScrollChange = frame.scroll.diff.value;\n        var totalChange = add(windowScrollChange, droppableScrollChange);\n        var moved = offsetDraggable({\n            draggable: draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nvar publishWhileDraggingInVirtual = function(_ref) {\n    var state = _ref.state, published = _ref.published;\n    start();\n    var withScrollChange = published.modified.map(function(update) {\n        var existing = state.dimensions.droppables[update.droppableId];\n        var scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    var droppables = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));\n    var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    var draggables = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.dimensions.draggables, {}, updatedAdditions);\n    published.removals.forEach(function(id) {\n        delete draggables[id];\n    });\n    var dimensions = {\n        droppables: droppables,\n        draggables: draggables\n    };\n    var wasOverId = whatIsDraggedOver(state.impact);\n    var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    var draggable = dimensions.draggables[state.critical.draggable.id];\n    var home = dimensions.droppables[state.critical.droppable.id];\n    var _getLiftEffect = getLiftEffect({\n        draggable: draggable,\n        home: home,\n        draggables: draggables,\n        viewport: state.viewport\n    }), onLiftImpact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;\n    var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    var impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: previousImpact,\n        viewport: state.viewport,\n        afterCritical: afterCritical\n    });\n    finish();\n    var draggingState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        phase: \"DRAGGING\"\n    }, state, {\n        phase: \"DRAGGING\",\n        impact: impact,\n        onLiftImpact: onLiftImpact,\n        dimensions: dimensions,\n        afterCritical: afterCritical,\n        forceShouldAnimate: false\n    });\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    var dropPending = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        phase: \"DROP_PENDING\"\n    }, draggingState, {\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    });\n    return dropPending;\n};\nvar isSnapping = function isSnapping(state) {\n    return state.movementMode === \"SNAP\";\n};\nvar postDroppableChange = function postDroppableChange(state, updated, isEnabledChanging) {\n    var dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state: state,\n            dimensions: dimensions\n        });\n    }\n    return refreshSnap({\n        state: state,\n        dimensions: dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"DRAGGING\"\n        }, state, {\n            scrollJumpRequest: null\n        });\n    }\n    return state;\n}\nvar idle = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = function(state, action) {\n    if (state === void 0) {\n        state = idle;\n    }\n    if (action.type === \"FLUSH\") {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, idle, {\n            shouldFlush: true\n        });\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        var _action$payload = action.payload, critical = _action$payload.critical, clientSelection = _action$payload.clientSelection, viewport = _action$payload.viewport, dimensions = _action$payload.dimensions, movementMode = _action$payload.movementMode;\n        var draggable = dimensions.draggables[critical.draggable.id];\n        var home = dimensions.droppables[critical.droppable.id];\n        var client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        var initial = {\n            client: client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function(item) {\n            return !item.isFixedOnPage;\n        });\n        var _getLiftEffect = getLiftEffect({\n            draggable: draggable,\n            home: home,\n            draggables: dimensions.draggables,\n            viewport: viewport\n        }), impact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;\n        var result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical: critical,\n            movementMode: movementMode,\n            dimensions: dimensions,\n            initial: initial,\n            current: initial,\n            isWindowScrollAllowed: isWindowScrollAllowed,\n            impact: impact,\n            afterCritical: afterCritical,\n            onLiftImpact: impact,\n            viewport: viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Collection cannot start from phase \" + state.phase) : 0 : void 0;\n        var _result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"COLLECTING\"\n        }, state, {\n            phase: \"COLLECTING\"\n        });\n        return _result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, \"Unexpected \" + action.type + \" received in phase \" + state.phase) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state: state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : 0 : void 0;\n        var _clientSelection = action.payload.client;\n        if (isEqual(_clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state: state,\n            clientSelection: _clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, action.type + \" not permitted in phase \" + state.phase) : 0 : void 0;\n        var _action$payload2 = action.payload, id = _action$payload2.id, newScroll = _action$payload2.newScroll;\n        var target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        var scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : 0 : void 0;\n        var _action$payload3 = action.payload, _id = _action$payload3.id, isEnabled = _action$payload3.isEnabled;\n        var _target = state.dimensions.droppables[_id];\n        !_target ?  true ? invariant(false, \"Cannot find Droppable[id: \" + _id + \"] to toggle its enabled state\") : 0 : void 0;\n        !(_target.isEnabled !== isEnabled) ?  true ? invariant(false, \"Trying to set droppable isEnabled to \" + String(isEnabled) + \"\\n      but it is already \" + String(_target.isEnabled)) : 0 : void 0;\n        var updated = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, _target, {\n            isEnabled: isEnabled\n        });\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, \"Attempting to move in an unsupported phase \" + state.phase) : 0 : void 0;\n        var _action$payload4 = action.payload, _id2 = _action$payload4.id, isCombineEnabled = _action$payload4.isCombineEnabled;\n        var _target2 = state.dimensions.droppables[_id2];\n        !_target2 ?  true ? invariant(false, \"Cannot find Droppable[id: \" + _id2 + \"] to toggle its isCombineEnabled state\") : 0 : void 0;\n        !(_target2.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, \"Trying to set droppable isCombineEnabled to \" + String(isCombineEnabled) + \"\\n      but it is already \" + String(_target2.isCombineEnabled)) : 0 : void 0;\n        var _updated = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, _target2, {\n            isCombineEnabled: isCombineEnabled\n        });\n        return postDroppableChange(state, _updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, \"Cannot move by window in phase \" + state.phase) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        var _newScroll = action.payload.newScroll;\n        if (isEqual(state.viewport.scroll.current, _newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        var _viewport = scrollViewport(state.viewport, _newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state: state,\n                viewport: _viewport\n            });\n        }\n        return update({\n            state: state,\n            viewport: _viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        var maxScroll = action.payload.maxScroll;\n        if (isEqual(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        var withMaxScroll = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.viewport, {\n            scroll: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, state.viewport.scroll, {\n                max: maxScroll\n            })\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"DRAGGING\"\n        }, state, {\n            viewport: withMaxScroll\n        });\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, action.type + \" received while not in DRAGGING phase\") : 0 : void 0;\n        var _result2 = moveInDirection({\n            state: state,\n            type: action.type\n        });\n        if (!_result2) {\n            return state;\n        }\n        return update({\n            state: state,\n            impact: _result2.impact,\n            clientSelection: _result2.clientSelection,\n            scrollJumpRequest: _result2.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        var reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        var newState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            phase: \"DROP_PENDING\"\n        }, state, {\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason: reason\n        });\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        var _action$payload5 = action.payload, completed = _action$payload5.completed, dropDuration = _action$payload5.dropDuration, newHomeClientOffset = _action$payload5.newHomeClientOffset;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, \"Cannot animate drop from phase \" + state.phase) : 0 : void 0;\n        var _result3 = {\n            phase: \"DROP_ANIMATING\",\n            completed: completed,\n            dropDuration: dropDuration,\n            newHomeClientOffset: newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return _result3;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        var _completed = action.payload.completed;\n        return {\n            phase: \"IDLE\",\n            completed: _completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nvar beforeInitialCapture = function beforeInitialCapture(args) {\n    return {\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    };\n};\nvar lift = function lift(args) {\n    return {\n        type: \"LIFT\",\n        payload: args\n    };\n};\nvar initialPublish = function initialPublish(args) {\n    return {\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    };\n};\nvar publishWhileDragging = function publishWhileDragging(args) {\n    return {\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    };\n};\nvar collectionStarting = function collectionStarting() {\n    return {\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    };\n};\nvar updateDroppableScroll = function updateDroppableScroll(args) {\n    return {\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    };\n};\nvar updateDroppableIsEnabled = function updateDroppableIsEnabled(args) {\n    return {\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    };\n};\nvar updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(args) {\n    return {\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    };\n};\nvar move = function move(args) {\n    return {\n        type: \"MOVE\",\n        payload: args\n    };\n};\nvar moveByWindowScroll = function moveByWindowScroll(args) {\n    return {\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    };\n};\nvar updateViewportMaxScroll = function updateViewportMaxScroll(args) {\n    return {\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    };\n};\nvar moveUp = function moveUp() {\n    return {\n        type: \"MOVE_UP\",\n        payload: null\n    };\n};\nvar moveDown = function moveDown() {\n    return {\n        type: \"MOVE_DOWN\",\n        payload: null\n    };\n};\nvar moveRight = function moveRight() {\n    return {\n        type: \"MOVE_RIGHT\",\n        payload: null\n    };\n};\nvar moveLeft = function moveLeft() {\n    return {\n        type: \"MOVE_LEFT\",\n        payload: null\n    };\n};\nvar flush = function flush() {\n    return {\n        type: \"FLUSH\",\n        payload: null\n    };\n};\nvar animateDrop = function animateDrop(args) {\n    return {\n        type: \"DROP_ANIMATE\",\n        payload: args\n    };\n};\nvar completeDrop = function completeDrop(args) {\n    return {\n        type: \"DROP_COMPLETE\",\n        payload: args\n    };\n};\nvar drop = function drop(args) {\n    return {\n        type: \"DROP\",\n        payload: args\n    };\n};\nvar dropPending = function dropPending(args) {\n    return {\n        type: \"DROP_PENDING\",\n        payload: args\n    };\n};\nvar dropAnimationFinished = function dropAnimationFinished() {\n    return {\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    };\n};\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    var indexes = insideDestination.map(function(d) {\n        return d.descriptor.index;\n    });\n    var errors = {};\n    for(var i = 1; i < indexes.length; i++){\n        var current = indexes[i];\n        var previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    var formatted = indexes.map(function(index) {\n        var hasError = Boolean(errors[index]);\n        return hasError ? \"[\\uD83D\\uDD25\" + index + \"]\" : \"\" + index;\n    }).join(\", \");\n     true ? warning(\"\\n    Detected non-consecutive <Draggable /> indexes.\\n\\n    (This can cause unexpected bugs)\\n\\n    \" + formatted + \"\\n  \") : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift$1 = function(marshal) {\n    return function(_ref) {\n        var getState = _ref.getState, dispatch = _ref.dispatch;\n        return function(next) {\n            return function(action) {\n                if (action.type !== \"LIFT\") {\n                    next(action);\n                    return;\n                }\n                var _action$payload = action.payload, id = _action$payload.id, clientSelection = _action$payload.clientSelection, movementMode = _action$payload.movementMode;\n                var initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode: movementMode\n                }));\n                var scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                var request = {\n                    draggableId: id,\n                    scrollOptions: scrollOptions\n                };\n                var _marshal$startPublish = marshal.startPublishing(request), critical = _marshal$startPublish.critical, dimensions = _marshal$startPublish.dimensions, viewport = _marshal$startPublish.viewport;\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical: critical,\n                    dimensions: dimensions,\n                    clientSelection: clientSelection,\n                    movementMode: movementMode,\n                    viewport: viewport\n                }));\n            };\n        };\n    };\n};\nvar style = function(marshal) {\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    marshal.dragging();\n                }\n                if (action.type === \"DROP_ANIMATE\") {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\") {\n                    marshal.resting();\n                }\n                next(action);\n            };\n        };\n    };\n};\nvar curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nvar combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nvar timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nvar outOfTheWayTiming = timings.outOfTheWay + \"s \" + curves.outOfTheWay;\nvar transitions = {\n    fluid: \"opacity \" + outOfTheWayTiming,\n    snap: \"transform \" + outOfTheWayTiming + \", opacity \" + outOfTheWayTiming,\n    drop: function drop(duration) {\n        var timing = duration + \"s \" + curves.drop;\n        return \"transform \" + timing + \", opacity \" + timing;\n    },\n    outOfTheWay: \"transform \" + outOfTheWayTiming,\n    placeholder: \"height \" + outOfTheWayTiming + \", width \" + outOfTheWayTiming + \", margin \" + outOfTheWayTiming\n};\nvar moveTo = function moveTo(offset) {\n    return isEqual(offset, origin) ? null : \"translate(\" + offset.x + \"px, \" + offset.y + \"px)\";\n};\nvar transforms = {\n    moveTo: moveTo,\n    drop: function drop(offset, isCombining) {\n        var translate = moveTo(offset);\n        if (!translate) {\n            return null;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return translate + \" scale(\" + combine.scale.drop + \")\";\n    }\n};\nvar minDropTime = timings.minDropTime, maxDropTime = timings.maxDropTime;\nvar dropTimeRange = maxDropTime - minDropTime;\nvar maxDropTimeAtDistance = 1500;\nvar cancelDropModifier = 0.6;\nvar getDropDuration = function(_ref) {\n    var current = _ref.current, destination = _ref.destination, reason = _ref.reason;\n    var distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    var percentage = distance$1 / maxDropTimeAtDistance;\n    var duration = minDropTime + dropTimeRange * percentage;\n    var withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = function(_ref) {\n    var impact = _ref.impact, draggable = _ref.draggable, dimensions = _ref.dimensions, viewport = _ref.viewport, afterCritical = _ref.afterCritical;\n    var draggables = dimensions.draggables, droppables = dimensions.droppables;\n    var droppableId = whatIsDraggedOver(impact);\n    var destination = droppableId ? droppables[droppableId] : null;\n    var home = droppables[draggable.descriptor.droppableId];\n    var newClientCenter = getClientBorderBoxCenter({\n        impact: impact,\n        draggable: draggable,\n        draggables: draggables,\n        afterCritical: afterCritical,\n        droppable: destination || home,\n        viewport: viewport\n    });\n    var offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = function(_ref) {\n    var draggables = _ref.draggables, reason = _ref.reason, lastImpact = _ref.lastImpact, home = _ref.home, viewport = _ref.viewport, onLiftImpact = _ref.onLiftImpact;\n    if (!lastImpact.at || reason !== \"DROP\") {\n        var recomputedHomeImpact = recompute({\n            draggables: draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport: viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    var withoutMovement = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, lastImpact, {\n        displaced: emptyGroups\n    });\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nvar drop$1 = function(_ref) {\n    var getState = _ref.getState, dispatch = _ref.dispatch;\n    return function(next) {\n        return function(action) {\n            if (action.type !== \"DROP\") {\n                next(action);\n                return;\n            }\n            var state = getState();\n            var reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason: reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            var isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, \"Cannot drop in phase: \" + state.phase) : 0 : void 0;\n            var critical = state.critical;\n            var dimensions = state.dimensions;\n            var draggable = dimensions.draggables[state.critical.draggable.id];\n            var _getDropImpact = getDropImpact({\n                reason: reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            }), impact = _getDropImpact.impact, didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;\n            var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            var combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            var source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            var result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source: source,\n                reason: reason,\n                mode: state.movementMode,\n                destination: destination,\n                combine: combine\n            };\n            var newHomeClientOffset = getNewHomeClientOffset({\n                impact: impact,\n                draggable: draggable,\n                dimensions: dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            var completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result: result,\n                impact: impact\n            };\n            var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed: completed\n                }));\n                return;\n            }\n            var dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason: reason\n            });\n            var args = {\n                newHomeClientOffset: newHomeClientOffset,\n                dropDuration: dropDuration,\n                completed: completed\n            };\n            dispatch(animateDrop(args));\n        };\n    };\n};\nvar getWindowScroll = function() {\n    return {\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    };\n};\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: function fn(event) {\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener(_ref) {\n    var onWindowScroll = _ref.onWindowScroll;\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    var scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(updateScroll);\n    var binding = getWindowScrollBinding(scheduled);\n    var unbind = noop;\n    function isActive() {\n        return unbind !== noop;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop;\n    }\n    return {\n        start: start,\n        stop: stop,\n        isActive: isActive\n    };\n}\nvar shouldEnd = function shouldEnd(action) {\n    return action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\n};\nvar scrollListener = function(store) {\n    var listener = getScrollListener({\n        onWindowScroll: function onWindowScroll(newScroll) {\n            store.dispatch(moveByWindowScroll({\n                newScroll: newScroll\n            }));\n        }\n    });\n    return function(next) {\n        return function(action) {\n            if (!listener.isActive() && action.type === \"INITIAL_PUBLISH\") {\n                listener.start();\n            }\n            if (listener.isActive() && shouldEnd(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n    };\n};\nvar getExpiringAnnounce = function(announce) {\n    var wasCalled = false;\n    var isExpired = false;\n    var timeoutId = setTimeout(function() {\n        isExpired = true;\n    });\n    var result = function result(message) {\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(\"\\n        Announcements cannot be made asynchronously.\\n        Default message has already been announced.\\n      \") : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = function() {\n        return wasCalled;\n    };\n    return result;\n};\nvar getAsyncMarshal = function() {\n    var entries = [];\n    var execute = function execute(timerId) {\n        var index = findIndex(entries, function(item) {\n            return item.timerId === timerId;\n        });\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        var _entries$splice = entries.splice(index, 1), entry = _entries$splice[0];\n        entry.callback();\n    };\n    var add = function add(fn) {\n        var timerId = setTimeout(function() {\n            return execute(timerId);\n        });\n        var entry = {\n            timerId: timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    var flush = function flush() {\n        if (!entries.length) {\n            return;\n        }\n        var shallow = [].concat(entries);\n        entries.length = 0;\n        shallow.forEach(function(entry) {\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add: add,\n        flush: flush\n    };\n};\nvar areLocationsEqual = function areLocationsEqual(first, second) {\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nvar isCombineEqual = function isCombineEqual(first, second) {\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nvar isCriticalEqual = function isCriticalEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nvar withTimings = function withTimings(key, fn) {\n    start();\n    fn();\n    finish();\n};\nvar getDragStart = function getDragStart(critical, mode) {\n    return {\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode: mode\n    };\n};\nvar execute = function execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    var willExpire = getExpiringAnnounce(announce);\n    var provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n};\nvar getPublisher = function(getResponders, announce) {\n    var asyncMarshal = getAsyncMarshal();\n    var dragging = null;\n    var beforeCapture = function beforeCapture(draggableId, mode) {\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", function() {\n            var fn = getResponders().onBeforeCapture;\n            if (fn) {\n                var before = {\n                    draggableId: draggableId,\n                    mode: mode\n                };\n                fn(before);\n            }\n        });\n    };\n    var beforeStart = function beforeStart(critical, mode) {\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", function() {\n            var fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    var start = function start(critical, mode) {\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        var data = getDragStart(critical, mode);\n        dragging = {\n            mode: mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(function() {\n            withTimings(\"onDragStart\", function() {\n                return execute(getResponders().onDragStart, data, announce, preset.onDragStart);\n            });\n        });\n    };\n    var update = function update(critical, impact) {\n        var location = tryGetDestination(impact);\n        var combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        var data = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, getDragStart(critical, dragging.mode), {\n            combine: combine,\n            destination: location\n        });\n        asyncMarshal.add(function() {\n            withTimings(\"onDragUpdate\", function() {\n                return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);\n            });\n        });\n    };\n    var flush = function flush() {\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    var drop = function drop(result) {\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", function() {\n            return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);\n        });\n    };\n    var abort = function abort() {\n        if (!dragging) {\n            return;\n        }\n        var result = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, getDragStart(dragging.lastCritical, dragging.mode), {\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        });\n        drop(result);\n    };\n    return {\n        beforeCapture: beforeCapture,\n        beforeStart: beforeStart,\n        start: start,\n        update: update,\n        flush: flush,\n        drop: drop,\n        abort: abort\n    };\n};\nvar responders = function(getResponders, announce) {\n    var publisher = getPublisher(getResponders, announce);\n    return function(store) {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"BEFORE_INITIAL_CAPTURE\") {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    var critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    var result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (action.type === \"FLUSH\") {\n                    publisher.abort();\n                    return;\n                }\n                var state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n        };\n    };\n};\nvar dropAnimationFinish = function(store) {\n    return function(next) {\n        return function(action) {\n            if (action.type !== \"DROP_ANIMATION_FINISHED\") {\n                next(action);\n                return;\n            }\n            var state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\n    };\n};\nvar dropAnimationFlushOnScroll = function(store) {\n    var unbind = null;\n    var frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return function(next) {\n        return function(action) {\n            if (action.type === \"FLUSH\" || action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATION_FINISHED\") {\n                clear();\n            }\n            next(action);\n            if (action.type !== \"DROP_ANIMATE\") {\n                return;\n            }\n            var binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    var state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(function() {\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n    };\n};\nvar dimensionMarshalStopper = function(marshal) {\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"DROP_COMPLETE\" || action.type === \"FLUSH\" || action.type === \"DROP_ANIMATE\") {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\n        };\n    };\n};\nvar focus = function(marshal) {\n    var isWatching = false;\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (action.type === \"FLUSH\") {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (action.type === \"DROP_COMPLETE\") {\n                    isWatching = false;\n                    var result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n        };\n    };\n};\nvar shouldStop = function shouldStop(action) {\n    return action.type === \"DROP_COMPLETE\" || action.type === \"DROP_ANIMATE\" || action.type === \"FLUSH\";\n};\nvar autoScroll = function(autoScroller) {\n    return function(store) {\n        return function(next) {\n            return function(action) {\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (action.type === \"INITIAL_PUBLISH\") {\n                    next(action);\n                    var state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\n        };\n    };\n};\nvar pendingDrop = function(store) {\n    return function(next) {\n        return function(action) {\n            next(action);\n            if (action.type !== \"PUBLISH_WHILE_DRAGGING\") {\n                return;\n            }\n            var postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop({\n                reason: postActionState.reason\n            }));\n        };\n    };\n};\nvar composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_8__.compose;\nvar createStore = function(_ref) {\n    var dimensionMarshal = _ref.dimensionMarshal, focusMarshal = _ref.focusMarshal, styleMarshal = _ref.styleMarshal, getResponders = _ref.getResponders, announce = _ref.announce, autoScroller = _ref.autoScroller;\n    return (0,redux__WEBPACK_IMPORTED_MODULE_8__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_8__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\n};\nvar clean$1 = function clean() {\n    return {\n        additions: {},\n        removals: {},\n        modified: {}\n    };\n};\nfunction createPublisher(_ref) {\n    var registry = _ref.registry, callbacks = _ref.callbacks;\n    var staging = clean$1();\n    var frameId = null;\n    var collect = function collect() {\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(function() {\n            frameId = null;\n            start();\n            var _staging = staging, additions = _staging.additions, removals = _staging.removals, modified = _staging.modified;\n            var added = Object.keys(additions).map(function(id) {\n                return registry.draggable.getById(id).getDimension(origin);\n            }).sort(function(a, b) {\n                return a.descriptor.index - b.descriptor.index;\n            });\n            var updated = Object.keys(modified).map(function(id) {\n                var entry = registry.droppable.getById(id);\n                var scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll: scroll\n                };\n            });\n            var result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    var add = function add(entry) {\n        var id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    var remove = function remove(entry) {\n        var descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    var stop = function stop() {\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add: add,\n        remove: remove,\n        stop: stop\n    };\n}\nvar getMaxScroll = function(_ref) {\n    var scrollHeight = _ref.scrollHeight, scrollWidth = _ref.scrollWidth, height = _ref.height, width = _ref.width;\n    var maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    var adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = function() {\n    var doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = function() {\n    var doc = getDocumentElement();\n    var maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = function() {\n    var scroll = getWindowScroll();\n    var maxScroll = getMaxWindowScroll();\n    var top = scroll.y;\n    var left = scroll.x;\n    var doc = getDocumentElement();\n    var width = doc.clientWidth;\n    var height = doc.clientHeight;\n    var right = left + width;\n    var bottom = top + height;\n    var frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)({\n        top: top,\n        left: left,\n        right: right,\n        bottom: bottom\n    });\n    var viewport = {\n        frame: frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = function(_ref) {\n    var critical = _ref.critical, scrollOptions = _ref.scrollOptions, registry = _ref.registry;\n    start();\n    var viewport = getViewport();\n    var windowScroll = viewport.scroll.current;\n    var home = critical.droppable;\n    var droppables = registry.droppable.getAllByType(home.type).map(function(entry) {\n        return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);\n    });\n    var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function(entry) {\n        return entry.getDimension(windowScroll);\n    });\n    var dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    var result = {\n        dimensions: dimensions,\n        critical: critical,\n        viewport: viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    var home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(\"\\n      You are attempting to add or remove a Draggable [id: \" + entry.descriptor.id + \"]\\n      while a drag is occurring. This is only supported for virtual lists.\\n\\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\\n    \") : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = function(registry, callbacks) {\n    var collection = null;\n    var publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry: registry\n    });\n    var updateDroppableIsEnabled = function updateDroppableIsEnabled(id, isEnabled) {\n        !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update is enabled flag of Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id: id,\n            isEnabled: isEnabled\n        });\n    };\n    var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled(id, isCombineEnabled) {\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update isCombineEnabled flag of Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id: id,\n            isCombineEnabled: isCombineEnabled\n        });\n    };\n    var updateDroppableScroll = function updateDroppableScroll(id, newScroll) {\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, \"Cannot update the scroll on Droppable \" + id + \" as it is not registered\") : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id: id,\n            newScroll: newScroll\n        });\n    };\n    var scrollDroppable = function scrollDroppable(id, change) {\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    var stopPublishing = function stopPublishing() {\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        var home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach(function(entry) {\n            return entry.callbacks.dragStopped();\n        });\n        collection.unsubscribe();\n        collection = null;\n    };\n    var subscriber = function subscriber(event) {\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        var dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    var startPublishing = function startPublishing(request) {\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        var entry = registry.draggable.getById(request.draggableId);\n        var home = registry.droppable.getById(entry.descriptor.droppableId);\n        var critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        var unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical: critical,\n            unsubscribe: unsubscribe\n        };\n        return getInitialPublish({\n            critical: critical,\n            registry: registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    var marshal = {\n        updateDroppableIsEnabled: updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n        scrollDroppable: scrollDroppable,\n        updateDroppableScroll: updateDroppableScroll,\n        startPublishing: startPublishing,\n        stopPublishing: stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = function(state, id) {\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = function(change) {\n    window.scrollBy(change.x, change.y);\n};\nvar getScrollableDroppables = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(droppables) {\n    return toDroppableList(droppables).filter(function(droppable) {\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    });\n});\nvar getScrollableDroppableOver = function getScrollableDroppableOver(target, droppables) {\n    var maybe = find(getScrollableDroppables(droppables), function(droppable) {\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    });\n    return maybe;\n};\nvar getBestScrollableDroppable = function(_ref) {\n    var center = _ref.center, destination = _ref.destination, droppables = _ref.droppables;\n    if (destination) {\n        var _dimension = droppables[destination];\n        if (!_dimension.frame) {\n            return null;\n        }\n        return _dimension;\n    }\n    var dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nvar config = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: function ease(percentage) {\n        return Math.pow(percentage, 2);\n    },\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    }\n};\nvar getDistanceThresholds = function(container, axis) {\n    var startScrollingFrom = container[axis.size] * config.startFromPercentage;\n    var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;\n    var thresholds = {\n        startScrollingFrom: startScrollingFrom,\n        maxScrollValueAt: maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = function(_ref) {\n    var startOfRange = _ref.startOfRange, endOfRange = _ref.endOfRange, current = _ref.current;\n    var range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(\"\\n      Detected distance range of 0 in the fluid auto scroller\\n      This is unexpected and would cause a divide by 0 issue.\\n      Not allowing an auto scroll\\n    \") : 0;\n        return 0;\n    }\n    var currentInRange = current - startOfRange;\n    var percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = function(distanceToEdge, thresholds) {\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return config.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    var percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    var scroll = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar accelerateAt = config.durationDampening.accelerateAt;\nvar stopAt = config.durationDampening.stopDampeningAt;\nvar dampenValueByTime = function(proposedScroll, dragStartTime) {\n    var startOfRange = dragStartTime;\n    var endOfRange = stopAt;\n    var now = Date.now();\n    var runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    var betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange: endOfRange,\n        current: runTime\n    });\n    var scroll = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = function(_ref) {\n    var distanceToEdge = _ref.distanceToEdge, thresholds = _ref.thresholds, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var scroll = getValueFromDistance(distanceToEdge, thresholds);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime), minScroll);\n};\nvar getScrollOnAxis = function(_ref) {\n    var container = _ref.container, distanceToEdges = _ref.distanceToEdges, dragStartTime = _ref.dragStartTime, axis = _ref.axis, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var thresholds = getDistanceThresholds(container, axis);\n    var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds: thresholds,\n            dragStartTime: dragStartTime,\n            shouldUseTimeDampening: shouldUseTimeDampening\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds: thresholds,\n        dragStartTime: dragStartTime,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n};\nvar adjustForSizeLimits = function(_ref) {\n    var container = _ref.container, subject = _ref.subject, proposedScroll = _ref.proposedScroll;\n    var isTooBigVertically = subject.height > container.height;\n    var isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nvar clean$2 = apply(function(value) {\n    return value === 0 ? 0 : value;\n});\nvar getScroll = function(_ref) {\n    var dragStartTime = _ref.dragStartTime, container = _ref.container, subject = _ref.subject, center = _ref.center, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    var y = getScrollOnAxis({\n        container: container,\n        distanceToEdges: distanceToEdges,\n        dragStartTime: dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    var x = getScrollOnAxis({\n        container: container,\n        distanceToEdges: distanceToEdges,\n        dragStartTime: dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    var required = clean$2({\n        x: x,\n        y: y\n    });\n    if (isEqual(required, origin)) {\n        return null;\n    }\n    var limited = adjustForSizeLimits({\n        container: container,\n        subject: subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual(limited, origin) ? null : limited;\n};\nvar smallestSigned = apply(function(value) {\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nvar getOverlap = function() {\n    var getRemainder = function getRemainder(target, max) {\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return function(_ref) {\n        var current = _ref.current, max = _ref.max, change = _ref.change;\n        var targetScroll = add(current, change);\n        var overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n}();\nvar canPartiallyScroll = function canPartiallyScroll(_ref2) {\n    var rawMax = _ref2.max, current = _ref2.current, change = _ref2.change;\n    var max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    var smallestChange = smallestSigned(change);\n    var overlap = getOverlap({\n        max: max,\n        current: current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nvar canScrollWindow = function canScrollWindow(viewport, change) {\n    return canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change: change\n    });\n};\nvar getWindowOverlap = function getWindowOverlap(viewport, change) {\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    var max = viewport.scroll.max;\n    var current = viewport.scroll.current;\n    return getOverlap({\n        current: current,\n        max: max,\n        change: change\n    });\n};\nvar canScrollDroppable = function canScrollDroppable(droppable, change) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change: change\n    });\n};\nvar getDroppableOverlap = function getDroppableOverlap(droppable, change) {\n    var frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change: change\n    });\n};\nvar getWindowScrollChange = function(_ref) {\n    var viewport = _ref.viewport, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var scroll = getScroll({\n        dragStartTime: dragStartTime,\n        container: viewport.frame,\n        subject: subject,\n        center: center,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = function(_ref) {\n    var droppable = _ref.droppable, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;\n    var frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    var scroll = getScroll({\n        dragStartTime: dragStartTime,\n        container: frame.pageMarginBox,\n        subject: subject,\n        center: center,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll$1 = function(_ref) {\n    var state = _ref.state, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening, scrollWindow = _ref.scrollWindow, scrollDroppable = _ref.scrollDroppable;\n    var center = state.current.page.borderBoxCenter;\n    var draggable = state.dimensions.draggables[state.critical.draggable.id];\n    var subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        var viewport = state.viewport;\n        var _change = getWindowScrollChange({\n            dragStartTime: dragStartTime,\n            viewport: viewport,\n            subject: subject,\n            center: center,\n            shouldUseTimeDampening: shouldUseTimeDampening\n        });\n        if (_change) {\n            scrollWindow(_change);\n            return;\n        }\n    }\n    var droppable = getBestScrollableDroppable({\n        center: center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    var change = getDroppableScrollChange({\n        dragStartTime: dragStartTime,\n        droppable: droppable,\n        subject: subject,\n        center: center,\n        shouldUseTimeDampening: shouldUseTimeDampening\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = function(_ref) {\n    var scrollWindow = _ref.scrollWindow, scrollDroppable = _ref.scrollDroppable;\n    var scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(scrollWindow);\n    var scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(scrollDroppable);\n    var dragging = null;\n    var tryScroll = function tryScroll(state) {\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        var _dragging = dragging, shouldUseTimeDampening = _dragging.shouldUseTimeDampening, dragStartTime = _dragging.dragStartTime;\n        scroll$1({\n            state: state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime: dragStartTime,\n            shouldUseTimeDampening: shouldUseTimeDampening\n        });\n    };\n    var start$1 = function start$1(state) {\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        var dragStartTime = Date.now();\n        var wasScrollNeeded = false;\n        var fakeScrollCallback = function fakeScrollCallback() {\n            wasScrollNeeded = true;\n        };\n        scroll$1({\n            state: state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback\n        });\n        dragging = {\n            dragStartTime: dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    var stop = function stop() {\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop: stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = function(_ref) {\n    var move = _ref.move, scrollDroppable = _ref.scrollDroppable, scrollWindow = _ref.scrollWindow;\n    var moveByOffset = function moveByOffset(state, offset) {\n        var client = add(state.current.client.selection, offset);\n        move({\n            client: client\n        });\n    };\n    var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan(droppable, change) {\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        var overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        var whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        var remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan(isWindowScrollAllowed, viewport, change) {\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        var overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        var whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        var remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    var jumpScroller = function jumpScroller(state) {\n        var request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        var destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        var viewport = state.viewport;\n        var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = function(_ref) {\n    var scrollDroppable = _ref.scrollDroppable, scrollWindow = _ref.scrollWindow, move = _ref.move;\n    var fluidScroller = createFluidScroller({\n        scrollWindow: scrollWindow,\n        scrollDroppable: scrollDroppable\n    });\n    var jumpScroll = createJumpScroller({\n        move: move,\n        scrollWindow: scrollWindow,\n        scrollDroppable: scrollDroppable\n    });\n    var scroll = function scroll(state) {\n        if (state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    var scroller = {\n        scroll: scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nvar prefix$1 = \"data-rbd\";\nvar dragHandle = function() {\n    var base = prefix$1 + \"-drag-handle\";\n    return {\n        base: base,\n        draggableId: base + \"-draggable-id\",\n        contextId: base + \"-context-id\"\n    };\n}();\nvar draggable = function() {\n    var base = prefix$1 + \"-draggable\";\n    return {\n        base: base,\n        contextId: base + \"-context-id\",\n        id: base + \"-id\"\n    };\n}();\nvar droppable = function() {\n    var base = prefix$1 + \"-droppable\";\n    return {\n        base: base,\n        contextId: base + \"-context-id\",\n        id: base + \"-id\"\n    };\n}();\nvar scrollContainer = {\n    contextId: prefix$1 + \"-scroll-container-context-id\"\n};\nvar makeGetSelector = function makeGetSelector(context) {\n    return function(attribute) {\n        return \"[\" + attribute + '=\"' + context + '\"]';\n    };\n};\nvar getStyles = function getStyles(rules, property) {\n    return rules.map(function(rule) {\n        var value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return rule.selector + \" { \" + value + \" }\";\n    }).join(\" \");\n};\nvar noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = function(contextId) {\n    var getSelector = makeGetSelector(contextId);\n    var dragHandle$1 = function() {\n        var grabCursor = \"\\n      cursor: -webkit-grab;\\n      cursor: grab;\\n    \";\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: \"\\n          -webkit-touch-callout: none;\\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\\n          touch-action: manipulation;\\n        \",\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    }();\n    var draggable$1 = function() {\n        var transition = \"\\n      transition: \" + transitions.outOfTheWay + \";\\n    \";\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    }();\n    var droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: \"overflow-anchor: none;\"\n        }\n    };\n    var body = {\n        selector: \"body\",\n        styles: {\n            dragging: \"\\n        cursor: grabbing;\\n        cursor: -webkit-grabbing;\\n        user-select: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        overflow-anchor: none;\\n      \"\n        }\n    };\n    var rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nvar useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar getHead = function getHead() {\n    var head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nvar createStyleEl = function createStyleEl(nonce) {\n    var el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    var styles = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return getStyles$1(contextId);\n    }, [\n        contextId\n    ]);\n    var alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var setDynamicStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)((0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(proposed) {\n        var el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    var setAlwaysStyle = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(proposed) {\n        var el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useIsomorphicLayoutEffect(function() {\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        var always = createStyleEl(nonce);\n        var dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(prefix$1 + \"-always\", contextId);\n        dynamic.setAttribute(prefix$1 + \"-dynamic\", contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return function() {\n            var remove = function remove(ref) {\n                var current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    var dragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return setDynamicStyle(styles.dragging);\n    }, [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    var dropping = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(reason) {\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    var resting = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    var marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            dragging: dragging,\n            dropping: dropping,\n            resting: resting\n        };\n    }, [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nvar getWindowFromEl = function(el) {\n    return el && el.ownerDocument ? el.ownerDocument.defaultView : window;\n};\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    var selector = \"[\" + dragHandle.contextId + '=\"' + contextId + '\"]';\n    var possible = toArray(document.querySelectorAll(selector));\n    if (!possible.length) {\n         true ? warning('Unable to find any drag handles in the context \"' + contextId + '\"') : 0;\n        return null;\n    }\n    var handle = find(possible, function(el) {\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning('Unable to find drag handle with id \"' + draggableId + '\" as no handle with a matching id was found') : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    var entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    var recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    var register = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function register(id, focus) {\n        var entry = {\n            id: id,\n            focus: focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            var entries = entriesRef.current;\n            var current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    var tryGiveFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryGiveFocus(tryGiveFocusTo) {\n        var handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    var tryShiftRecord = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    var tryRestoreFocusRecorded = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(function() {\n            restoreFocusFrameRef.current = null;\n            var record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    var tryRecordFocus = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryRecordFocus(id) {\n        recordRef.current = null;\n        var focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useIsomorphicLayoutEffect(function() {\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            var frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    var marshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            register: register,\n            tryRecordFocus: tryRecordFocus,\n            tryRestoreFocusRecorded: tryRestoreFocusRecorded,\n            tryShiftRecord: tryShiftRecord\n        };\n    }, [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    var entries = {\n        draggables: {},\n        droppables: {}\n    };\n    var subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            var index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach(function(cb) {\n                return cb(event);\n            });\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        var entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, \"Cannot find draggable entry with id [\" + id + \"]\") : 0 : void 0;\n        return entry;\n    }\n    var draggableAPI = {\n        register: function register(entry) {\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: function update(entry, last) {\n            var current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: function unregister(entry) {\n            var draggableId = entry.descriptor.id;\n            var current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            notify({\n                type: \"REMOVAL\",\n                value: entry\n            });\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: function exists(id) {\n            return Boolean(findDraggableById(id));\n        },\n        getAllByType: function getAllByType(type) {\n            return values(entries.draggables).filter(function(entry) {\n                return entry.descriptor.type === type;\n            });\n        }\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        var entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, \"Cannot find droppable entry with id [\" + id + \"]\") : 0 : void 0;\n        return entry;\n    }\n    var droppableAPI = {\n        register: function register(entry) {\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: function unregister(entry) {\n            var current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: function exists(id) {\n            return Boolean(findDroppableById(id));\n        },\n        getAllByType: function getAllByType(type) {\n            return values(entries.droppables).filter(function(entry) {\n                return entry.descriptor.type === type;\n            });\n        }\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe: subscribe,\n        clean: clean\n    };\n}\nfunction useRegistry() {\n    var registry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return function unmount() {\n            requestAnimationFrame(registry.clean);\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = function() {\n    var body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nvar visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nvar getId = function getId(contextId) {\n    return \"rbd-announcement-\" + contextId;\n};\nfunction useAnnouncer(contextId) {\n    var id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return getId(contextId);\n    }, [\n        contextId\n    ]);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        var el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el.style, visuallyHidden);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                var body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    var announce = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(message) {\n        var el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning('\\n      A screen reader message was trying to be announced but it was unable to do so.\\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\\n      Consider calling provided.announce() before the unmount so that the instruction will\\n      not be lost for users relying on a screen reader.\\n\\n      Message not passed to screen reader:\\n\\n      \"' + message + '\"\\n    ') : 0;\n    }, []);\n    return announce;\n}\nvar count = 0;\nvar defaults = {\n    separator: \"::\"\n};\nfunction reset() {\n    count = 0;\n}\nfunction useUniqueId(prefix, options) {\n    if (options === void 0) {\n        options = defaults;\n    }\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return \"\" + prefix + options.separator + count++;\n    }, [\n        options.separator,\n        prefix\n    ]);\n}\nfunction getElementId(_ref) {\n    var contextId = _ref.contextId, uniqueId = _ref.uniqueId;\n    return \"rbd-hidden-text-\" + contextId + \"-\" + uniqueId;\n}\nfunction useHiddenTextElement(_ref2) {\n    var contextId = _ref2.contextId, text = _ref2.text;\n    var uniqueId = useUniqueId(\"hidden-text\", {\n        separator: \"-\"\n    });\n    var id = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return getElementId({\n            contextId: contextId,\n            uniqueId: uniqueId\n        });\n    }, [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        var el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            var body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^16.8.5 || ^17.0.0 || ^18.0.0\",\n    \"react-dom\": \"^16.8.5 || ^17.0.0 || ^18.0.0\"\n};\nvar semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nvar getVersion = function getVersion(value) {\n    var result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, \"Unable to parse React version \" + value) : 0 : void 0;\n    var major = Number(result[1]);\n    var minor = Number(result[2]);\n    var patch = Number(result[3]);\n    return {\n        major: major,\n        minor: minor,\n        patch: patch,\n        raw: value\n    };\n};\nvar isSatisfied = function isSatisfied(expected, actual) {\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = function(peerDepValue, actualValue) {\n    var peerDep = getVersion(peerDepValue);\n    var actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(\"\\n    React version: [\" + actual.raw + \"]\\n    does not satisfy expected peer dependency version: [\" + peerDep.raw + \"]\\n\\n    This can result in run time bugs, and even fatal crashes\\n  \") : 0;\n};\nvar suffix = \"\\n  We expect a html5 doctype: <!doctype html>\\n  This is to ensure consistent browser layout and measurement\\n\\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\\n\";\nvar checkDoctype = function(doc) {\n    var doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(\"\\n      No <!doctype html> found.\\n\\n      \" + suffix + \"\\n    \") : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(\"\\n      Unexpected <!doctype> found: (\" + doctype.name + \")\\n\\n      \" + suffix + \"\\n    \") : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(\"\\n      Unexpected <!doctype> publicId found: (\" + doctype.publicId + \")\\n      A html5 doctype does not have a publicId\\n\\n      \" + suffix + \"\\n    \") : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(function() {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n            try {\n                fn();\n            } catch (e) {\n                error(\"\\n          A setup problem was encountered.\\n\\n          > \" + e.message + \"\\n        \");\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(function() {\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    var lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        var newLock = {\n            abandon: abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed: isClaimed,\n        isActive: isActive,\n        claim: claim,\n        release: release,\n        tryAbandon: tryAbandon\n    };\n}\nvar tab = 9;\nvar enter = 13;\nvar escape = 27;\nvar space = 32;\nvar pageUp = 33;\nvar pageDown = 34;\nvar end = 35;\nvar home = 36;\nvar arrowLeft = 37;\nvar arrowUp = 38;\nvar arrowRight = 39;\nvar arrowDown = 40;\nvar _preventedKeys;\nvar preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);\nvar preventStandardKeyEvents = function(event) {\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nvar supportedEventName = function() {\n    var base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    var candidates = [\n        base,\n        \"ms\" + base,\n        \"webkit\" + base,\n        \"moz\" + base,\n        \"o\" + base\n    ];\n    var supported = find(candidates, function(eventName) {\n        return \"on\" + eventName in document;\n    });\n    return supported || base;\n}();\nvar primaryButton = 0;\nvar sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nvar idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings(_ref) {\n    var cancel = _ref.cancel, completed = _ref.completed, getPhase = _ref.getPhase, setPhase = _ref.setPhase;\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: function fn(event) {\n                var button = event.button, clientX = event.clientX, clientY = event.clientY;\n                if (button !== primaryButton) {\n                    return;\n                }\n                var point = {\n                    x: clientX,\n                    y: clientY\n                };\n                var phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                var pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                var actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions: actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: function fn(event) {\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: function fn() {\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    var phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop);\n    var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                var draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                var actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                var point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        };\n    }, [\n        api\n    ]);\n    var preventForcePressBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: function fn(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                var id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                var options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        };\n    }, [\n        api\n    ]);\n    var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function listenForCapture() {\n        var options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    var stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    var cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    var bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function bindCapturingEvents() {\n        var options = {\n            capture: true,\n            passive: false\n        };\n        var bindings = getCaptureBindings({\n            cancel: cancel,\n            completed: stop,\n            getPhase: function getPhase() {\n                return phaseRef.current;\n            },\n            setPhase: function setPhase(phase) {\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    var startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point: point,\n            actions: actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nvar _scrollJumpKeys;\nfunction noop$1() {}\nvar scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: function fn(event) {\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                var draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                var preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                var isCapturing = true;\n                var actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        };\n    }, [\n        api\n    ]);\n    var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryStartCapture() {\n        var options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nvar idle$2 = {\n    type: \"IDLE\"\n};\nvar timeForLongPress = 120;\nvar forcePressThreshold = 0.15;\nfunction getWindowBindings(_ref) {\n    var cancel = _ref.cancel, getPhase = _ref.getPhase;\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: function fn(event) {\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: function fn(event) {\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings(_ref2) {\n    var cancel = _ref2.cancel, completed = _ref2.completed, getPhase = _ref2.getPhase;\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                var _event$touches$ = event.touches[0], clientX = _event$touches$.clientX, clientY = _event$touches$.clientY;\n                var point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: function fn(event) {\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: function fn(event) {\n                var phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false) : 0 : void 0;\n                var touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                var isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                var shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    var phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$2);\n    var unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop);\n    var getPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    var setPhase = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    var startCaptureBinding = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                var draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                var actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                var touch = event.touches[0];\n                var clientX = touch.clientX, clientY = touch.clientY;\n                var point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        };\n    }, [\n        api\n    ]);\n    var listenForCapture = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function listenForCapture() {\n        var options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    var stop = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle$2);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    var cancel = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    var bindCapturingEvents = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function bindCapturingEvents() {\n        var options = {\n            capture: true,\n            passive: false\n        };\n        var args = {\n            cancel: cancel,\n            completed: stop,\n            getPhase: getPhase\n        };\n        var unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        var unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    var startDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startDragging() {\n        var phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot start dragging from phase \" + phase.type) : 0 : void 0;\n        var actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions: actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    var startPendingDrag = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        var longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point: point,\n            actions: actions,\n            longPressTimerId: longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            var phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle$2);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useIsomorphicLayoutEffect(function webkitHack() {\n        var unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: function fn() {},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(function() {\n        var previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(function() {\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nvar interactiveTagNames = {\n    input: true,\n    button: true,\n    textarea: true,\n    select: true,\n    option: true,\n    optgroup: true,\n    video: true,\n    audio: true\n};\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    var attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    var target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = function(el) {\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getRect)(el.getBoundingClientRect()).center;\n};\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nvar supportedMatchesName = function() {\n    var base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    var candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    var value = find(candidates, function(name) {\n        return name in Element.prototype;\n    });\n    return value || base;\n}();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest$1(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return \"[\" + dragHandle.contextId + '=\"' + contextId + '\"]';\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    var target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    var selector = getSelector(contextId);\n    var handle = closest$1(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    var handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    var selector = \"[\" + draggable.contextId + '=\"' + contextId + '\"]';\n    var possible = toArray(document.querySelectorAll(selector));\n    var draggable$1 = find(possible, function(el) {\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction _isActive(_ref) {\n    var expected = _ref.expected, phase = _ref.phase, isLockActive = _ref.isLockActive, shouldWarn = _ref.shouldWarn;\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(\"\\n        Cannot perform action.\\n        The sensor no longer has an action lock.\\n\\n        Tips:\\n\\n        - Throw away your action handlers when forceStop() is called\\n        - Check actions.isActive() if you really need to\\n      \") : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(\"\\n        Cannot perform action.\\n        The actions you used belong to an outdated phase\\n\\n        Current phase: \" + expected + \"\\n        You called an action from outdated phase: \" + phase + \"\\n\\n        Tips:\\n\\n        - Do not use preDragActions actions after calling preDragActions.lift()\\n      \") : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart(_ref2) {\n    var lockAPI = _ref2.lockAPI, store = _ref2.store, registry = _ref2.registry, draggableId = _ref2.draggableId;\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    var entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(\"Unable to find draggable with id: \" + draggableId) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart(_ref3) {\n    var lockAPI = _ref3.lockAPI, contextId = _ref3.contextId, store = _ref3.store, registry = _ref3.registry, draggableId = _ref3.draggableId, forceSensorStop = _ref3.forceSensorStop, sourceEvent = _ref3.sourceEvent;\n    var shouldStart = canStart({\n        lockAPI: lockAPI,\n        store: store,\n        registry: registry,\n        draggableId: draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    var entry = registry.draggable.getById(draggableId);\n    var el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(\"Unable to find draggable element with id: \" + draggableId) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    var lock = lockAPI.claim(forceSensorStop || noop);\n    var phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (_isActive({\n            expected: expected,\n            phase: phase,\n            isLockActive: isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    var tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift$1(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n            !(phase === \"PRE_DRAG\") ?  true ? invariant(false, \"Cannot lift in phase \" + phase) : 0 : void 0;\n        }\n        store.dispatch(lift(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options) {\n            if (options === void 0) {\n                options = {\n                    shouldBlockNextClick: false\n                };\n            }\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                var unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop({\n                reason: reason\n            }));\n        }\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            isActive: function isActive() {\n                return _isActive({\n                    expected: \"DRAGGING\",\n                    phase: phase,\n                    isLockActive: isLockActive,\n                    shouldWarn: false\n                });\n            },\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: function drop(options) {\n                return finish(\"DROP\", options);\n            },\n            cancel: function cancel(options) {\n                return finish(\"CANCEL\", options);\n            }\n        }, args.actions);\n    }\n    function fluidLift(clientSelection) {\n        var move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(function(client) {\n            tryDispatchWhenDragging(function() {\n                return move({\n                    client: client\n                });\n            });\n        });\n        var api = lift$1({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: function cleanup() {\n                return move$1.cancel();\n            },\n            actions: {\n                move: move$1\n            }\n        });\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, api, {\n            move: move$1\n        });\n    }\n    function snapLift() {\n        var actions = {\n            moveUp: function moveUp$1() {\n                return tryDispatchWhenDragging(moveUp);\n            },\n            moveRight: function moveRight$1() {\n                return tryDispatchWhenDragging(moveRight);\n            },\n            moveDown: function moveDown$1() {\n                return tryDispatchWhenDragging(moveDown);\n            },\n            moveLeft: function moveLeft$1() {\n                return tryDispatchWhenDragging(moveLeft);\n            }\n        };\n        return lift$1({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop,\n            actions: actions\n        });\n    }\n    function abortPreDrag() {\n        var shouldRelease = _isActive({\n            expected: \"PRE_DRAG\",\n            phase: phase,\n            isLockActive: isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    var preDrag = {\n        isActive: function isActive() {\n            return _isActive({\n                expected: \"PRE_DRAG\",\n                phase: phase,\n                isLockActive: isLockActive,\n                shouldWarn: false\n            });\n        },\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift: fluidLift,\n        snapLift: snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nvar defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal(_ref4) {\n    var contextId = _ref4.contextId, store = _ref4.store, registry = _ref4.registry, customSensors = _ref4.customSensors, enableDefaultSensors = _ref4.enableDefaultSensors;\n    var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);\n    var lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function() {\n        return create();\n    })[0];\n    var tryAbandonLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryAbandonLock(previous, current) {\n        if (previous.isDragging && !current.isDragging) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useIsomorphicLayoutEffect(function listenToStore() {\n        var previous = store.getState();\n        var unsubscribe = store.subscribe(function() {\n            var current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    var canGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(draggableId) {\n        return canStart({\n            lockAPI: lockAPI,\n            registry: registry,\n            store: store,\n            draggableId: draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    var tryGetLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(draggableId, forceStop, options) {\n        return tryStart({\n            lockAPI: lockAPI,\n            registry: registry,\n            contextId: contextId,\n            store: store,\n            draggableId: draggableId,\n            forceSensorStop: forceStop,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        });\n    }, [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    var findClosestDraggableId = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(event) {\n        return tryGetClosestDraggableIdFromEvent(contextId, event);\n    }, [\n        contextId\n    ]);\n    var findOptionsForDraggable = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(id) {\n        var entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    var tryReleaseLock = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    var isLockClaimed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(lockAPI.isClaimed, [\n        lockAPI\n    ]);\n    var api = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            canGetLock: canGetLock,\n            tryGetLock: tryGetLock,\n            findClosestDraggableId: findClosestDraggableId,\n            findOptionsForDraggable: findOptionsForDraggable,\n            tryReleaseLock: tryReleaseLock,\n            isLockClaimed: isLockClaimed\n        };\n    }, [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(var i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nvar createResponders = function createResponders(props) {\n    return {\n        onBeforeCapture: props.onBeforeCapture,\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    };\n};\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    var contextId = props.contextId, setCallbacks = props.setCallbacks, sensors = props.sensors, nonce = props.nonce, dragHandleUsageInstructions = props.dragHandleUsageInstructions;\n    var lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    var lastPropsRef = usePrevious(props);\n    var getResponders = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    var announce = useAnnouncer(contextId);\n    var dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId: contextId,\n        text: dragHandleUsageInstructions\n    });\n    var styleMarshal = useStyleMarshal(contextId, nonce);\n    var lazyDispatch = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(action) {\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    var marshalCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return (0,redux__WEBPACK_IMPORTED_MODULE_8__.bindActionCreators)({\n            publishWhileDragging: publishWhileDragging,\n            updateDroppableScroll: updateDroppableScroll,\n            updateDroppableIsEnabled: updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled,\n            collectionStarting: collectionStarting\n        }, lazyDispatch);\n    }, [\n        lazyDispatch\n    ]);\n    var registry = useRegistry();\n    var dimensionMarshal = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    var autoScroller = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return createAutoScroller((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n            scrollWindow: scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable\n        }, (0,redux__WEBPACK_IMPORTED_MODULE_8__.bindActionCreators)({\n            move: move\n        }, lazyDispatch)));\n    }, [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch\n    ]);\n    var focusMarshal = useFocusMarshal(contextId);\n    var store = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return createStore({\n            announce: announce,\n            autoScroller: autoScroller,\n            dimensionMarshal: dimensionMarshal,\n            focusMarshal: focusMarshal,\n            getResponders: getResponders,\n            styleMarshal: styleMarshal\n        });\n    }, [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    var tryResetStore = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var current = getStore(lazyStoreRef);\n        var state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    var isDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var state = getStore(lazyStoreRef).getState();\n        return state.isDragging || state.phase === \"DROP_ANIMATING\";\n    }, []);\n    var appCallbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            isDragging: isDragging,\n            tryAbort: tryResetStore\n        };\n    }, [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    var getCanLift = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(id) {\n        return canStartDrag(getStore(lazyStoreRef).getState(), id);\n    }, []);\n    var getIsMovementAllowed = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return isMovementAllowed(getStore(lazyStoreRef).getState());\n    }, []);\n    var appContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId: contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId: dragHandleUsageInstructionsId,\n            registry: registry\n        };\n    }, [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId: contextId,\n        store: store,\n        registry: registry,\n        customSensors: sensors,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_3__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nvar count$1 = 0;\nfunction reset$1() {\n    count$1 = 0;\n}\nfunction useInstanceCount() {\n    return (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return \"\" + count$1++;\n    }, []);\n}\nfunction resetServerContext() {\n    reset$1();\n    reset();\n}\nfunction DragDropContext(props) {\n    var contextId = useInstanceCount();\n    var dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, function(setCallbacks) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd\n        }, props.children);\n    });\n}\nvar isEqual$1 = function isEqual(base) {\n    return function(value) {\n        return base === value;\n    };\n};\nvar isScroll = isEqual$1(\"scroll\");\nvar isAuto = isEqual$1(\"auto\");\nvar isVisible$1 = isEqual$1(\"visible\");\nvar isEither = function isEither(overflow, fn) {\n    return fn(overflow.overflowX) || fn(overflow.overflowY);\n};\nvar isBoth = function isBoth(overflow, fn) {\n    return fn(overflow.overflowX) && fn(overflow.overflowY);\n};\nvar isElementScrollable = function isElementScrollable(el) {\n    var style = window.getComputedStyle(el);\n    var overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nvar isBodyScrollable = function isBodyScrollable() {\n    if (false) {}\n    var body = getBodyElement();\n    var html = document.documentElement;\n    !html ?  true ? invariant(false) : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    var htmlStyle = window.getComputedStyle(html);\n    var htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible$1)) {\n        return false;\n    }\n     true ? warning(\"\\n    We have detected that your <body> element might be a scroll container.\\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\\n\\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\\n    we will be treating the <body> as *not* a scroll container\\n\\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\\n  \") : 0;\n    return false;\n};\nvar getClosestScrollable = function getClosestScrollable(el) {\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar checkForNestedScrollContainers = function(scrollable) {\n    if (!scrollable) {\n        return;\n    }\n    var anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(\"\\n    Droppable: unsupported nested scroll container detected.\\n    A Droppable can only have one scroll parent (which can be itself)\\n    Nested scroll containers are currently not supported.\\n\\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\\n  \") : 0;\n};\nvar getScroll$1 = function(el) {\n    return {\n        x: el.scrollLeft,\n        y: el.scrollTop\n    };\n};\nvar getIsFixed = function getIsFixed(el) {\n    if (!el) {\n        return false;\n    }\n    var style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = function(start) {\n    var closestScrollable = getClosestScrollable(start);\n    var isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable: closestScrollable,\n        isFixedOnPage: isFixedOnPage\n    };\n};\nvar getDroppableDimension = function(_ref) {\n    var descriptor = _ref.descriptor, isEnabled = _ref.isEnabled, isCombineEnabled = _ref.isCombineEnabled, isFixedOnPage = _ref.isFixedOnPage, direction = _ref.direction, client = _ref.client, page = _ref.page, closest = _ref.closest;\n    var frame = function() {\n        if (!closest) {\n            return null;\n        }\n        var scrollSize = closest.scrollSize, frameClient = closest.client;\n        var maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient: frameClient,\n            scrollSize: scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    }();\n    var axis = direction === \"vertical\" ? vertical : horizontal;\n    var subject = getSubject({\n        page: page,\n        withPlaceholder: null,\n        axis: axis,\n        frame: frame\n    });\n    var dimension = {\n        descriptor: descriptor,\n        isCombineEnabled: isCombineEnabled,\n        isFixedOnPage: isFixedOnPage,\n        axis: axis,\n        isEnabled: isEnabled,\n        client: client,\n        page: page,\n        frame: frame,\n        subject: subject\n    };\n    return dimension;\n};\nvar getClient = function getClient(targetRef, closestScrollable) {\n    var base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    var top = base.paddingBox.top - closestScrollable.scrollTop;\n    var left = base.paddingBox.left - closestScrollable.scrollLeft;\n    var bottom = top + closestScrollable.scrollHeight;\n    var right = left + closestScrollable.scrollWidth;\n    var paddingBox = {\n        top: top,\n        right: right,\n        bottom: bottom,\n        left: left\n    };\n    var borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.expand)(paddingBox, base.border);\n    var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.createBox)({\n        borderBox: borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = function(_ref) {\n    var ref = _ref.ref, descriptor = _ref.descriptor, env = _ref.env, windowScroll = _ref.windowScroll, direction = _ref.direction, isDropDisabled = _ref.isDropDisabled, isCombineEnabled = _ref.isCombineEnabled, shouldClipSubject = _ref.shouldClipSubject;\n    var closestScrollable = env.closestScrollable;\n    var client = getClient(ref, closestScrollable);\n    var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, windowScroll);\n    var closest = function() {\n        if (!closestScrollable) {\n            return null;\n        }\n        var frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.getBox)(closestScrollable);\n        var scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll$1(closestScrollable),\n            scrollSize: scrollSize,\n            shouldClipSubject: shouldClipSubject\n        };\n    }();\n    var dimension = getDroppableDimension({\n        descriptor: descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled: isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction: direction,\n        client: client,\n        page: page,\n        closest: closest\n    });\n    return dimension;\n};\nvar immediate = {\n    passive: false\n};\nvar delayed = {\n    passive: true\n};\nvar getListenerOptions = function(options) {\n    return options.shouldPublishImmediately ? immediate : delayed;\n};\nfunction useRequiredContext(Context) {\n    var result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nvar getClosestScrollableFromDrag = function getClosestScrollableFromDrag(dragging) {\n    return dragging && dragging.env.closestScrollable || null;\n};\nfunction useDroppablePublisher(args) {\n    var whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var appContext = useRequiredContext(AppContext);\n    var uniqueId = useUniqueId(\"droppable\");\n    var registry = appContext.registry, marshal = appContext.marshal;\n    var previousRef = usePrevious(args);\n    var descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        };\n    }, [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    var publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    var memoizedUpdateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(x, y) {\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            var scroll = {\n                x: x,\n                y: y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        });\n    }, [\n        descriptor.id,\n        marshal\n    ]);\n    var getClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll$1(dragging.env.closestScrollable);\n    }, []);\n    var updateScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    var scheduleScrollUpdate = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return (0,raf_schd__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(updateScroll);\n    }, [\n        updateScroll\n    ]);\n    var onClosestScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        var closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        var options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    var getDimensionAndWatchScroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(windowScroll, options) {\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        var previous = previousRef.current;\n        var ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        var env = getEnv(ref);\n        var dragging = {\n            ref: ref,\n            descriptor: descriptor,\n            env: env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        var dimension = getDimension({\n            ref: ref,\n            descriptor: descriptor,\n            env: env,\n            windowScroll: windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        var scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    var getScrollWhileDragging = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        var closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll$1(closest);\n    }, []);\n    var dragStopped = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        var dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        var closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    var scroll = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(change) {\n        var dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        var closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    var callbacks = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            getDimensionAndWatchScroll: getDimensionAndWatchScroll,\n            getScrollWhileDragging: getScrollWhileDragging,\n            dragStopped: dragStopped,\n            scroll: scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    var entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            uniqueId: uniqueId,\n            descriptor: descriptor,\n            callbacks: callbacks\n        };\n    }, [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return function() {\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop$2() {}\nvar empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nvar getSize = function getSize(_ref) {\n    var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount, placeholder = _ref.placeholder, animate = _ref.animate;\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nvar getStyle = function getStyle(_ref2) {\n    var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount, placeholder = _ref2.placeholder, animate = _ref2.animate;\n    var size = getSize({\n        isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n        placeholder: placeholder,\n        animate: animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nfunction Placeholder(props) {\n    var animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var tryClearAnimateOpenTimer = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    var animate = props.animate, onTransitionEnd = props.onTransitionEnd, onClose = props.onClose, contextId = props.contextId;\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\"), isAnimatingOpenOnMount = _useState[0], setIsAnimatingOpenOnMount = _useState[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        if (!isAnimatingOpenOnMount) {\n            return noop$2;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop$2;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop$2;\n        }\n        animateOpenTimerRef.current = setTimeout(function() {\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    var onSizeChangeEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(event) {\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    var style = getStyle({\n        isAnimatingOpenOnMount: isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style: style,\n        \"data-rbd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n}\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, \"\\n    provided.innerRef has not been provided with a HTMLElement.\\n\\n    You can find a guide on using the innerRef callback functions at:\\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\\n  \") : 0 : void 0;\n}\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach(function(check) {\n        return check(args);\n    });\n}\nvar shared = [\n    function required(_ref) {\n        var props = _ref.props;\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, \"A Droppable requires a [string] droppableId. Provided: [\" + typeof props.droppableId + \"]\") : 0 : void 0;\n    },\n    function _boolean(_ref2) {\n        var props = _ref2.props;\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref(_ref3) {\n        var getDroppableRef = _ref3.getDroppableRef;\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nvar standard = [\n    function placeholder(_ref4) {\n        var props = _ref4.props, getPlaceholderRef = _ref4.getPlaceholderRef;\n        if (!props.placeholder) {\n            return;\n        }\n        var ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning('\\n      Droppable setup issue [droppableId: \"' + props.droppableId + '\"]:\\n      DroppableProvided > placeholder could not be found.\\n\\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\\n    ') : 0;\n    }\n];\nvar virtual = [\n    function hasClone(_ref5) {\n        var props = _ref5.props;\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder(_ref6) {\n        var getPlaceholderRef = _ref6.getPlaceholderRef;\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(function() {\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nvar AnimateInOut = function(_React$PureComponent) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(AnimateInOut, _React$PureComponent);\n    function AnimateInOut() {\n        var _this;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        _this = _React$PureComponent.call.apply(_React$PureComponent, [\n            this\n        ].concat(args)) || this;\n        _this.state = {\n            isVisible: Boolean(_this.props.on),\n            data: _this.props.on,\n            animate: _this.props.shouldAnimate && _this.props.on ? \"open\" : \"none\"\n        };\n        _this.onClose = function() {\n            if (_this.state.animate !== \"close\") {\n                return;\n            }\n            _this.setState({\n                isVisible: false\n            });\n        };\n        return _this;\n    }\n    AnimateInOut.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    };\n    var _proto = AnimateInOut.prototype;\n    _proto.render = function render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        var provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    };\n    return AnimateInOut;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent));\nvar zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nvar getDraggingTransition = function getDraggingTransition(shouldAnimateDragMovement, dropping) {\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nvar getDraggingOpacity = function getDraggingOpacity(isCombining, isDropAnimating) {\n    if (!isCombining) {\n        return null;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nvar getShouldDraggingAnimate = function getShouldDraggingAnimate(dragging) {\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    var dimension = dragging.dimension;\n    var box = dimension.client;\n    var offset = dragging.offset, combineWith = dragging.combineWith, dropping = dragging.dropping;\n    var isCombining = Boolean(combineWith);\n    var shouldAnimate = getShouldDraggingAnimate(dragging);\n    var isDropAnimating = Boolean(dropping);\n    var transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    var style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform: transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? null : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll) {\n    if (windowScroll === void 0) {\n        windowScroll = origin;\n    }\n    var computedStyles = window.getComputedStyle(el);\n    var borderBox = el.getBoundingClientRect();\n    var client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.calculateBox)(borderBox, computedStyles);\n    var page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_5__.withScroll)(client, windowScroll);\n    var placeholder = {\n        client: client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    var displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    var dimension = {\n        descriptor: descriptor,\n        placeholder: placeholder,\n        displaceBy: displaceBy,\n        client: client,\n        page: page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    var uniqueId = useUniqueId(\"draggable\");\n    var descriptor = args.descriptor, registry = args.registry, getDraggableRef = args.getDraggableRef, canDragInteractiveElements = args.canDragInteractiveElements, shouldRespectForcePress = args.shouldRespectForcePress, isEnabled = args.isEnabled;\n    var options = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            canDragInteractiveElements: canDragInteractiveElements,\n            shouldRespectForcePress: shouldRespectForcePress,\n            isEnabled: isEnabled\n        };\n    }, [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    var getDimension = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(windowScroll) {\n        var el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    var entry = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            uniqueId: uniqueId,\n            descriptor: descriptor,\n            options: options,\n            getDimension: getDimension\n        };\n    }, [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    var publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    var isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useIsomorphicLayoutEffect(function() {\n        registry.draggable.register(publishedRef.current);\n        return function() {\n            return registry.draggable.unregister(publishedRef.current);\n        };\n    }, [\n        registry.draggable\n    ]);\n    useIsomorphicLayoutEffect(function() {\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        var last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(function() {\n        function prefix(id) {\n            return \"Draggable[id: \" + id + \"]: \";\n        }\n        var id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, \"Draggable requires a [string] draggableId.\\n      Provided: [type: \" + typeof id + \"] (value: \" + id + \")\") : 0 : void 0;\n        !isInteger(props.index) ?  true ? invariant(false, prefix(id) + \" requires an integer index prop\") : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, prefix(id) + \" Unable to find drag handle\") : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(function() {\n        var initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(function() {\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nfunction Draggable(props) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var setRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(el) {\n        ref.current = el;\n    }, []);\n    var getRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return ref.current;\n    }, []);\n    var _useRequiredContext = useRequiredContext(AppContext), contextId = _useRequiredContext.contextId, dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId, registry = _useRequiredContext.registry;\n    var _useRequiredContext2 = useRequiredContext(DroppableContext), type = _useRequiredContext2.type, droppableId = _useRequiredContext2.droppableId;\n    var descriptor = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            id: props.draggableId,\n            index: props.index,\n            type: type,\n            droppableId: droppableId\n        };\n    }, [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    var children = props.children, draggableId = props.draggableId, isEnabled = props.isEnabled, shouldRespectForcePress = props.shouldRespectForcePress, canDragInteractiveElements = props.canDragInteractiveElements, isClone = props.isClone, mapped = props.mapped, dropAnimationFinishedAction = props.dropAnimationFinished;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        var forPublisher = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n            return {\n                descriptor: descriptor,\n                registry: registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements: canDragInteractiveElements,\n                shouldRespectForcePress: shouldRespectForcePress,\n                isEnabled: isEnabled\n            };\n        }, [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    var dragHandleProps = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rbd-drag-handle-draggable-id\": draggableId,\n            \"data-rbd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null;\n    }, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    var onMoveEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(event) {\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        dropAnimationFinishedAction();\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    var provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        var style = getStyle$1(mapped);\n        var onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : null;\n        var result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rbd-draggable-context-id\": contextId,\n                \"data-rbd-draggable-id\": draggableId,\n                style: style,\n                onTransitionEnd: onTransitionEnd\n            },\n            dragHandleProps: dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    var rubric = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        };\n    }, [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return children(provided, mapped.snapshot, rubric);\n}\nvar isStrictEqual = function(a, b) {\n    return a === b;\n};\nvar whatIsDraggedOverFromResult = function(result) {\n    var combine = result.combine, destination = result.destination;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nvar getCombineWithFromResult = function getCombineWithFromResult(result) {\n    return result.combine ? result.combine.draggableId : null;\n};\nvar getCombineWithFromImpact = function getCombineWithFromImpact(impact) {\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    var memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(x, y) {\n        return {\n            x: x,\n            y: y\n        };\n    });\n    var getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(mode, isClone, draggingOver, combineWith, dropping) {\n        return {\n            isDragging: true,\n            isClone: isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode: mode,\n            draggingOver: draggingOver,\n            combineWith: combineWith,\n            combineTargetFor: null\n        };\n    });\n    var getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(offset, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {\n        return {\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver: draggingOver,\n                combineWith: combineWith,\n                mode: mode,\n                offset: offset,\n                dimension: dimension,\n                forceShouldAnimate: forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        };\n    });\n    var selector = function selector(state, ownProps) {\n        if (state.isDragging) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            var offset = state.current.client.offset;\n            var dimension = state.dimensions.draggables[ownProps.draggableId];\n            var draggingOver = whatIsDraggedOver(state.impact);\n            var combineWith = getCombineWithFromImpact(state.impact);\n            var forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            var completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            var isClone = ownProps.isClone;\n            var _dimension = state.dimensions.draggables[ownProps.draggableId];\n            var result = completed.result;\n            var mode = result.mode;\n            var _draggingOver = whatIsDraggedOverFromResult(result);\n            var _combineWith = getCombineWithFromResult(result);\n            var duration = state.dropDuration;\n            var dropping = {\n                duration: duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: _combineWith ? combine.opacity.drop : null,\n                scale: _combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension: _dimension,\n                    dropping: dropping,\n                    draggingOver: _draggingOver,\n                    combineWith: _combineWith,\n                    mode: mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor) {\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor: combineTargetFor,\n        combineWith: null\n    };\n}\nvar atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    var memoizedOffset = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(x, y) {\n        return {\n            x: x,\n            y: y\n        };\n    });\n    var getMemoizedSnapshot = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(getSecondarySnapshot);\n    var getMemoizedProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(offset, combineTargetFor, shouldAnimateDisplacement) {\n        if (combineTargetFor === void 0) {\n            combineTargetFor = null;\n        }\n        return {\n            mapped: {\n                type: \"SECONDARY\",\n                offset: offset,\n                combineTargetFor: combineTargetFor,\n                shouldAnimateDisplacement: shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        };\n    });\n    var getFallback = function getFallback(combineTargetFor) {\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    var getProps = function getProps(ownId, draggingId, impact, afterCritical) {\n        var visualDisplacement = impact.displaced.visible[ownId];\n        var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        var combine = tryGetCombine(impact);\n        var combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            var change = negate(afterCritical.displacedBy.point);\n            var _offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(_offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        var displaceBy = impact.displacedBy.point;\n        var offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    var selector = function selector(state, ownProps) {\n        if (state.isDragging) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            var completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nvar makeMapStateToProps = function makeMapStateToProps() {\n    var draggingSelector = getDraggableSelector();\n    var secondarySelector = getSecondarySelector();\n    var selector = function selector(state, ownProps) {\n        return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    };\n    return selector;\n};\nvar mapDispatchToProps = {\n    dropAnimationFinished: dropAnimationFinished\n};\nvar ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.connect)(makeMapStateToProps, mapDispatchToProps, null, {\n    context: StoreContext,\n    pure: true,\n    areStatePropsEqual: isStrictEqual\n})(Draggable);\nfunction PrivateDraggable(props) {\n    var droppableContext = useRequiredContext(DroppableContext);\n    var isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n    var isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nfunction Droppable(props) {\n    var appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    var contextId = appContext.contextId, isMovementAllowed = appContext.isMovementAllowed;\n    var droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var children = props.children, droppableId = props.droppableId, type = props.type, mode = props.mode, direction = props.direction, ignoreContainerClipping = props.ignoreContainerClipping, isDropDisabled = props.isDropDisabled, isCombineEnabled = props.isCombineEnabled, snapshot = props.snapshot, useClone = props.useClone, updateViewportMaxScroll = props.updateViewportMaxScroll, getContainerForClone = props.getContainerForClone;\n    var getDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return droppableRef.current;\n    }, []);\n    var setDroppableRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(value) {\n        droppableRef.current = value;\n    }, []);\n    var getPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        return placeholderRef.current;\n    }, []);\n    var setPlaceholderRef = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function(value) {\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props: props,\n        getDroppableRef: getDroppableRef,\n        getPlaceholderRef: getPlaceholderRef\n    });\n    var onPlaceholderTransitionEnd = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useCallback)(function() {\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId: droppableId,\n        type: type,\n        mode: mode,\n        direction: direction,\n        isDropDisabled: isDropDisabled,\n        isCombineEnabled: isCombineEnabled,\n        ignoreContainerClipping: ignoreContainerClipping,\n        getDroppableRef: getDroppableRef\n    });\n    var placeholder = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n        on: props.placeholder,\n        shouldAnimate: props.shouldAnimatePlaceholder\n    }, function(_ref) {\n        var onClose = _ref.onClose, data = _ref.data, animate = _ref.animate;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n            placeholder: data,\n            onClose: onClose,\n            innerRef: setPlaceholderRef,\n            animate: animate,\n            contextId: contextId,\n            onTransitionEnd: onPlaceholderTransitionEnd\n        });\n    });\n    var provided = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            innerRef: setDroppableRef,\n            placeholder: placeholder,\n            droppableProps: {\n                \"data-rbd-droppable-id\": droppableId,\n                \"data-rbd-droppable-context-id\": contextId\n            }\n        };\n    }, [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    var droppableContext = (0,use_memo_one__WEBPACK_IMPORTED_MODULE_9__.useMemo)(function() {\n        return {\n            droppableId: droppableId,\n            type: type,\n            isUsingCloneFor: isUsingCloneFor\n        };\n    }, [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        var dragging = useClone.dragging, render = useClone.render;\n        var node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, function(draggableProvided, draggableSnapshot) {\n            return render(draggableProvided, draggableSnapshot, dragging);\n        });\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_4___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n}\nvar isMatchingType = function isMatchingType(type, critical) {\n    return type === critical.droppable.type;\n};\nvar getDraggable = function getDraggable(critical, dimensions) {\n    return dimensions.draggables[critical.draggable.id];\n};\nvar makeMapStateToProps$1 = function makeMapStateToProps() {\n    var idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    var idleWithoutAnimation = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, idleWithAnimation, {\n        shouldAnimatePlaceholder: false\n    });\n    var getDraggableRubric = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(descriptor) {\n        return {\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        };\n    });\n    var getMapProps = (0,memoize_one__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(function(id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {\n        var draggableId = dragging.descriptor.id;\n        var isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            var useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            var _snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot: _snapshot,\n                useClone: useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        var snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot: snapshot,\n            useClone: null\n        };\n    });\n    var selector = function selector(state, ownProps) {\n        var id = ownProps.droppableId;\n        var type = ownProps.type;\n        var isEnabled = !ownProps.isDropDisabled;\n        var renderClone = ownProps.renderClone;\n        if (state.isDragging) {\n            var critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            var dragging = getDraggable(critical, state.dimensions);\n            var isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            var completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            var _dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            var _completed = state.completed;\n            if (!isMatchingType(type, _completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            var wasOver = whatIsDraggedOver(_completed.impact) === id;\n            var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === \"COMBINE\");\n            var isHome = _completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nvar mapDispatchToProps$1 = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nvar defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nvar ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_3__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    pure: true,\n    areStatePropsEqual: isStrictEqual\n})(Droppable);\nConnectedDroppable.defaultProps = defaultProps;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYmVhdXRpZnVsLWRuZC9kaXN0L3JlYWN0LWJlYXV0aWZ1bC1kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDbEI7QUFDWjtBQUN5QztBQUNuRDtBQUNJO0FBQ2lEO0FBQ2hFO0FBQ047QUFDRTtBQUVqQyxJQUFJMkIsZUFBZUMsa0JBQXlCO0FBQzVDLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxzQkFBc0I7QUFFMUIsSUFBSUMsUUFBUSxTQUFTQSxNQUFNQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQ0osZUFBZSxLQUFLSSxPQUFPLENBQUNILHFCQUFxQixJQUFJSSxJQUFJO0FBQ2hGO0FBRUEsSUFBSUMsZ0JBQWdCLFNBQVNBLGNBQWNDLE9BQU87SUFDaEQsT0FBT0wsTUFBTSxzQ0FBc0NBLE1BQU1LLFdBQVc7QUFDdEU7QUFFQSxJQUFJQyxzQkFBc0IsU0FBU0Esb0JBQW9CRCxPQUFPO0lBQzVELE9BQU87UUFBQ0QsY0FBY0M7UUFBVTtRQUF3RDtRQUFvQjtLQUFrQjtBQUNoSTtBQUNBLElBQUlFLGlCQUFpQjtBQUNyQixTQUFTQyxJQUFJQyxJQUFJLEVBQUVKLE9BQU87SUFDeEIsSUFBSUs7SUFFSixJQUFJZCxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSxJQUFJLEtBQXVELEVBQUUsRUFFNUQ7SUFFQWMsQ0FBQUEsV0FBV0UsT0FBTSxDQUFFLENBQUNILEtBQUssQ0FBQ0ksS0FBSyxDQUFDSCxVQUFVSixvQkFBb0JEO0FBQ2pFO0FBQ0EsSUFBSVMsVUFBVU4sSUFBSU8sSUFBSSxDQUFDLE1BQU07QUFDN0IsSUFBSUMsUUFBUVIsSUFBSU8sSUFBSSxDQUFDLE1BQU07QUFFM0IsU0FBU0UsUUFBUTtBQUVqQixTQUFTQyxXQUFXQyxNQUFNLEVBQUVDLFdBQVc7SUFDckMsT0FBTzVDLDhFQUFRQSxDQUFDLENBQUMsR0FBRzJDLFFBQVEsQ0FBQyxHQUFHQztB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QUkwZSx1QkFBdUI7SUFDekI5d0IseUJBQXlCQTtBQUMzQjtBQUVBLFNBQVMrd0I7SUFDUCxDQUFDcnNCLFNBQVNzTyxJQUFJLEdBQUc3MEIsS0FBcUMsR0FBRzRDLFVBQVUsT0FBTyxnQ0FBZ0NBLENBQWdCLEdBQUcsS0FBSztJQUNsSSxPQUFPMmpCLFNBQVNzTyxJQUFJO0FBQ3RCO0FBRUEsSUFBSWdlLGVBQWU7SUFDakJ0N0IsTUFBTTtJQUNOM1csTUFBTTtJQUNOb08sV0FBVztJQUNYKzRCLGdCQUFnQjtJQUNoQmo3QixrQkFBa0I7SUFDbEJnOEIseUJBQXlCO0lBQ3pCd0MsYUFBYTtJQUNiMEYsc0JBQXNCNEI7QUFDeEI7QUFDQSxJQUFJRSxxQkFBcUI1ekMsb0RBQU9BLENBQUMyeUMsdUJBQXVCYyxzQkFBc0IsTUFBTTtJQUNsRmpmLFNBQVM0RTtJQUNUOFgsTUFBTTtJQUNOQyxvQkFBb0IvQjtBQUN0QixHQUFHc0M7QUFDSGtDLG1CQUFtQkQsWUFBWSxHQUFHQTtBQUUrSCIsInNvdXJjZXMiOlsid2VicGFjazovL25peW8tY3JlYXRpb25zLXBtLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJlYXV0aWZ1bC1kbmQvZGlzdC9yZWFjdC1iZWF1dGlmdWwtZG5kLmVzbS5qcz84MGY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCB7IGNyZWF0ZVN0b3JlIGFzIGNyZWF0ZVN0b3JlJDEsIGFwcGx5TWlkZGxld2FyZSwgY29tcG9zZSwgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgUHJvdmlkZXIsIGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3VzZS1tZW1vLW9uZSc7XG5pbXBvcnQgeyBnZXRSZWN0LCBleHBhbmQsIG9mZnNldCwgd2l0aFNjcm9sbCwgZ2V0Qm94LCBjcmVhdGVCb3gsIGNhbGN1bGF0ZUJveCB9IGZyb20gJ2Nzcy1ib3gtbW9kZWwnO1xuaW1wb3J0IG1lbW9pemVPbmUgZnJvbSAnbWVtb2l6ZS1vbmUnO1xuaW1wb3J0IHJhZlNjaGQgZnJvbSAncmFmLXNjaGQnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbnZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xudmFyIHNwYWNlc0FuZFRhYnMgPSAvWyBcXHRdezIsfS9nO1xudmFyIGxpbmVTdGFydFdpdGhTcGFjZXMgPSAvXlsgXFx0XSovZ207XG5cbnZhciBjbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHNwYWNlc0FuZFRhYnMsICcgJykucmVwbGFjZShsaW5lU3RhcnRXaXRoU3BhY2VzLCAnJykudHJpbSgpO1xufTtcblxudmFyIGdldERldk1lc3NhZ2UgPSBmdW5jdGlvbiBnZXREZXZNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNsZWFuKFwiXFxuICAlY3JlYWN0LWJlYXV0aWZ1bC1kbmRcXG5cXG4gICVjXCIgKyBjbGVhbihtZXNzYWdlKSArIFwiXFxuXFxuICAlY1xcdUQ4M0RcXHVEQzc3XFx1MjAwRCBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQgb25seSBtZXNzYWdlLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXFxuXCIpO1xufTtcblxudmFyIGdldEZvcm1hdHRlZE1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFtnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLCAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4yZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsICdsaW5lLWhlaWdodDogMS41JywgJ2NvbG9yOiAjNzIzODc0OyddO1xufTtcbnZhciBpc0Rpc2FibGVkRmxhZyA9ICdfX3JlYWN0LWJlYXV0aWZ1bC1kbmQtZGlzYWJsZS1kZXYtd2FybmluZ3MnO1xuZnVuY3Rpb24gbG9nKHR5cGUsIG1lc3NhZ2UpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93W2lzRGlzYWJsZWRGbGFnXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIChfY29uc29sZSA9IGNvbnNvbGUpW3R5cGVdLmFwcGx5KF9jb25zb2xlLCBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbn1cbnZhciB3YXJuaW5nID0gbG9nLmJpbmQobnVsbCwgJ3dhcm4nKTtcbnZhciBlcnJvciA9IGxvZy5iaW5kKG51bGwsICdlcnJvcicpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhzaGFyZWQsIGZyb21CaW5kaW5nKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgc2hhcmVkLCB7fSwgZnJvbUJpbmRpbmcpO1xufVxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzKGVsLCBiaW5kaW5ncywgc2hhcmVkT3B0aW9ucykge1xuICB2YXIgdW5iaW5kaW5ncyA9IGJpbmRpbmdzLm1hcChmdW5jdGlvbiAoYmluZGluZykge1xuICAgIHZhciBvcHRpb25zID0gZ2V0T3B0aW9ucyhzaGFyZWRPcHRpb25zLCBiaW5kaW5nLm9wdGlvbnMpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGJpbmRpbmcuZXZlbnROYW1lLCBiaW5kaW5nLmZuLCBvcHRpb25zKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICB1bmJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKHVuYmluZCkge1xuICAgICAgdW5iaW5kKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbnZhciBpc1Byb2R1Y3Rpb24kMSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG52YXIgcHJlZml4ID0gJ0ludmFyaWFudCBmYWlsZWQnO1xuZnVuY3Rpb24gUmJkSW52YXJpYW50KG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuUmJkSW52YXJpYW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5tZXNzYWdlO1xufTtcblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzUHJvZHVjdGlvbiQxKSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYmRJbnZhcmlhbnQocHJlZml4ICsgXCI6IFwiICsgKG1lc3NhZ2UgfHwgJycpKTtcbiAgfVxufVxuXG52YXIgRXJyb3JCb3VuZGFyeSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEVycm9yQm91bmRhcnksIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEVycm9yQm91bmRhcnkoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICBfdGhpcy51bmJpbmQgPSBub29wO1xuXG4gICAgX3RoaXMub25XaW5kb3dFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IF90aGlzLmdldENhbGxiYWNrcygpO1xuXG4gICAgICBpZiAoY2FsbGJhY2tzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICBjYWxsYmFja3MudHJ5QWJvcnQoKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgICAgQW4gZXJyb3Igd2FzIGNhdWdodCBieSBvdXIgd2luZG93ICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgd2hpbGUgYSBkcmFnIHdhcyBvY2N1cnJpbmcuXFxuICAgICAgICBUaGUgYWN0aXZlIGRyYWcgaGFzIGJlZW4gYWJvcnRlZC5cXG4gICAgICBcIikgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnIgPSBldmVudC5lcnJvcjtcblxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldENhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgQXBwQ2FsbGJhY2tzIGluIDxFcnJvckJvdW5kYXJ5Lz4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmNhbGxiYWNrcztcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0Q2FsbGJhY2tzID0gZnVuY3Rpb24gKGNhbGxiYWNrcykge1xuICAgICAgX3RoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRXJyb3JCb3VuZGFyeS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ2Vycm9yJyxcbiAgICAgIGZuOiB0aGlzLm9uV2luZG93RXJyb3JcbiAgICB9XSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuc2V0Q2FsbGJhY2tzKTtcbiAgfTtcblxuICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IFwiXFxuICBQcmVzcyBzcGFjZSBiYXIgdG8gc3RhcnQgYSBkcmFnLlxcbiAgV2hlbiBkcmFnZ2luZyB5b3UgY2FuIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBpdGVtIGFyb3VuZCBhbmQgZXNjYXBlIHRvIGNhbmNlbC5cXG4gIFNvbWUgc2NyZWVuIHJlYWRlcnMgbWF5IHJlcXVpcmUgeW91IHRvIGJlIGluIGZvY3VzIG1vZGUgb3IgdG8gdXNlIHlvdXIgcGFzcyB0aHJvdWdoIGtleVxcblwiO1xuXG52YXIgcG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbihpbmRleCkge1xuICByZXR1cm4gaW5kZXggKyAxO1xufTtcblxudmFyIG9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gb25EcmFnU3RhcnQoc3RhcnQpIHtcbiAgcmV0dXJuIFwiXFxuICBZb3UgaGF2ZSBsaWZ0ZWQgYW4gaXRlbSBpbiBwb3NpdGlvbiBcIiArIHBvc2l0aW9uKHN0YXJ0LnNvdXJjZS5pbmRleCkgKyBcIlxcblwiO1xufTtcblxudmFyIHdpdGhMb2NhdGlvbiA9IGZ1bmN0aW9uIHdpdGhMb2NhdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIHZhciBpc0luSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICB2YXIgc3RhcnRQb3NpdGlvbiA9IHBvc2l0aW9uKHNvdXJjZS5pbmRleCk7XG4gIHZhciBlbmRQb3NpdGlvbiA9IHBvc2l0aW9uKGRlc3RpbmF0aW9uLmluZGV4KTtcblxuICBpZiAoaXNJbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIFwiXFxuICAgICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiBcIiArIHN0YXJ0UG9zaXRpb24gKyBcIlxcbiAgICAgIHRvIHBvc2l0aW9uIFwiICsgZW5kUG9zaXRpb24gKyBcIlxcbiAgICBcIjtcbiAgfVxuXG4gIHJldHVybiBcIlxcbiAgICBZb3UgaGF2ZSBtb3ZlZCB0aGUgaXRlbSBmcm9tIHBvc2l0aW9uIFwiICsgc3RhcnRQb3NpdGlvbiArIFwiXFxuICAgIGluIGxpc3QgXCIgKyBzb3VyY2UuZHJvcHBhYmxlSWQgKyBcIlxcbiAgICB0byBsaXN0IFwiICsgZGVzdGluYXRpb24uZHJvcHBhYmxlSWQgKyBcIlxcbiAgICBpbiBwb3NpdGlvbiBcIiArIGVuZFBvc2l0aW9uICsgXCJcXG4gIFwiO1xufTtcblxudmFyIHdpdGhDb21iaW5lID0gZnVuY3Rpb24gd2l0aENvbWJpbmUoaWQsIHNvdXJjZSwgY29tYmluZSkge1xuICB2YXIgaW5Ib21lTGlzdCA9IHNvdXJjZS5kcm9wcGFibGVJZCA9PT0gY29tYmluZS5kcm9wcGFibGVJZDtcblxuICBpZiAoaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBcIlxcbiAgICAgIFRoZSBpdGVtIFwiICsgaWQgKyBcIlxcbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggXCIgKyBjb21iaW5lLmRyYWdnYWJsZUlkO1xuICB9XG5cbiAgcmV0dXJuIFwiXFxuICAgICAgVGhlIGl0ZW0gXCIgKyBpZCArIFwiXFxuICAgICAgaW4gbGlzdCBcIiArIHNvdXJjZS5kcm9wcGFibGVJZCArIFwiXFxuICAgICAgaGFzIGJlZW4gY29tYmluZWQgd2l0aCBcIiArIGNvbWJpbmUuZHJhZ2dhYmxlSWQgKyBcIlxcbiAgICAgIGluIGxpc3QgXCIgKyBjb21iaW5lLmRyb3BwYWJsZUlkICsgXCJcXG4gICAgXCI7XG59O1xuXG52YXIgb25EcmFnVXBkYXRlID0gZnVuY3Rpb24gb25EcmFnVXBkYXRlKHVwZGF0ZSkge1xuICB2YXIgbG9jYXRpb24gPSB1cGRhdGUuZGVzdGluYXRpb247XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHdpdGhMb2NhdGlvbih1cGRhdGUuc291cmNlLCBsb2NhdGlvbik7XG4gIH1cblxuICB2YXIgY29tYmluZSA9IHVwZGF0ZS5jb21iaW5lO1xuXG4gIGlmIChjb21iaW5lKSB7XG4gICAgcmV0dXJuIHdpdGhDb21iaW5lKHVwZGF0ZS5kcmFnZ2FibGVJZCwgdXBkYXRlLnNvdXJjZSwgY29tYmluZSk7XG4gIH1cblxuICByZXR1cm4gJ1lvdSBhcmUgb3ZlciBhbiBhcmVhIHRoYXQgY2Fubm90IGJlIGRyb3BwZWQgb24nO1xufTtcblxudmFyIHJldHVybmVkVG9TdGFydCA9IGZ1bmN0aW9uIHJldHVybmVkVG9TdGFydChzb3VyY2UpIHtcbiAgcmV0dXJuIFwiXFxuICBUaGUgaXRlbSBoYXMgcmV0dXJuZWQgdG8gaXRzIHN0YXJ0aW5nIHBvc2l0aW9uXFxuICBvZiBcIiArIHBvc2l0aW9uKHNvdXJjZS5pbmRleCkgKyBcIlxcblwiO1xufTtcblxudmFyIG9uRHJhZ0VuZCA9IGZ1bmN0aW9uIG9uRHJhZ0VuZChyZXN1bHQpIHtcbiAgaWYgKHJlc3VsdC5yZWFzb24gPT09ICdDQU5DRUwnKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgICAgTW92ZW1lbnQgY2FuY2VsbGVkLlxcbiAgICAgIFwiICsgcmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpICsgXCJcXG4gICAgXCI7XG4gIH1cblxuICB2YXIgbG9jYXRpb24gPSByZXN1bHQuZGVzdGluYXRpb247XG4gIHZhciBjb21iaW5lID0gcmVzdWx0LmNvbWJpbmU7XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgICAgWW91IGhhdmUgZHJvcHBlZCB0aGUgaXRlbS5cXG4gICAgICBcIiArIHdpdGhMb2NhdGlvbihyZXN1bHQuc291cmNlLCBsb2NhdGlvbikgKyBcIlxcbiAgICBcIjtcbiAgfVxuXG4gIGlmIChjb21iaW5lKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgICAgWW91IGhhdmUgZHJvcHBlZCB0aGUgaXRlbS5cXG4gICAgICBcIiArIHdpdGhDb21iaW5lKHJlc3VsdC5kcmFnZ2FibGVJZCwgcmVzdWx0LnNvdXJjZSwgY29tYmluZSkgKyBcIlxcbiAgICBcIjtcbiAgfVxuXG4gIHJldHVybiBcIlxcbiAgICBUaGUgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIHdoaWxlIG5vdCBvdmVyIGEgZHJvcCBhcmVhLlxcbiAgICBcIiArIHJldHVybmVkVG9TdGFydChyZXN1bHQuc291cmNlKSArIFwiXFxuICBcIjtcbn07XG5cbnZhciBwcmVzZXQgPSB7XG4gIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uczogZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICBvbkRyYWdTdGFydDogb25EcmFnU3RhcnQsXG4gIG9uRHJhZ1VwZGF0ZTogb25EcmFnVXBkYXRlLFxuICBvbkRyYWdFbmQ6IG9uRHJhZ0VuZFxufTtcblxudmFyIG9yaWdpbiA9IHtcbiAgeDogMCxcbiAgeTogMFxufTtcbnZhciBhZGQgPSBmdW5jdGlvbiBhZGQocG9pbnQxLCBwb2ludDIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludDEueCArIHBvaW50Mi54LFxuICAgIHk6IHBvaW50MS55ICsgcG9pbnQyLnlcbiAgfTtcbn07XG52YXIgc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChwb2ludDEsIHBvaW50Mikge1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50MS54IC0gcG9pbnQyLngsXG4gICAgeTogcG9pbnQxLnkgLSBwb2ludDIueVxuICB9O1xufTtcbnZhciBpc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbChwb2ludDEsIHBvaW50Mikge1xuICByZXR1cm4gcG9pbnQxLnggPT09IHBvaW50Mi54ICYmIHBvaW50MS55ID09PSBwb2ludDIueTtcbn07XG52YXIgbmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKHBvaW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQueCAhPT0gMCA/IC1wb2ludC54IDogMCxcbiAgICB5OiBwb2ludC55ICE9PSAwID8gLXBvaW50LnkgOiAwXG4gIH07XG59O1xudmFyIHBhdGNoID0gZnVuY3Rpb24gcGF0Y2gobGluZSwgdmFsdWUsIG90aGVyVmFsdWUpIHtcbiAgdmFyIF9yZWY7XG5cbiAgaWYgKG90aGVyVmFsdWUgPT09IHZvaWQgMCkge1xuICAgIG90aGVyVmFsdWUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltsaW5lXSA9IHZhbHVlLCBfcmVmW2xpbmUgPT09ICd4JyA/ICd5JyA6ICd4J10gPSBvdGhlclZhbHVlLCBfcmVmO1xufTtcbnZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKHBvaW50MSwgcG9pbnQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnQyLnggLSBwb2ludDEueCwgMikgKyBNYXRoLnBvdyhwb2ludDIueSAtIHBvaW50MS55LCAyKSk7XG59O1xudmFyIGNsb3Nlc3QgPSBmdW5jdGlvbiBjbG9zZXN0KHRhcmdldCwgcG9pbnRzKSB7XG4gIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBkaXN0YW5jZSh0YXJnZXQsIHBvaW50KTtcbiAgfSkpO1xufTtcbnZhciBhcHBseSA9IGZ1bmN0aW9uIGFwcGx5KGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZm4ocG9pbnQueCksXG4gICAgICB5OiBmbihwb2ludC55KVxuICAgIH07XG4gIH07XG59O1xuXG52YXIgZXhlY3V0ZUNsaXAgPSAoZnVuY3Rpb24gKGZyYW1lLCBzdWJqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRSZWN0KHtcbiAgICB0b3A6IE1hdGgubWF4KHN1YmplY3QudG9wLCBmcmFtZS50b3ApLFxuICAgIHJpZ2h0OiBNYXRoLm1pbihzdWJqZWN0LnJpZ2h0LCBmcmFtZS5yaWdodCksXG4gICAgYm90dG9tOiBNYXRoLm1pbihzdWJqZWN0LmJvdHRvbSwgZnJhbWUuYm90dG9tKSxcbiAgICBsZWZ0OiBNYXRoLm1heChzdWJqZWN0LmxlZnQsIGZyYW1lLmxlZnQpXG4gIH0pO1xuXG4gIGlmIChyZXN1bHQud2lkdGggPD0gMCB8fCByZXN1bHQuaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIG9mZnNldEJ5UG9zaXRpb24gPSBmdW5jdGlvbiBvZmZzZXRCeVBvc2l0aW9uKHNwYWNpbmcsIHBvaW50KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBzcGFjaW5nLnRvcCArIHBvaW50LnksXG4gICAgbGVmdDogc3BhY2luZy5sZWZ0ICsgcG9pbnQueCxcbiAgICBib3R0b206IHNwYWNpbmcuYm90dG9tICsgcG9pbnQueSxcbiAgICByaWdodDogc3BhY2luZy5yaWdodCArIHBvaW50LnhcbiAgfTtcbn07XG52YXIgZ2V0Q29ybmVycyA9IGZ1bmN0aW9uIGdldENvcm5lcnMoc3BhY2luZykge1xuICByZXR1cm4gW3tcbiAgICB4OiBzcGFjaW5nLmxlZnQsXG4gICAgeTogc3BhY2luZy50b3BcbiAgfSwge1xuICAgIHg6IHNwYWNpbmcucmlnaHQsXG4gICAgeTogc3BhY2luZy50b3BcbiAgfSwge1xuICAgIHg6IHNwYWNpbmcubGVmdCxcbiAgICB5OiBzcGFjaW5nLmJvdHRvbVxuICB9LCB7XG4gICAgeDogc3BhY2luZy5yaWdodCxcbiAgICB5OiBzcGFjaW5nLmJvdHRvbVxuICB9XTtcbn07XG52YXIgbm9TcGFjaW5nID0ge1xuICB0b3A6IDAsXG4gIHJpZ2h0OiAwLFxuICBib3R0b206IDAsXG4gIGxlZnQ6IDBcbn07XG5cbnZhciBzY3JvbGwgPSBmdW5jdGlvbiBzY3JvbGwodGFyZ2V0LCBmcmFtZSkge1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRCeVBvc2l0aW9uKHRhcmdldCwgZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50KTtcbn07XG5cbnZhciBpbmNyZWFzZSA9IGZ1bmN0aW9uIGluY3JlYXNlKHRhcmdldCwgYXhpcywgd2l0aFBsYWNlaG9sZGVyKSB7XG4gIGlmICh3aXRoUGxhY2Vob2xkZXIgJiYgd2l0aFBsYWNlaG9sZGVyLmluY3JlYXNlZEJ5KSB7XG4gICAgdmFyIF9leHRlbmRzMjtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdGFyZ2V0LCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltheGlzLmVuZF0gPSB0YXJnZXRbYXhpcy5lbmRdICsgd2l0aFBsYWNlaG9sZGVyLmluY3JlYXNlZEJ5W2F4aXMubGluZV0sIF9leHRlbmRzMikpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBjbGlwID0gZnVuY3Rpb24gY2xpcCh0YXJnZXQsIGZyYW1lKSB7XG4gIGlmIChmcmFtZSAmJiBmcmFtZS5zaG91bGRDbGlwU3ViamVjdCkge1xuICAgIHJldHVybiBleGVjdXRlQ2xpcChmcmFtZS5wYWdlTWFyZ2luQm94LCB0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIGdldFJlY3QodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRTdWJqZWN0ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwYWdlID0gX3JlZi5wYWdlLFxuICAgICAgd2l0aFBsYWNlaG9sZGVyID0gX3JlZi53aXRoUGxhY2Vob2xkZXIsXG4gICAgICBheGlzID0gX3JlZi5heGlzLFxuICAgICAgZnJhbWUgPSBfcmVmLmZyYW1lO1xuICB2YXIgc2Nyb2xsZWQgPSBzY3JvbGwocGFnZS5tYXJnaW5Cb3gsIGZyYW1lKTtcbiAgdmFyIGluY3JlYXNlZCA9IGluY3JlYXNlKHNjcm9sbGVkLCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpO1xuICB2YXIgY2xpcHBlZCA9IGNsaXAoaW5jcmVhc2VkLCBmcmFtZSk7XG4gIHJldHVybiB7XG4gICAgcGFnZTogcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IHdpdGhQbGFjZWhvbGRlcixcbiAgICBhY3RpdmU6IGNsaXBwZWRcbiAgfTtcbn0pO1xuXG52YXIgc2Nyb2xsRHJvcHBhYmxlID0gKGZ1bmN0aW9uIChkcm9wcGFibGUsIG5ld1Njcm9sbCkge1xuICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBzY3JvbGxhYmxlID0gZHJvcHBhYmxlLmZyYW1lO1xuICB2YXIgc2Nyb2xsRGlmZiA9IHN1YnRyYWN0KG5ld1Njcm9sbCwgc2Nyb2xsYWJsZS5zY3JvbGwuaW5pdGlhbCk7XG4gIHZhciBzY3JvbGxEaXNwbGFjZW1lbnQgPSBuZWdhdGUoc2Nyb2xsRGlmZik7XG5cbiAgdmFyIGZyYW1lID0gX2V4dGVuZHMoe30sIHNjcm9sbGFibGUsIHtcbiAgICBzY3JvbGw6IHtcbiAgICAgIGluaXRpYWw6IHNjcm9sbGFibGUuc2Nyb2xsLmluaXRpYWwsXG4gICAgICBjdXJyZW50OiBuZXdTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBzY3JvbGxEaWZmLFxuICAgICAgICBkaXNwbGFjZW1lbnQ6IHNjcm9sbERpc3BsYWNlbWVudFxuICAgICAgfSxcbiAgICAgIG1heDogc2Nyb2xsYWJsZS5zY3JvbGwubWF4XG4gICAgfVxuICB9KTtcblxuICB2YXIgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWU6IGZyYW1lXG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBfZXh0ZW5kcyh7fSwgZHJvcHBhYmxlLCB7XG4gICAgZnJhbWU6IGZyYW1lLFxuICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufVxuZnVuY3Rpb24gdmFsdWVzKG1hcCkge1xuICBpZiAoT2JqZWN0LnZhbHVlcykge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKG1hcCk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtYXBba2V5XTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kSW5kZXgobGlzdCwgcHJlZGljYXRlKSB7XG4gIGlmIChsaXN0LmZpbmRJbmRleCkge1xuICAgIHJldHVybiBsaXN0LmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShsaXN0W2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmluZChsaXN0LCBwcmVkaWNhdGUpIHtcbiAgaWYgKGxpc3QuZmluZCkge1xuICAgIHJldHVybiBsaXN0LmZpbmQocHJlZGljYXRlKTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IGZpbmRJbmRleChsaXN0LCBwcmVkaWNhdGUpO1xuXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gbGlzdFtpbmRleF07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdG9BcnJheShsaXN0KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0KTtcbn1cblxudmFyIHRvRHJvcHBhYmxlTWFwID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZHJvcHBhYmxlcykge1xuICByZXR1cm4gZHJvcHBhYmxlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgcHJldmlvdXNbY3VycmVudC5kZXNjcmlwdG9yLmlkXSA9IGN1cnJlbnQ7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LCB7fSk7XG59KTtcbnZhciB0b0RyYWdnYWJsZU1hcCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGRyYWdnYWJsZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgIHByZXZpb3VzW2N1cnJlbnQuZGVzY3JpcHRvci5pZF0gPSBjdXJyZW50O1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSwge30pO1xufSk7XG52YXIgdG9Ecm9wcGFibGVMaXN0ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZHJvcHBhYmxlcykge1xuICByZXR1cm4gdmFsdWVzKGRyb3BwYWJsZXMpO1xufSk7XG52YXIgdG9EcmFnZ2FibGVMaXN0ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZHJhZ2dhYmxlcykge1xuICByZXR1cm4gdmFsdWVzKGRyYWdnYWJsZXMpO1xufSk7XG5cbnZhciBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZHJvcHBhYmxlSWQsIGRyYWdnYWJsZXMpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRHJhZ2dhYmxlTGlzdChkcmFnZ2FibGVzKS5maWx0ZXIoZnVuY3Rpb24gKGRyYWdnYWJsZSkge1xuICAgIHJldHVybiBkcm9wcGFibGVJZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQ7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIHtcbiAgaWYgKGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIGltcGFjdC5hdC5kZXN0aW5hdGlvbjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJ5R2V0Q29tYmluZShpbXBhY3QpIHtcbiAgaWYgKGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ0NPTUJJTkUnKSB7XG4gICAgcmV0dXJuIGltcGFjdC5hdC5jb21iaW5lO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKHJlbW92ZSwgbGlzdCkge1xuICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS5kZXNjcmlwdG9yLmlkICE9PSByZW1vdmUuZGVzY3JpcHRvci5pZDtcbiAgfSk7XG59KTtcblxudmFyIG1vdmVUb05leHRDb21iaW5lID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBfcmVmLmlzTW92aW5nRm9yd2FyZCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgcHJldmlvdXNJbXBhY3QgPSBfcmVmLnByZXZpb3VzSW1wYWN0O1xuXG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxvY2F0aW9uID0gdHJ5R2V0RGVzdGluYXRpb24ocHJldmlvdXNJbXBhY3QpO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEltcGFjdCh0YXJnZXQpIHtcbiAgICB2YXIgYXQgPSB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiB0YXJnZXQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHByZXZpb3VzSW1wYWN0LCB7XG4gICAgICBhdDogYXRcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBhbGwgPSBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQuYWxsO1xuICB2YXIgY2xvc2VzdElkID0gYWxsLmxlbmd0aCA/IGFsbFswXSA6IG51bGw7XG5cbiAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgIHJldHVybiBjbG9zZXN0SWQgPyBnZXRJbXBhY3QoY2xvc2VzdElkKSA6IG51bGw7XG4gIH1cblxuICB2YXIgd2l0aG91dERyYWdnYWJsZSA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuXG4gIGlmICghY2xvc2VzdElkKSB7XG4gICAgaWYgKCF3aXRob3V0RHJhZ2dhYmxlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxhc3QgPSB3aXRob3V0RHJhZ2dhYmxlW3dpdGhvdXREcmFnZ2FibGUubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGdldEltcGFjdChsYXN0LmRlc2NyaXB0b3IuaWQpO1xuICB9XG5cbiAgdmFyIGluZGV4T2ZDbG9zZXN0ID0gZmluZEluZGV4KHdpdGhvdXREcmFnZ2FibGUsIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuZGVzY3JpcHRvci5pZCA9PT0gY2xvc2VzdElkO1xuICB9KTtcbiAgIShpbmRleE9mQ2xvc2VzdCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgZGlzcGxhY2VkIGl0ZW0gaW4gc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgcHJvcG9zZWRJbmRleCA9IGluZGV4T2ZDbG9zZXN0IC0gMTtcblxuICBpZiAocHJvcG9zZWRJbmRleCA8IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBiZWZvcmUgPSB3aXRob3V0RHJhZ2dhYmxlW3Byb3Bvc2VkSW5kZXhdO1xuICByZXR1cm4gZ2V0SW1wYWN0KGJlZm9yZS5kZXNjcmlwdG9yLmlkKTtcbn0pO1xuXG52YXIgaXNIb21lT2YgPSAoZnVuY3Rpb24gKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pIHtcbiAgcmV0dXJuIGRyYWdnYWJsZS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkO1xufSk7XG5cbnZhciBub0Rpc3BsYWNlZEJ5ID0ge1xuICBwb2ludDogb3JpZ2luLFxuICB2YWx1ZTogMFxufTtcbnZhciBlbXB0eUdyb3VwcyA9IHtcbiAgaW52aXNpYmxlOiB7fSxcbiAgdmlzaWJsZToge30sXG4gIGFsbDogW11cbn07XG52YXIgbm9JbXBhY3QgPSB7XG4gIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gIGRpc3BsYWNlZEJ5OiBub0Rpc3BsYWNlZEJ5LFxuICBhdDogbnVsbFxufTtcblxudmFyIGlzV2l0aGluID0gKGZ1bmN0aW9uIChsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbG93ZXJCb3VuZCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1cHBlckJvdW5kO1xuICB9O1xufSk7XG5cbnZhciBpc1BhcnRpYWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSAoZnVuY3Rpb24gKGZyYW1lKSB7XG4gIHZhciBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICB2YXIgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICB2YXIgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG5cbiAgICBpZiAoaXNDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5ID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgfHwgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSk7XG4gICAgdmFyIGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSA9IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpIHx8IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICB2YXIgaXNQYXJ0aWFsbHlDb250YWluZWQgPSBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseTtcblxuICAgIGlmIChpc1BhcnRpYWxseUNvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQmlnZ2VyVmVydGljYWxseSA9IHN1YmplY3QudG9wIDwgZnJhbWUudG9wICYmIHN1YmplY3QuYm90dG9tID4gZnJhbWUuYm90dG9tO1xuICAgIHZhciBpc0JpZ2dlckhvcml6b250YWxseSA9IHN1YmplY3QubGVmdCA8IGZyYW1lLmxlZnQgJiYgc3ViamVjdC5yaWdodCA+IGZyYW1lLnJpZ2h0O1xuICAgIHZhciBpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSA9IGlzQmlnZ2VyVmVydGljYWxseSAmJiBpc0JpZ2dlckhvcml6b250YWxseTtcblxuICAgIGlmIChpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzID0gaXNCaWdnZXJWZXJ0aWNhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSB8fCBpc0JpZ2dlckhvcml6b250YWxseSAmJiBpc1BhcnRpYWxseVZpc2libGVWZXJ0aWNhbGx5O1xuICAgIHJldHVybiBpc1RhcmdldEJpZ2dlck9uT25lQXhpcztcbiAgfTtcbn0pO1xuXG52YXIgaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSA9IChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgdmFyIGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIHZhciBpc1dpdGhpbkhvcml6b250YWwgPSBpc1dpdGhpbihmcmFtZS5sZWZ0LCBmcmFtZS5yaWdodCk7XG4gIHJldHVybiBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHZhciBpc0NvbnRhaW5lZCA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApICYmIGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICByZXR1cm4gaXNDb250YWluZWQ7XG4gIH07XG59KTtcblxudmFyIHZlcnRpY2FsID0ge1xuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGxpbmU6ICd5JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3gnLFxuICBzdGFydDogJ3RvcCcsXG4gIGVuZDogJ2JvdHRvbScsXG4gIHNpemU6ICdoZWlnaHQnLFxuICBjcm9zc0F4aXNTdGFydDogJ2xlZnQnLFxuICBjcm9zc0F4aXNFbmQ6ICdyaWdodCcsXG4gIGNyb3NzQXhpc1NpemU6ICd3aWR0aCdcbn07XG52YXIgaG9yaXpvbnRhbCA9IHtcbiAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gIGxpbmU6ICd4JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3knLFxuICBzdGFydDogJ2xlZnQnLFxuICBlbmQ6ICdyaWdodCcsXG4gIHNpemU6ICd3aWR0aCcsXG4gIGNyb3NzQXhpc1N0YXJ0OiAndG9wJyxcbiAgY3Jvc3NBeGlzRW5kOiAnYm90dG9tJyxcbiAgY3Jvc3NBeGlzU2l6ZTogJ2hlaWdodCdcbn07XG5cbnZhciBpc1RvdGFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lT25BeGlzID0gKGZ1bmN0aW9uIChheGlzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICB2YXIgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgICB2YXIgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgICAgaWYgKGF4aXMgPT09IHZlcnRpY2FsKSB7XG4gICAgICAgIHJldHVybiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpICYmIGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBnZXREcm9wcGFibGVEaXNwbGFjZWQgPSBmdW5jdGlvbiBnZXREcm9wcGFibGVEaXNwbGFjZWQodGFyZ2V0LCBkZXN0aW5hdGlvbikge1xuICB2YXIgZGlzcGxhY2VtZW50ID0gZGVzdGluYXRpb24uZnJhbWUgPyBkZXN0aW5hdGlvbi5mcmFtZS5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQgOiBvcmlnaW47XG4gIHJldHVybiBvZmZzZXRCeVBvc2l0aW9uKHRhcmdldCwgZGlzcGxhY2VtZW50KTtcbn07XG5cbnZhciBpc1Zpc2libGVJbkRyb3BwYWJsZSA9IGZ1bmN0aW9uIGlzVmlzaWJsZUluRHJvcHBhYmxlKHRhcmdldCwgZGVzdGluYXRpb24sIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSB7XG4gIGlmICghZGVzdGluYXRpb24uc3ViamVjdC5hY3RpdmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4oZGVzdGluYXRpb24uc3ViamVjdC5hY3RpdmUpKHRhcmdldCk7XG59O1xuXG52YXIgaXNWaXNpYmxlSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIGlzVmlzaWJsZUluVmlld3BvcnQodGFyZ2V0LCB2aWV3cG9ydCwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pIHtcbiAgcmV0dXJuIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKHZpZXdwb3J0KSh0YXJnZXQpO1xufTtcblxudmFyIGlzVmlzaWJsZSA9IGZ1bmN0aW9uIGlzVmlzaWJsZShfcmVmKSB7XG4gIHZhciB0b0JlRGlzcGxhY2VkID0gX3JlZi50YXJnZXQsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gX3JlZi53aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICAgICAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4gPSBfcmVmLmlzVmlzaWJsZVRocm91Z2hGcmFtZUZuO1xuICB2YXIgZGlzcGxhY2VkVGFyZ2V0ID0gd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA/IGdldERyb3BwYWJsZURpc3BsYWNlZCh0b0JlRGlzcGxhY2VkLCBkZXN0aW5hdGlvbikgOiB0b0JlRGlzcGxhY2VkO1xuICByZXR1cm4gaXNWaXNpYmxlSW5Ecm9wcGFibGUoZGlzcGxhY2VkVGFyZ2V0LCBkZXN0aW5hdGlvbiwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pICYmIGlzVmlzaWJsZUluVmlld3BvcnQoZGlzcGxhY2VkVGFyZ2V0LCB2aWV3cG9ydCwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pO1xufTtcblxudmFyIGlzUGFydGlhbGx5VmlzaWJsZSA9IGZ1bmN0aW9uIGlzUGFydGlhbGx5VmlzaWJsZShhcmdzKSB7XG4gIHJldHVybiBpc1Zpc2libGUoX2V4dGVuZHMoe30sIGFyZ3MsIHtcbiAgICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lXG4gIH0pKTtcbn07XG52YXIgaXNUb3RhbGx5VmlzaWJsZSA9IGZ1bmN0aW9uIGlzVG90YWxseVZpc2libGUoYXJncykge1xuICByZXR1cm4gaXNWaXNpYmxlKF9leHRlbmRzKHt9LCBhcmdzLCB7XG4gICAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVcbiAgfSkpO1xufTtcbnZhciBpc1RvdGFsbHlWaXNpYmxlT25BeGlzID0gZnVuY3Rpb24gaXNUb3RhbGx5VmlzaWJsZU9uQXhpcyhhcmdzKSB7XG4gIHJldHVybiBpc1Zpc2libGUoX2V4dGVuZHMoe30sIGFyZ3MsIHtcbiAgICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyhhcmdzLmRlc3RpbmF0aW9uLmF4aXMpXG4gIH0pKTtcbn07XG5cbnZhciBnZXRTaG91bGRBbmltYXRlID0gZnVuY3Rpb24gZ2V0U2hvdWxkQW5pbWF0ZShpZCwgbGFzdCwgZm9yY2VTaG91bGRBbmltYXRlKSB7XG4gIGlmICh0eXBlb2YgZm9yY2VTaG91bGRBbmltYXRlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gZm9yY2VTaG91bGRBbmltYXRlO1xuICB9XG5cbiAgaWYgKCFsYXN0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaW52aXNpYmxlID0gbGFzdC5pbnZpc2libGUsXG4gICAgICB2aXNpYmxlID0gbGFzdC52aXNpYmxlO1xuXG4gIGlmIChpbnZpc2libGVbaWRdKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzID0gdmlzaWJsZVtpZF07XG4gIHJldHVybiBwcmV2aW91cyA/IHByZXZpb3VzLnNob3VsZEFuaW1hdGUgOiB0cnVlO1xufTtcblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpIHtcbiAgdmFyIG1hcmdpbkJveCA9IGRyYWdnYWJsZS5wYWdlLm1hcmdpbkJveDtcbiAgdmFyIGV4cGFuZEJ5ID0ge1xuICAgIHRvcDogZGlzcGxhY2VkQnkucG9pbnQueSxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogZGlzcGxhY2VkQnkucG9pbnQueFxuICB9O1xuICByZXR1cm4gZ2V0UmVjdChleHBhbmQobWFyZ2luQm94LCBleHBhbmRCeSkpO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGFjZW1lbnRHcm91cHMoX3JlZikge1xuICB2YXIgYWZ0ZXJEcmFnZ2luZyA9IF9yZWYuYWZ0ZXJEcmFnZ2luZyxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGRpc3BsYWNlZEJ5ID0gX3JlZi5kaXNwbGFjZWRCeSxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSA9IF9yZWYuZm9yY2VTaG91bGRBbmltYXRlLFxuICAgICAgbGFzdCA9IF9yZWYubGFzdDtcbiAgcmV0dXJuIGFmdGVyRHJhZ2dpbmcucmVkdWNlKGZ1bmN0aW9uIHByb2Nlc3MoZ3JvdXBzLCBkcmFnZ2FibGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpO1xuICAgIHZhciBpZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkO1xuICAgIGdyb3Vwcy5hbGwucHVzaChpZCk7XG4gICAgdmFyIGlzVmlzaWJsZSA9IGlzUGFydGlhbGx5VmlzaWJsZSh7XG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgICB9KTtcblxuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICBncm91cHMuaW52aXNpYmxlW2RyYWdnYWJsZS5kZXNjcmlwdG9yLmlkXSA9IHRydWU7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRBbmltYXRlID0gZ2V0U2hvdWxkQW5pbWF0ZShpZCwgbGFzdCwgZm9yY2VTaG91bGRBbmltYXRlKTtcbiAgICB2YXIgZGlzcGxhY2VtZW50ID0ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgc2hvdWxkQW5pbWF0ZTogc2hvdWxkQW5pbWF0ZVxuICAgIH07XG4gICAgZ3JvdXBzLnZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgIHJldHVybiBncm91cHM7XG4gIH0sIHtcbiAgICBhbGw6IFtdLFxuICAgIHZpc2libGU6IHt9LFxuICAgIGludmlzaWJsZToge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4T2ZMYXN0SXRlbShkcmFnZ2FibGVzLCBvcHRpb25zKSB7XG4gIGlmICghZHJhZ2dhYmxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBpbmRleE9mTGFzdEl0ZW0gPSBkcmFnZ2FibGVzW2RyYWdnYWJsZXMubGVuZ3RoIC0gMV0uZGVzY3JpcHRvci5pbmRleDtcbiAgcmV0dXJuIG9wdGlvbnMuaW5Ib21lTGlzdCA/IGluZGV4T2ZMYXN0SXRlbSA6IGluZGV4T2ZMYXN0SXRlbSArIDE7XG59XG5cbmZ1bmN0aW9uIGdvQXRFbmQoX3JlZikge1xuICB2YXIgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgaW5Ib21lTGlzdCA9IF9yZWYuaW5Ib21lTGlzdCxcbiAgICAgIGRpc3BsYWNlZEJ5ID0gX3JlZi5kaXNwbGFjZWRCeSxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbjtcbiAgdmFyIG5ld0luZGV4ID0gZ2V0SW5kZXhPZkxhc3RJdGVtKGluc2lkZURlc3RpbmF0aW9uLCB7XG4gICAgaW5Ib21lTGlzdDogaW5Ib21lTGlzdFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzLFxuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ1JFT1JERVInLFxuICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmVvcmRlckltcGFjdChfcmVmMikge1xuICB2YXIgZHJhZ2dhYmxlID0gX3JlZjIuZHJhZ2dhYmxlLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmMi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZjIuZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydCA9IF9yZWYyLnZpZXdwb3J0LFxuICAgICAgZGlzcGxhY2VkQnkgPSBfcmVmMi5kaXNwbGFjZWRCeSxcbiAgICAgIGxhc3QgPSBfcmVmMi5sYXN0LFxuICAgICAgaW5kZXggPSBfcmVmMi5pbmRleCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSA9IF9yZWYyLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgdmFyIGluSG9tZUxpc3QgPSBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKTtcblxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBnb0F0RW5kKHtcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGluSG9tZUxpc3Q6IGluSG9tZUxpc3QsXG4gICAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBtYXRjaCA9IGZpbmQoaW5zaWRlRGVzdGluYXRpb24sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uZGVzY3JpcHRvci5pbmRleCA9PT0gaW5kZXg7XG4gIH0pO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZ29BdEVuZCh7XG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0OiBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uXG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIHZhciBzbGljZUZyb20gPSBpbnNpZGVEZXN0aW5hdGlvbi5pbmRleE9mKG1hdGNoKTtcbiAgdmFyIGltcGFjdGVkID0gd2l0aG91dERyYWdnaW5nLnNsaWNlKHNsaWNlRnJvbSk7XG4gIHZhciBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGltcGFjdGVkLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgbGFzdDogbGFzdCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBmb3JjZVNob3VsZEFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkOiBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlSWQsIGFmdGVyQ3JpdGljYWwpIHtcbiAgcmV0dXJuIEJvb2xlYW4oYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtkcmFnZ2FibGVJZF0pO1xufVxuXG52YXIgZnJvbUNvbWJpbmUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IF9yZWYuaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGNvbWJpbmUgPSBfcmVmLmNvbWJpbmUsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuXG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvbWJpbmVJZCA9IGNvbWJpbmUuZHJhZ2dhYmxlSWQ7XG4gIHZhciBjb21iaW5lV2l0aCA9IGRyYWdnYWJsZXNbY29tYmluZUlkXTtcbiAgdmFyIGNvbWJpbmVXaXRoSW5kZXggPSBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmluZGV4O1xuICB2YXIgZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoY29tYmluZUlkLCBhZnRlckNyaXRpY2FsKTtcblxuICBpZiAoZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwpIHtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleCAtIDE7XG4gIH1cblxuICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggKyAxO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG59KTtcblxudmFyIGZyb21SZW9yZGVyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBfcmVmLmlzTW92aW5nRm9yd2FyZCxcbiAgICAgIGlzSW5Ib21lTGlzdCA9IF9yZWYuaXNJbkhvbWVMaXN0LFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmLmluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uO1xuXG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY3VycmVudEluZGV4ID0gbG9jYXRpb24uaW5kZXg7XG4gIHZhciBwcm9wb3NlZEluZGV4ID0gaXNNb3ZpbmdGb3J3YXJkID8gY3VycmVudEluZGV4ICsgMSA6IGN1cnJlbnRJbmRleCAtIDE7XG4gIHZhciBmaXJzdEluZGV4ID0gaW5zaWRlRGVzdGluYXRpb25bMF0uZGVzY3JpcHRvci5pbmRleDtcbiAgdmFyIGxhc3RJbmRleCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIHZhciB1cHBlckJvdW5kID0gaXNJbkhvbWVMaXN0ID8gbGFzdEluZGV4IDogbGFzdEluZGV4ICsgMTtcblxuICBpZiAocHJvcG9zZWRJbmRleCA8IGZpcnN0SW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9wb3NlZEluZGV4ID4gdXBwZXJCb3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByb3Bvc2VkSW5kZXg7XG59KTtcblxudmFyIG1vdmVUb05leHRJbmRleCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaXNNb3ZpbmdGb3J3YXJkID0gX3JlZi5pc01vdmluZ0ZvcndhcmQsXG4gICAgICBpc0luSG9tZUxpc3QgPSBfcmVmLmlzSW5Ib21lTGlzdCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIHByZXZpb3VzSW1wYWN0ID0gX3JlZi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciB3YXNBdCA9IHByZXZpb3VzSW1wYWN0LmF0O1xuICAhd2FzQXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgbW92ZSBpbiBkaXJlY3Rpb24gd2l0aG91dCBwcmV2aW91cyBpbXBhY3QgbG9jYXRpb24nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaWYgKHdhc0F0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHZhciBfbmV3SW5kZXggPSBmcm9tUmVvcmRlcih7XG4gICAgICBpc01vdmluZ0ZvcndhcmQ6IGlzTW92aW5nRm9yd2FyZCxcbiAgICAgIGlzSW5Ib21lTGlzdDogaXNJbkhvbWVMaXN0LFxuICAgICAgbG9jYXRpb246IHdhc0F0LmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAoX25ld0luZGV4ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgZGlzcGxhY2VkQnk6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgICAgaW5kZXg6IF9uZXdJbmRleFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIG5ld0luZGV4ID0gZnJvbUNvbWJpbmUoe1xuICAgIGlzTW92aW5nRm9yd2FyZDogaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGNvbWJpbmU6IHdhc0F0LmNvbWJpbmUsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcblxuICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGxhc3Q6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeTogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgaW5kZXg6IG5ld0luZGV4XG4gIH0pO1xufSk7XG5cbnZhciBnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRpc3BsYWNlZCA9IF9yZWYuZGlzcGxhY2VkLFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbCxcbiAgICAgIGNvbWJpbmVXaXRoID0gX3JlZi5jb21iaW5lV2l0aCxcbiAgICAgIGRpc3BsYWNlZEJ5ID0gX3JlZi5kaXNwbGFjZWRCeTtcbiAgdmFyIGlzRGlzcGxhY2VkID0gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtjb21iaW5lV2l0aF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtjb21iaW5lV2l0aF0pO1xuXG4gIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwoY29tYmluZVdpdGgsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgcmV0dXJuIGlzRGlzcGxhY2VkID8gb3JpZ2luIDogbmVnYXRlKGRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgfVxuXG4gIHJldHVybiBpc0Rpc3BsYWNlZCA/IGRpc3BsYWNlZEJ5LnBvaW50IDogb3JpZ2luO1xufSk7XG5cbnZhciB3aGVuQ29tYmluaW5nID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsLFxuICAgICAgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzO1xuICB2YXIgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgIWNvbWJpbmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGNvbWJpbmVXaXRoID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgdmFyIGNlbnRlciA9IGRyYWdnYWJsZXNbY29tYmluZVdpdGhdLnBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgdmFyIGRpc3BsYWNlQnkgPSBnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQoe1xuICAgIGRpc3BsYWNlZDogaW1wYWN0LmRpc3BsYWNlZCxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsLFxuICAgIGNvbWJpbmVXaXRoOiBjb21iaW5lV2l0aCxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5XG4gIH0pO1xuICByZXR1cm4gYWRkKGNlbnRlciwgZGlzcGxhY2VCeSk7XG59KTtcblxudmFyIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIgPSBmdW5jdGlvbiBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGJveCkge1xuICByZXR1cm4gYm94Lm1hcmdpbltheGlzLnN0YXJ0XSArIGJveC5ib3JkZXJCb3hbYXhpcy5zaXplXSAvIDI7XG59O1xuXG52YXIgZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIgPSBmdW5jdGlvbiBkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlcihheGlzLCBib3gpIHtcbiAgcmV0dXJuIGJveC5tYXJnaW5bYXhpcy5lbmRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbn07XG5cbnZhciBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIgPSBmdW5jdGlvbiBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgdGFyZ2V0LCBpc01vdmluZykge1xuICByZXR1cm4gdGFyZ2V0W2F4aXMuY3Jvc3NBeGlzU3RhcnRdICsgaXNNb3ZpbmcubWFyZ2luW2F4aXMuY3Jvc3NBeGlzU3RhcnRdICsgaXNNb3ZpbmcuYm9yZGVyQm94W2F4aXMuY3Jvc3NBeGlzU2l6ZV0gLyAyO1xufTtcblxudmFyIGdvQWZ0ZXIgPSBmdW5jdGlvbiBnb0FmdGVyKF9yZWYpIHtcbiAgdmFyIGF4aXMgPSBfcmVmLmF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbyA9IF9yZWYubW92ZVJlbGF0aXZlVG8sXG4gICAgICBpc01vdmluZyA9IF9yZWYuaXNNb3Zpbmc7XG4gIHJldHVybiBwYXRjaChheGlzLmxpbmUsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveFtheGlzLmVuZF0gKyBkaXN0YW5jZUZyb21TdGFydFRvQm9yZGVyQm94Q2VudGVyKGF4aXMsIGlzTW92aW5nKSwgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyKGF4aXMsIG1vdmVSZWxhdGl2ZVRvLm1hcmdpbkJveCwgaXNNb3ZpbmcpKTtcbn07XG52YXIgZ29CZWZvcmUgPSBmdW5jdGlvbiBnb0JlZm9yZShfcmVmMikge1xuICB2YXIgYXhpcyA9IF9yZWYyLmF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbyA9IF9yZWYyLm1vdmVSZWxhdGl2ZVRvLFxuICAgICAgaXNNb3ZpbmcgPSBfcmVmMi5pc01vdmluZztcbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuc3RhcnRdIC0gZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xufTtcbnZhciBnb0ludG9TdGFydCA9IGZ1bmN0aW9uIGdvSW50b1N0YXJ0KF9yZWYzKSB7XG4gIHZhciBheGlzID0gX3JlZjMuYXhpcyxcbiAgICAgIG1vdmVJbnRvID0gX3JlZjMubW92ZUludG8sXG4gICAgICBpc01vdmluZyA9IF9yZWYzLmlzTW92aW5nO1xuICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBtb3ZlSW50by5jb250ZW50Qm94W2F4aXMuc3RhcnRdICsgZGlzdGFuY2VGcm9tU3RhcnRUb0JvcmRlckJveENlbnRlcihheGlzLCBpc01vdmluZyksIGdldENyb3NzQXhpc0JvcmRlckJveENlbnRlcihheGlzLCBtb3ZlSW50by5jb250ZW50Qm94LCBpc01vdmluZykpO1xufTtcblxudmFyIHdoZW5SZW9yZGVyaW5nID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZSA9IF9yZWYuZHJvcHBhYmxlLFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIHZhciBkcmFnZ2FibGVQYWdlID0gZHJhZ2dhYmxlLnBhZ2U7XG4gIHZhciBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG5cbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ29JbnRvU3RhcnQoe1xuICAgICAgYXhpczogYXhpcyxcbiAgICAgIG1vdmVJbnRvOiBkcm9wcGFibGUucGFnZSxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgZGlzcGxhY2VkID0gaW1wYWN0LmRpc3BsYWNlZCxcbiAgICAgIGRpc3BsYWNlZEJ5ID0gaW1wYWN0LmRpc3BsYWNlZEJ5O1xuICB2YXIgY2xvc2VzdEFmdGVyID0gZGlzcGxhY2VkLmFsbFswXTtcblxuICBpZiAoY2xvc2VzdEFmdGVyKSB7XG4gICAgdmFyIGNsb3Nlc3QgPSBkcmFnZ2FibGVzW2Nsb3Nlc3RBZnRlcl07XG5cbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNsb3Nlc3RBZnRlciwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICAgIHJldHVybiBnb0JlZm9yZSh7XG4gICAgICAgIGF4aXM6IGF4aXMsXG4gICAgICAgIG1vdmVSZWxhdGl2ZVRvOiBjbG9zZXN0LnBhZ2UsXG4gICAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgd2l0aERpc3BsYWNlbWVudCA9IG9mZnNldChjbG9zZXN0LnBhZ2UsIGRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgYXhpczogYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiB3aXRoRGlzcGxhY2VtZW50LFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV07XG5cbiAgaWYgKGxhc3QuZGVzY3JpcHRvci5pZCA9PT0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQpIHtcbiAgICByZXR1cm4gZHJhZ2dhYmxlUGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICB9XG5cbiAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChsYXN0LmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgdmFyIHBhZ2UgPSBvZmZzZXQobGFzdC5wYWdlLCBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkpO1xuICAgIHJldHVybiBnb0FmdGVyKHtcbiAgICAgIGF4aXM6IGF4aXMsXG4gICAgICBtb3ZlUmVsYXRpdmVUbzogcGFnZSxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZ29BZnRlcih7XG4gICAgYXhpczogYXhpcyxcbiAgICBtb3ZlUmVsYXRpdmVUbzogbGFzdC5wYWdlLFxuICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gIH0pO1xufSk7XG5cbnZhciB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gKGZ1bmN0aW9uIChkcm9wcGFibGUsIHBvaW50KSB7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgcmV0dXJuIGFkZChwb2ludCwgZnJhbWUuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50KTtcbn0pO1xuXG52YXIgZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCA9IGZ1bmN0aW9uIGdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQoX3JlZikge1xuICB2YXIgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRyb3BwYWJsZSA9IF9yZWYuZHJvcHBhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIHZhciBhdCA9IGltcGFjdC5hdDtcblxuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuXG4gIGlmICghYXQpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cblxuICBpZiAoYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHdoZW5SZW9yZGVyaW5nKHtcbiAgICAgIGltcGFjdDogaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlOiBkcm9wcGFibGUsXG4gICAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gd2hlbkNvbWJpbmluZyh7XG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xufTtcblxudmFyIGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0ID0gKGZ1bmN0aW9uIChhcmdzKSB7XG4gIHZhciB3aXRob3V0RGlzcGxhY2VtZW50ID0gZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudChhcmdzKTtcbiAgdmFyIGRyb3BwYWJsZSA9IGFyZ3MuZHJvcHBhYmxlO1xuICB2YXIgd2l0aERpc3BsYWNlbWVudCA9IGRyb3BwYWJsZSA/IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZHJvcHBhYmxlLCB3aXRob3V0RGlzcGxhY2VtZW50KSA6IHdpdGhvdXREaXNwbGFjZW1lbnQ7XG4gIHJldHVybiB3aXRoRGlzcGxhY2VtZW50O1xufSk7XG5cbnZhciBzY3JvbGxWaWV3cG9ydCA9IChmdW5jdGlvbiAodmlld3BvcnQsIG5ld1Njcm9sbCkge1xuICB2YXIgZGlmZiA9IHN1YnRyYWN0KG5ld1Njcm9sbCwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpO1xuICB2YXIgZGlzcGxhY2VtZW50ID0gbmVnYXRlKGRpZmYpO1xuICB2YXIgZnJhbWUgPSBnZXRSZWN0KHtcbiAgICB0b3A6IG5ld1Njcm9sbC55LFxuICAgIGJvdHRvbTogbmV3U2Nyb2xsLnkgKyB2aWV3cG9ydC5mcmFtZS5oZWlnaHQsXG4gICAgbGVmdDogbmV3U2Nyb2xsLngsXG4gICAgcmlnaHQ6IG5ld1Njcm9sbC54ICsgdmlld3BvcnQuZnJhbWUud2lkdGhcbiAgfSk7XG4gIHZhciB1cGRhdGVkID0ge1xuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBzY3JvbGw6IHtcbiAgICAgIGluaXRpYWw6IHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsLFxuICAgICAgbWF4OiB2aWV3cG9ydC5zY3JvbGwubWF4LFxuICAgICAgY3VycmVudDogbmV3U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogZGlmZixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBkaXNwbGFjZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVkO1xufSk7XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZXMoaWRzLCBkcmFnZ2FibGVzKSB7XG4gIHJldHVybiBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBkcmFnZ2FibGVzW2lkXTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyeUdldFZpc2libGUoaWQsIGdyb3Vwcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXNwbGFjZW1lbnQgPSBncm91cHNbaV0udmlzaWJsZVtpZF07XG5cbiAgICBpZiAoZGlzcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gZGlzcGxhY2VtZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgc3BlY3VsYXRpdmVseUluY3JlYXNlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBtYXhTY3JvbGxDaGFuZ2UgPSBfcmVmLm1heFNjcm9sbENoYW5nZTtcbiAgdmFyIHNjcm9sbGVkVmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydCh2aWV3cG9ydCwgYWRkKHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKTtcbiAgdmFyIHNjcm9sbGVkRHJvcHBhYmxlID0gZGVzdGluYXRpb24uZnJhbWUgPyBzY3JvbGxEcm9wcGFibGUoZGVzdGluYXRpb24sIGFkZChkZXN0aW5hdGlvbi5mcmFtZS5zY3JvbGwuY3VycmVudCwgbWF4U2Nyb2xsQ2hhbmdlKSkgOiBkZXN0aW5hdGlvbjtcbiAgdmFyIGxhc3QgPSBpbXBhY3QuZGlzcGxhY2VkO1xuICB2YXIgd2l0aFZpZXdwb3J0U2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzKGxhc3QuYWxsLCBkcmFnZ2FibGVzKSxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogc2Nyb2xsZWRWaWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0OiBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIHZhciB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzKGxhc3QuYWxsLCBkcmFnZ2FibGVzKSxcbiAgICBkZXN0aW5hdGlvbjogc2Nyb2xsZWREcm9wcGFibGUsXG4gICAgZGlzcGxhY2VkQnk6IGltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdDogbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICB2YXIgaW52aXNpYmxlID0ge307XG4gIHZhciB2aXNpYmxlID0ge307XG4gIHZhciBncm91cHMgPSBbbGFzdCwgd2l0aFZpZXdwb3J0U2Nyb2xsLCB3aXRoRHJvcHBhYmxlU2Nyb2xsXTtcbiAgbGFzdC5hbGwuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZGlzcGxhY2VtZW50ID0gdHJ5R2V0VmlzaWJsZShpZCwgZ3JvdXBzKTtcblxuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmlzaWJsZVtpZF0gPSB0cnVlO1xuICB9KTtcblxuICB2YXIgbmV3SW1wYWN0ID0gX2V4dGVuZHMoe30sIGltcGFjdCwge1xuICAgIGRpc3BsYWNlZDoge1xuICAgICAgYWxsOiBsYXN0LmFsbCxcbiAgICAgIGludmlzaWJsZTogaW52aXNpYmxlLFxuICAgICAgdmlzaWJsZTogdmlzaWJsZVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5ld0ltcGFjdDtcbn0pO1xuXG52YXIgd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50ID0gKGZ1bmN0aW9uICh2aWV3cG9ydCwgcG9pbnQpIHtcbiAgcmV0dXJuIGFkZCh2aWV3cG9ydC5zY3JvbGwuZGlmZi5kaXNwbGFjZW1lbnQsIHBvaW50KTtcbn0pO1xuXG52YXIgZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBfcmVmLnBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydDtcbiAgdmFyIHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlID0gd2l0aFZpZXdwb3J0RGlzcGxhY2VtZW50KHZpZXdwb3J0LCBwYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgdmFyIG9mZnNldCA9IHN1YnRyYWN0KHdpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlLCBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyKTtcbiAgcmV0dXJuIGFkZChkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIsIG9mZnNldCk7XG59KTtcblxudmFyIGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIgPSBfcmVmLm5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gX3JlZi53aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50LFxuICAgICAgX3JlZiRvbmx5T25NYWluQXhpcyA9IF9yZWYub25seU9uTWFpbkF4aXMsXG4gICAgICBvbmx5T25NYWluQXhpcyA9IF9yZWYkb25seU9uTWFpbkF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRvbmx5T25NYWluQXhpcztcbiAgdmFyIGNoYW5nZU5lZWRlZCA9IHN1YnRyYWN0KG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXIsIGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXIpO1xuICB2YXIgc2hpZnRlZCA9IG9mZnNldEJ5UG9zaXRpb24oZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LCBjaGFuZ2VOZWVkZWQpO1xuICB2YXIgYXJncyA9IHtcbiAgICB0YXJnZXQ6IHNoaWZ0ZWQsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH07XG4gIHJldHVybiBvbmx5T25NYWluQXhpcyA/IGlzVG90YWxseVZpc2libGVPbkF4aXMoYXJncykgOiBpc1RvdGFsbHlWaXNpYmxlKGFyZ3MpO1xufSk7XG5cbnZhciBtb3ZlVG9OZXh0UGxhY2UgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IF9yZWYuaXNNb3ZpbmdGb3J3YXJkLFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgcHJldmlvdXNJbXBhY3QgPSBfcmVmLnByZXZpb3VzSW1wYWN0LFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gX3JlZi5wcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbiA9IF9yZWYucHJldmlvdXNDbGllbnRTZWxlY3Rpb24sXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuXG4gIGlmICghZGVzdGluYXRpb24uaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICB2YXIgaXNJbkhvbWVMaXN0ID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbik7XG4gIHZhciBpbXBhY3QgPSBtb3ZlVG9OZXh0Q29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkOiBpc01vdmluZ0ZvcndhcmQsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdDogcHJldmlvdXNJbXBhY3RcbiAgfSkgfHwgbW92ZVRvTmV4dEluZGV4KHtcbiAgICBpc01vdmluZ0ZvcndhcmQ6IGlzTW92aW5nRm9yd2FyZCxcbiAgICBpc0luSG9tZUxpc3Q6IGlzSW5Ib21lTGlzdCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgcHJldmlvdXNJbXBhY3Q6IHByZXZpb3VzSW1wYWN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuXG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgdmFyIGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IGZhbHNlLFxuICAgIG9ubHlPbk1haW5BeGlzOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChpc1Zpc2libGVJbk5ld0xvY2F0aW9uKSB7XG4gICAgdmFyIGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRTZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGltcGFjdDogaW1wYWN0LFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRpc3RhbmNlID0gc3VidHJhY3QocGFnZUJvcmRlckJveENlbnRlciwgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyKTtcbiAgdmFyIGNhdXRpb3VzID0gc3BlY3VsYXRpdmVseUluY3JlYXNlKHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgbWF4U2Nyb2xsQ2hhbmdlOiBkaXN0YW5jZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb246IHByZXZpb3VzQ2xpZW50U2VsZWN0aW9uLFxuICAgIGltcGFjdDogY2F1dGlvdXMsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IGRpc3RhbmNlXG4gIH07XG59KTtcblxudmFyIGdldEtub3duQWN0aXZlID0gZnVuY3Rpb24gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKSB7XG4gIHZhciByZWN0ID0gZHJvcHBhYmxlLnN1YmplY3QuYWN0aXZlO1xuICAhcmVjdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBnZXQgY2xpcHBlZCBhcmVhIGZyb20gZHJvcHBhYmxlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gcmVjdDtcbn07XG5cbnZhciBnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBfcmVmLmlzTW92aW5nRm9yd2FyZCxcbiAgICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBfcmVmLnBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmLmRyb3BwYWJsZXMsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQ7XG4gIHZhciBhY3RpdmUgPSBzb3VyY2Uuc3ViamVjdC5hY3RpdmU7XG5cbiAgaWYgKCFhY3RpdmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBheGlzID0gc291cmNlLmF4aXM7XG4gIHZhciBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuc3RhcnRdLCBhY3RpdmVbYXhpcy5lbmRdKTtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB0b0Ryb3BwYWJsZUxpc3QoZHJvcHBhYmxlcykuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlICE9PSBzb3VyY2U7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZS5pc0VuYWJsZWQ7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZHJvcHBhYmxlLnN1YmplY3QuYWN0aXZlKTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICByZXR1cm4gaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lKHZpZXdwb3J0LmZyYW1lKShnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpKTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICB2YXIgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuXG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZVtheGlzLmNyb3NzQXhpc0VuZF0gPCBhY3RpdmVPZlRhcmdldFtheGlzLmNyb3NzQXhpc0VuZF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZU9mVGFyZ2V0W2F4aXMuY3Jvc3NBeGlzU3RhcnRdIDwgYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgIHZhciBhY3RpdmVPZlRhcmdldCA9IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSk7XG4gICAgdmFyIGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZCA9IGlzV2l0aGluKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuc3RhcnRdLCBhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pO1xuICAgIHJldHVybiBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuc3RhcnRdKSB8fCBpc0JldHdlZW5Tb3VyY2VDbGlwcGVkKGFjdGl2ZU9mVGFyZ2V0W2F4aXMuZW5kXSkgfHwgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkKGFjdGl2ZVtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuRGVzdGluYXRpb25DbGlwcGVkKGFjdGl2ZVtheGlzLmVuZF0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGZpcnN0ID0gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgdmFyIHNlY29uZCA9IGdldEtub3duQWN0aXZlKGIpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdO1xuXG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cblxuICAgIHJldHVybiBzZWNvbmQgLSBmaXJzdDtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkcm9wcGFibGUsIGluZGV4LCBhcnJheSkge1xuICAgIHJldHVybiBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuY3Jvc3NBeGlzU3RhcnRdID09PSBnZXRLbm93bkFjdGl2ZShhcnJheVswXSlbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gIH0pO1xuXG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjYW5kaWRhdGVzWzBdO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5zID0gY2FuZGlkYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGRyb3BwYWJsZSkge1xuICAgIHZhciBpc1dpdGhpbkRyb3BwYWJsZSA9IGlzV2l0aGluKGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5zdGFydF0sIGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNXaXRoaW5Ecm9wcGFibGUocGFnZUJvcmRlckJveENlbnRlcltheGlzLmxpbmVdKTtcbiAgfSk7XG5cbiAgaWYgKGNvbnRhaW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjb250YWluc1swXTtcbiAgfVxuXG4gIGlmIChjb250YWlucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBnZXRLbm93bkFjdGl2ZShhKVtheGlzLnN0YXJ0XSAtIGdldEtub3duQWN0aXZlKGIpW2F4aXMuc3RhcnRdO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBmaXJzdCA9IGNsb3Nlc3QocGFnZUJvcmRlckJveENlbnRlciwgZ2V0Q29ybmVycyhnZXRLbm93bkFjdGl2ZShhKSkpO1xuICAgIHZhciBzZWNvbmQgPSBjbG9zZXN0KHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYikpKTtcblxuICAgIGlmIChmaXJzdCAhPT0gc2Vjb25kKSB7XG4gICAgICByZXR1cm4gZmlyc3QgLSBzZWNvbmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF07XG4gIH0pWzBdO1xufSk7XG5cbnZhciBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlciA9IGZ1bmN0aW9uIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCkge1xuICB2YXIgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICByZXR1cm4gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSA/IHN1YnRyYWN0KG9yaWdpbmFsLCBhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSA6IG9yaWdpbmFsO1xufTtcbnZhciBnZXRDdXJyZW50UGFnZUJvcmRlckJveCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94KGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCkge1xuICB2YXIgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3g7XG4gIHJldHVybiBkaWRTdGFydEFmdGVyQ3JpdGljYWwoZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsIGFmdGVyQ3JpdGljYWwpID8gb2Zmc2V0QnlQb3NpdGlvbihvcmlnaW5hbCwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKSA6IG9yaWdpbmFsO1xufTtcblxudmFyIGdldENsb3Nlc3REcmFnZ2FibGUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBfcmVmLnBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgc29ydGVkID0gaW5zaWRlRGVzdGluYXRpb24uZmlsdGVyKGZ1bmN0aW9uIChkcmFnZ2FibGUpIHtcbiAgICByZXR1cm4gaXNUb3RhbGx5VmlzaWJsZSh7XG4gICAgICB0YXJnZXQ6IGdldEN1cnJlbnRQYWdlQm9yZGVyQm94KGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCksXG4gICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB0cnVlXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgZGlzdGFuY2VUb0EgPSBkaXN0YW5jZShwYWdlQm9yZGVyQm94Q2VudGVyLCB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRlc3RpbmF0aW9uLCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihhLCBhZnRlckNyaXRpY2FsKSkpO1xuICAgIHZhciBkaXN0YW5jZVRvQiA9IGRpc3RhbmNlKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZGVzdGluYXRpb24sIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGIsIGFmdGVyQ3JpdGljYWwpKSk7XG5cbiAgICBpZiAoZGlzdGFuY2VUb0EgPCBkaXN0YW5jZVRvQikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmIChkaXN0YW5jZVRvQiA8IGRpc3RhbmNlVG9BKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4O1xuICB9KTtcbiAgcmV0dXJuIHNvcnRlZFswXSB8fCBudWxsO1xufSk7XG5cbnZhciBnZXREaXNwbGFjZWRCeSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gZ2V0RGlzcGxhY2VkQnkoYXhpcywgZGlzcGxhY2VCeSkge1xuICB2YXIgZGlzcGxhY2VtZW50ID0gZGlzcGxhY2VCeVtheGlzLmxpbmVdO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBkaXNwbGFjZW1lbnQsXG4gICAgcG9pbnQ6IHBhdGNoKGF4aXMubGluZSwgZGlzcGxhY2VtZW50KVxuICB9O1xufSk7XG5cbnZhciBnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyID0gZnVuY3Rpb24gZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlcihkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcykge1xuICB2YXIgYXhpcyA9IGRyb3BwYWJsZS5heGlzO1xuXG4gIGlmIChkcm9wcGFibGUuZGVzY3JpcHRvci5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXSk7XG4gIH1cblxuICB2YXIgYXZhaWxhYmxlU3BhY2UgPSBkcm9wcGFibGUuc3ViamVjdC5wYWdlLmNvbnRlbnRCb3hbYXhpcy5zaXplXTtcbiAgdmFyIGluc2lkZURyb3BwYWJsZSA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICB2YXIgc3BhY2VVc2VkID0gaW5zaWRlRHJvcHBhYmxlLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkaW1lbnNpb24pIHtcbiAgICByZXR1cm4gc3VtICsgZGltZW5zaW9uLmNsaWVudC5tYXJnaW5Cb3hbYXhpcy5zaXplXTtcbiAgfSwgMCk7XG4gIHZhciByZXF1aXJlZFNwYWNlID0gc3BhY2VVc2VkICsgcGxhY2Vob2xkZXJTaXplW2F4aXMubGluZV07XG4gIHZhciBuZWVkc1RvR3Jvd0J5ID0gcmVxdWlyZWRTcGFjZSAtIGF2YWlsYWJsZVNwYWNlO1xuXG4gIGlmIChuZWVkc1RvR3Jvd0J5IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXRjaChheGlzLmxpbmUsIG5lZWRzVG9Hcm93QnkpO1xufTtcblxudmFyIHdpdGhNYXhTY3JvbGwgPSBmdW5jdGlvbiB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBtYXgpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBmcmFtZSwge1xuICAgIHNjcm9sbDogX2V4dGVuZHMoe30sIGZyYW1lLnNjcm9sbCwge1xuICAgICAgbWF4OiBtYXhcbiAgICB9KVxuICB9KTtcbn07XG5cbnZhciBhZGRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIGFkZFBsYWNlaG9sZGVyKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKSB7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgISFpc0hvbWVPZihkcmFnZ2FibGUsIGRyb3BwYWJsZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgbm90IGFkZCBwbGFjZWhvbGRlciBzcGFjZSB0byBob21lIGxpc3QnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICEhZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGFkZCBwbGFjZWhvbGRlciBzaXplIHRvIGEgc3ViamVjdCB3aGVuIGl0IGFscmVhZHkgaGFzIG9uZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIHBsYWNlaG9sZGVyU2l6ZSA9IGdldERpc3BsYWNlZEJ5KGRyb3BwYWJsZS5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSkucG9pbnQ7XG4gIHZhciByZXF1aXJlZEdyb3d0aCA9IGdldFJlcXVpcmVkR3Jvd3RoRm9yUGxhY2Vob2xkZXIoZHJvcHBhYmxlLCBwbGFjZWhvbGRlclNpemUsIGRyYWdnYWJsZXMpO1xuICB2YXIgYWRkZWQgPSB7XG4gICAgcGxhY2Vob2xkZXJTaXplOiBwbGFjZWhvbGRlclNpemUsXG4gICAgaW5jcmVhc2VkQnk6IHJlcXVpcmVkR3Jvd3RoLFxuICAgIG9sZEZyYW1lTWF4U2Nyb2xsOiBkcm9wcGFibGUuZnJhbWUgPyBkcm9wcGFibGUuZnJhbWUuc2Nyb2xsLm1heCA6IG51bGxcbiAgfTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgdmFyIF9zdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgICAgd2l0aFBsYWNlaG9sZGVyOiBhZGRlZCxcbiAgICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgICAgZnJhbWU6IGRyb3BwYWJsZS5mcmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBkcm9wcGFibGUsIHtcbiAgICAgIHN1YmplY3Q6IF9zdWJqZWN0XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbWF4U2Nyb2xsID0gcmVxdWlyZWRHcm93dGggPyBhZGQoZnJhbWUuc2Nyb2xsLm1heCwgcmVxdWlyZWRHcm93dGgpIDogZnJhbWUuc2Nyb2xsLm1heDtcbiAgdmFyIG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgbWF4U2Nyb2xsKTtcbiAgdmFyIHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogYWRkZWQsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH0pO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGRyb3BwYWJsZSwge1xuICAgIHN1YmplY3Q6IHN1YmplY3QsXG4gICAgZnJhbWU6IG5ld0ZyYW1lXG4gIH0pO1xufTtcbnZhciByZW1vdmVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIHJlbW92ZVBsYWNlaG9sZGVyKGRyb3BwYWJsZSkge1xuICB2YXIgYWRkZWQgPSBkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXI7XG4gICFhZGRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCByZW1vdmUgcGxhY2Vob2xkZXIgZm9ybSBzdWJqZWN0IHdoZW4gdGhlcmUgd2FzIG5vbmUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgdmFyIF9zdWJqZWN0MiA9IGdldFN1YmplY3Qoe1xuICAgICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgICAgZnJhbWU6IG51bGwsXG4gICAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGxcbiAgICB9KTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZHJvcHBhYmxlLCB7XG4gICAgICBzdWJqZWN0OiBfc3ViamVjdDJcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBvbGRNYXhTY3JvbGwgPSBhZGRlZC5vbGRGcmFtZU1heFNjcm9sbDtcbiAgIW9sZE1heFNjcm9sbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyb3BwYWJsZSB3aXRoIGZyYW1lIHRvIGhhdmUgb2xkIG1heCBmcmFtZSBzY3JvbGwgd2hlbiByZW1vdmluZyBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgb2xkTWF4U2Nyb2xsKTtcbiAgdmFyIHN1YmplY3QgPSBnZXRTdWJqZWN0KHtcbiAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGxcbiAgfSk7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZHJvcHBhYmxlLCB7XG4gICAgc3ViamVjdDogc3ViamVjdCxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfSk7XG59O1xuXG52YXIgbW92ZVRvTmV3RHJvcHBhYmxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIgPSBfcmVmLnByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIG1vdmVSZWxhdGl2ZVRvID0gX3JlZi5tb3ZlUmVsYXRpdmVUbyxcbiAgICAgIGluc2lkZURlc3RpbmF0aW9uID0gX3JlZi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG5cbiAgaWYgKCFtb3ZlUmVsYXRpdmVUbykge1xuICAgIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwcm9wb3NlZCA9IHtcbiAgICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgICAgIGF0OiB7XG4gICAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgICBpbmRleDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgICAgaW1wYWN0OiBwcm9wb3NlZCxcbiAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gICAgdmFyIHdpdGhQbGFjZWhvbGRlciA9IGlzSG9tZU9mKGRyYWdnYWJsZSwgZGVzdGluYXRpb24pID8gZGVzdGluYXRpb24gOiBhZGRQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKTtcbiAgICB2YXIgaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA9IGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uKHtcbiAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgZGVzdGluYXRpb246IHdpdGhQbGFjZWhvbGRlcixcbiAgICAgIG5ld1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IGZhbHNlLFxuICAgICAgb25seU9uTWFpbkF4aXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA/IHByb3Bvc2VkIDogbnVsbDtcbiAgfVxuXG4gIHZhciBpc0dvaW5nQmVmb3JlVGFyZ2V0ID0gQm9vbGVhbihwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXJbZGVzdGluYXRpb24uYXhpcy5saW5lXSA8PSBtb3ZlUmVsYXRpdmVUby5wYWdlLmJvcmRlckJveC5jZW50ZXJbZGVzdGluYXRpb24uYXhpcy5saW5lXSk7XG5cbiAgdmFyIHByb3Bvc2VkSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbGF0aXZlVG8gPSBtb3ZlUmVsYXRpdmVUby5kZXNjcmlwdG9yLmluZGV4O1xuXG4gICAgaWYgKG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG5cbiAgICBpZiAoaXNHb2luZ0JlZm9yZVRhcmdldCkge1xuICAgICAgcmV0dXJuIHJlbGF0aXZlVG87XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbGF0aXZlVG8gKyAxO1xuICB9KCk7XG5cbiAgdmFyIGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IGVtcHR5R3JvdXBzLFxuICAgIGluZGV4OiBwcm9wb3NlZEluZGV4XG4gIH0pO1xufSk7XG5cbnZhciBtb3ZlQ3Jvc3NBeGlzID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBfcmVmLmlzTW92aW5nRm9yd2FyZCxcbiAgICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciA9IF9yZWYucHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBpc092ZXIgPSBfcmVmLmlzT3ZlcixcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzID0gX3JlZi5kcm9wcGFibGVzLFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIGRlc3RpbmF0aW9uID0gZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkOiBpc01vdmluZ0ZvcndhcmQsXG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIHNvdXJjZTogaXNPdmVyLFxuICAgIGRyb3BwYWJsZXM6IGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH0pO1xuXG4gIGlmICghZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIHZhciBtb3ZlUmVsYXRpdmVUbyA9IGdldENsb3Nlc3REcmFnZ2FibGUoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICB2YXIgaW1wYWN0ID0gbW92ZVRvTmV3RHJvcHBhYmxlKHtcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICBtb3ZlUmVsYXRpdmVUbzogbW92ZVJlbGF0aXZlVG8sXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xuXG4gIGlmICghaW1wYWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgdmFyIGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyOiBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjbGllbnRTZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICB9O1xufSk7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlciA9IChmdW5jdGlvbiAoaW1wYWN0KSB7XG4gIHZhciBhdCA9IGltcGFjdC5hdDtcblxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIGF0LmRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICB9XG5cbiAgcmV0dXJuIGF0LmNvbWJpbmUuZHJvcHBhYmxlSWQ7XG59KTtcblxudmFyIGdldERyb3BwYWJsZU92ZXIgPSBmdW5jdGlvbiBnZXREcm9wcGFibGVPdmVyKGltcGFjdCwgZHJvcHBhYmxlcykge1xuICB2YXIgaWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICByZXR1cm4gaWQgPyBkcm9wcGFibGVzW2lkXSA6IG51bGw7XG59O1xuXG52YXIgbW92ZUluRGlyZWN0aW9uID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICB0eXBlID0gX3JlZi50eXBlO1xuICB2YXIgaXNBY3R1YWxseU92ZXIgPSBnZXREcm9wcGFibGVPdmVyKHN0YXRlLmltcGFjdCwgc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzKTtcbiAgdmFyIGlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQgPSBCb29sZWFuKGlzQWN0dWFsbHlPdmVyKTtcbiAgdmFyIGhvbWUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcbiAgdmFyIGlzT3ZlciA9IGlzQWN0dWFsbHlPdmVyIHx8IGhvbWU7XG4gIHZhciBkaXJlY3Rpb24gPSBpc092ZXIuYXhpcy5kaXJlY3Rpb247XG4gIHZhciBpc01vdmluZ09uTWFpbkF4aXMgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgJiYgKHR5cGUgPT09ICdNT1ZFX1VQJyB8fCB0eXBlID09PSAnTU9WRV9ET1dOJykgfHwgZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgKHR5cGUgPT09ICdNT1ZFX0xFRlQnIHx8IHR5cGUgPT09ICdNT1ZFX1JJR0hUJyk7XG5cbiAgaWYgKGlzTW92aW5nT25NYWluQXhpcyAmJiAhaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlzTW92aW5nRm9yd2FyZCA9IHR5cGUgPT09ICdNT1ZFX0RPV04nIHx8IHR5cGUgPT09ICdNT1ZFX1JJR0hUJztcbiAgdmFyIGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICB2YXIgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgdmFyIF9zdGF0ZSRkaW1lbnNpb25zID0gc3RhdGUuZGltZW5zaW9ucyxcbiAgICAgIGRyYWdnYWJsZXMgPSBfc3RhdGUkZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlcyA9IF9zdGF0ZSRkaW1lbnNpb25zLmRyb3BwYWJsZXM7XG4gIHJldHVybiBpc01vdmluZ09uTWFpbkF4aXMgPyBtb3ZlVG9OZXh0UGxhY2Uoe1xuICAgIGlzTW92aW5nRm9yd2FyZDogaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcjogcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uOiBpc092ZXIsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgcHJldmlvdXNDbGllbnRTZWxlY3Rpb246IHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSkgOiBtb3ZlQ3Jvc3NBeGlzKHtcbiAgICBpc01vdmluZ0ZvcndhcmQ6IGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBpc092ZXI6IGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnBoYXNlID09PSAnRFJBR0dJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORyc7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkZyYW1lKGZyYW1lKSB7XG4gIHZhciBpc1dpdGhpblZlcnRpY2FsID0gaXNXaXRoaW4oZnJhbWUudG9wLCBmcmFtZS5ib3R0b20pO1xuICB2YXIgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gZnVuY3Rpb24gcnVuKHBvaW50KSB7XG4gICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwocG9pbnQueSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHBvaW50LngpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNPdmVybGFwKGZpcnN0LCBzZWNvbmQpIHtcbiAgcmV0dXJuIGZpcnN0LmxlZnQgPCBzZWNvbmQucmlnaHQgJiYgZmlyc3QucmlnaHQgPiBzZWNvbmQubGVmdCAmJiBmaXJzdC50b3AgPCBzZWNvbmQuYm90dG9tICYmIGZpcnN0LmJvdHRvbSA+IHNlY29uZC50b3A7XG59XG5cbmZ1bmN0aW9uIGdldEZ1cnRoZXN0QXdheShfcmVmKSB7XG4gIHZhciBwYWdlQm9yZGVyQm94ID0gX3JlZi5wYWdlQm9yZGVyQm94LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBjYW5kaWRhdGVzID0gX3JlZi5jYW5kaWRhdGVzO1xuICB2YXIgc3RhcnRDZW50ZXIgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICB2YXIgc29ydGVkID0gY2FuZGlkYXRlcy5tYXAoZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuICAgIHZhciBheGlzID0gY2FuZGlkYXRlLmF4aXM7XG4gICAgdmFyIHRhcmdldCA9IHBhdGNoKGNhbmRpZGF0ZS5heGlzLmxpbmUsIHBhZ2VCb3JkZXJCb3guY2VudGVyW2F4aXMubGluZV0sIGNhbmRpZGF0ZS5wYWdlLmJvcmRlckJveC5jZW50ZXJbYXhpcy5jcm9zc0F4aXNMaW5lXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBjYW5kaWRhdGUuZGVzY3JpcHRvci5pZCxcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZShzdGFydENlbnRlciwgdGFyZ2V0KVxuICAgIH07XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5kaXN0YW5jZSAtIGEuZGlzdGFuY2U7XG4gIH0pO1xuICByZXR1cm4gc29ydGVkWzBdID8gc29ydGVkWzBdLmlkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RHJvcHBhYmxlT3ZlciQxKF9yZWYyKSB7XG4gIHZhciBwYWdlQm9yZGVyQm94ID0gX3JlZjIucGFnZUJvcmRlckJveCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYyLmRyYWdnYWJsZSxcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmMi5kcm9wcGFibGVzO1xuICB2YXIgY2FuZGlkYXRlcyA9IHRvRHJvcHBhYmxlTGlzdChkcm9wcGFibGVzKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0uaXNFbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFjdGl2ZSA9IGl0ZW0uc3ViamVjdC5hY3RpdmU7XG5cbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZ2V0SGFzT3ZlcmxhcChwYWdlQm9yZGVyQm94LCBhY3RpdmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzUG9zaXRpb25JbkZyYW1lKGFjdGl2ZSkocGFnZUJvcmRlckJveC5jZW50ZXIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYXhpcyA9IGl0ZW0uYXhpcztcbiAgICB2YXIgY2hpbGRDZW50ZXIgPSBhY3RpdmUuY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV07XG4gICAgdmFyIGNyb3NzQXhpc1N0YXJ0ID0gcGFnZUJvcmRlckJveFtheGlzLmNyb3NzQXhpc1N0YXJ0XTtcbiAgICB2YXIgY3Jvc3NBeGlzRW5kID0gcGFnZUJvcmRlckJveFtheGlzLmNyb3NzQXhpc0VuZF07XG4gICAgdmFyIGlzQ29udGFpbmVkID0gaXNXaXRoaW4oYWN0aXZlW2F4aXMuY3Jvc3NBeGlzU3RhcnRdLCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdKTtcbiAgICB2YXIgaXNTdGFydENvbnRhaW5lZCA9IGlzQ29udGFpbmVkKGNyb3NzQXhpc1N0YXJ0KTtcbiAgICB2YXIgaXNFbmRDb250YWluZWQgPSBpc0NvbnRhaW5lZChjcm9zc0F4aXNFbmQpO1xuXG4gICAgaWYgKCFpc1N0YXJ0Q29udGFpbmVkICYmICFpc0VuZENvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RhcnRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiBjcm9zc0F4aXNTdGFydCA8IGNoaWxkQ2VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiBjcm9zc0F4aXNFbmQgPiBjaGlsZENlbnRlcjtcbiAgfSk7XG5cbiAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0uZGVzY3JpcHRvci5pZDtcbiAgfVxuXG4gIHJldHVybiBnZXRGdXJ0aGVzdEF3YXkoe1xuICAgIHBhZ2VCb3JkZXJCb3g6IHBhZ2VCb3JkZXJCb3gsXG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgY2FuZGlkYXRlczogY2FuZGlkYXRlc1xuICB9KTtcbn1cblxudmFyIG9mZnNldFJlY3RCeVBvc2l0aW9uID0gZnVuY3Rpb24gb2Zmc2V0UmVjdEJ5UG9zaXRpb24ocmVjdCwgcG9pbnQpIHtcbiAgcmV0dXJuIGdldFJlY3Qob2Zmc2V0QnlQb3NpdGlvbihyZWN0LCBwb2ludCkpO1xufTtcblxudmFyIHdpdGhEcm9wcGFibGVTY3JvbGwgPSAoZnVuY3Rpb24gKGRyb3BwYWJsZSwgYXJlYSkge1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBhcmVhO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFJlY3RCeVBvc2l0aW9uKGFyZWEsIGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlKTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRJc0Rpc3BsYWNlZChfcmVmKSB7XG4gIHZhciBkaXNwbGFjZWQgPSBfcmVmLmRpc3BsYWNlZCxcbiAgICAgIGlkID0gX3JlZi5pZDtcbiAgcmV0dXJuIEJvb2xlYW4oZGlzcGxhY2VkLnZpc2libGVbaWRdIHx8IGRpc3BsYWNlZC5pbnZpc2libGVbaWRdKTtcbn1cblxuZnVuY3Rpb24gYXRJbmRleChfcmVmKSB7XG4gIHZhciBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGNsb3Nlc3QgPSBfcmVmLmNsb3Nlc3QsXG4gICAgICBpbkhvbWVMaXN0ID0gX3JlZi5pbkhvbWVMaXN0O1xuXG4gIGlmICghY2xvc2VzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbiAgfVxuXG4gIGlmIChjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXggPiBkcmFnZ2FibGUuZGVzY3JpcHRvci5pbmRleCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXggLSAxO1xuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbn1cblxudmFyIGdldFJlb3JkZXJJbXBhY3QgPSAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciB0YXJnZXRSZWN0ID0gX3JlZjIucGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmMi5kcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYyLmRlc3RpbmF0aW9uLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24gPSBfcmVmMi5pbnNpZGVEZXN0aW5hdGlvbixcbiAgICAgIGxhc3QgPSBfcmVmMi5sYXN0LFxuICAgICAgdmlld3BvcnQgPSBfcmVmMi52aWV3cG9ydCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmMi5hZnRlckNyaXRpY2FsO1xuICB2YXIgYXhpcyA9IGRlc3RpbmF0aW9uLmF4aXM7XG4gIHZhciBkaXNwbGFjZWRCeSA9IGdldERpc3BsYWNlZEJ5KGRlc3RpbmF0aW9uLmF4aXMsIGRyYWdnYWJsZS5kaXNwbGFjZUJ5KTtcbiAgdmFyIGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICB2YXIgdGFyZ2V0U3RhcnQgPSB0YXJnZXRSZWN0W2F4aXMuc3RhcnRdO1xuICB2YXIgdGFyZ2V0RW5kID0gdGFyZ2V0UmVjdFtheGlzLmVuZF07XG4gIHZhciB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgdmFyIGNsb3Nlc3QgPSBmaW5kKHdpdGhvdXREcmFnZ2luZywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIGlkID0gY2hpbGQuZGVzY3JpcHRvci5pZDtcbiAgICB2YXIgY2hpbGRDZW50ZXIgPSBjaGlsZC5wYWdlLmJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXTtcbiAgICB2YXIgZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEgPSBkaWRTdGFydEFmdGVyQ3JpdGljYWwoaWQsIGFmdGVyQ3JpdGljYWwpO1xuICAgIHZhciBpc0Rpc3BsYWNlZCA9IGdldElzRGlzcGxhY2VkKHtcbiAgICAgIGRpc3BsYWNlZDogbGFzdCxcbiAgICAgIGlkOiBpZFxuICAgIH0pO1xuXG4gICAgaWYgKGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxKSB7XG4gICAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEVuZCA8PSBjaGlsZENlbnRlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0IDwgY2hpbGRDZW50ZXIgLSBkaXNwbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyICsgZGlzcGxhY2VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRTdGFydCA8IGNoaWxkQ2VudGVyO1xuICB9KTtcbiAgdmFyIG5ld0luZGV4ID0gYXRJbmRleCh7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgY2xvc2VzdDogY2xvc2VzdCxcbiAgICBpbkhvbWVMaXN0OiBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKVxuICB9KTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uOiBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGxhc3Q6IGxhc3QsXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGluZGV4OiBuZXdJbmRleFxuICB9KTtcbn0pO1xuXG52YXIgY29tYmluZVRocmVzaG9sZERpdmlzb3IgPSA0O1xudmFyIGdldENvbWJpbmVJbXBhY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgdGFyZ2V0UmVjdCA9IF9yZWYucGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwsXG4gICAgICBwcmV2aW91c0ltcGFjdCA9IF9yZWYucHJldmlvdXNJbXBhY3QsXG4gICAgICBkZXN0aW5hdGlvbiA9IF9yZWYuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvbiA9IF9yZWYuaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuXG4gIGlmICghZGVzdGluYXRpb24uaXNDb21iaW5lRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGF4aXMgPSBkZXN0aW5hdGlvbi5heGlzO1xuICB2YXIgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIHZhciBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZWRCeS52YWx1ZTtcbiAgdmFyIHRhcmdldFN0YXJ0ID0gdGFyZ2V0UmVjdFtheGlzLnN0YXJ0XTtcbiAgdmFyIHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICB2YXIgd2l0aG91dERyYWdnaW5nID0gcmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QoZHJhZ2dhYmxlLCBpbnNpZGVEZXN0aW5hdGlvbik7XG4gIHZhciBjb21iaW5lV2l0aCA9IGZpbmQod2l0aG91dERyYWdnaW5nLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZC5wYWdlLmJvcmRlckJveDtcbiAgICB2YXIgY2hpbGRTaXplID0gY2hpbGRSZWN0W2F4aXMuc2l6ZV07XG4gICAgdmFyIHRocmVzaG9sZCA9IGNoaWxkU2l6ZSAvIGNvbWJpbmVUaHJlc2hvbGREaXZpc29yO1xuICAgIHZhciBkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChpZCwgYWZ0ZXJDcml0aWNhbCk7XG4gICAgdmFyIGlzRGlzcGxhY2VkID0gZ2V0SXNEaXNwbGFjZWQoe1xuICAgICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgICBpZDogaWRcbiAgICB9KTtcblxuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSkge1xuICAgICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdIC0gZGlzcGxhY2VtZW50ICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSArIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gdGhyZXNob2xkO1xuICB9KTtcblxuICBpZiAoIWNvbWJpbmVXaXRoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaW1wYWN0ID0ge1xuICAgIGRpc3BsYWNlZEJ5OiBkaXNwbGFjZWRCeSxcbiAgICBkaXNwbGFjZWQ6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZCxcbiAgICBhdDoge1xuICAgICAgdHlwZTogJ0NPTUJJTkUnLFxuICAgICAgY29tYmluZToge1xuICAgICAgICBkcmFnZ2FibGVJZDogY29tYmluZVdpdGguZGVzY3JpcHRvci5pZCxcbiAgICAgICAgZHJvcHBhYmxlSWQ6IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBpbXBhY3Q7XG59KTtcblxudmFyIGdldERyYWdJbXBhY3QgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHBhZ2VPZmZzZXQgPSBfcmVmLnBhZ2VPZmZzZXQsXG4gICAgICBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzID0gX3JlZi5kcm9wcGFibGVzLFxuICAgICAgcHJldmlvdXNJbXBhY3QgPSBfcmVmLnByZXZpb3VzSW1wYWN0LFxuICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9yZWYuYWZ0ZXJDcml0aWNhbDtcbiAgdmFyIHBhZ2VCb3JkZXJCb3ggPSBvZmZzZXRSZWN0QnlQb3NpdGlvbihkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3gsIHBhZ2VPZmZzZXQpO1xuICB2YXIgZGVzdGluYXRpb25JZCA9IGdldERyb3BwYWJsZU92ZXIkMSh7XG4gICAgcGFnZUJvcmRlckJveDogcGFnZUJvcmRlckJveCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGVzOiBkcm9wcGFibGVzXG4gIH0pO1xuXG4gIGlmICghZGVzdGluYXRpb25JZCkge1xuICAgIHJldHVybiBub0ltcGFjdDtcbiAgfVxuXG4gIHZhciBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZXNbZGVzdGluYXRpb25JZF07XG4gIHZhciBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIHZhciBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCA9IHdpdGhEcm9wcGFibGVTY3JvbGwoZGVzdGluYXRpb24sIHBhZ2VCb3JkZXJCb3gpO1xuICByZXR1cm4gZ2V0Q29tYmluZUltcGFjdCh7XG4gICAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGw6IHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIHByZXZpb3VzSW1wYWN0OiBwcmV2aW91c0ltcGFjdCxcbiAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG4gICAgaW5zaWRlRGVzdGluYXRpb246IGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSkgfHwgZ2V0UmVvcmRlckltcGFjdCh7XG4gICAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGw6IHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbjogaW5zaWRlRGVzdGluYXRpb24sXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH0pO1xufSk7XG5cbnZhciBwYXRjaERyb3BwYWJsZU1hcCA9IChmdW5jdGlvbiAoZHJvcHBhYmxlcywgdXBkYXRlZCkge1xuICB2YXIgX2V4dGVuZHMyO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZHJvcHBhYmxlcywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbdXBkYXRlZC5kZXNjcmlwdG9yLmlkXSA9IHVwZGF0ZWQsIF9leHRlbmRzMikpO1xufSk7XG5cbnZhciBjbGVhclVudXNlZFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gY2xlYXJVbnVzZWRQbGFjZWhvbGRlcihfcmVmKSB7XG4gIHZhciBwcmV2aW91c0ltcGFjdCA9IF9yZWYucHJldmlvdXNJbXBhY3QsXG4gICAgICBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmLmRyb3BwYWJsZXM7XG4gIHZhciBsYXN0ID0gd2hhdElzRHJhZ2dlZE92ZXIocHJldmlvdXNJbXBhY3QpO1xuICB2YXIgbm93ID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcblxuICBpZiAoIWxhc3QpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuXG4gIGlmIChsYXN0ID09PSBub3cpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuXG4gIHZhciBsYXN0RHJvcHBhYmxlID0gZHJvcHBhYmxlc1tsYXN0XTtcblxuICBpZiAoIWxhc3REcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuXG4gIHZhciB1cGRhdGVkID0gcmVtb3ZlUGxhY2Vob2xkZXIobGFzdERyb3BwYWJsZSk7XG4gIHJldHVybiBwYXRjaERyb3BwYWJsZU1hcChkcm9wcGFibGVzLCB1cGRhdGVkKTtcbn07XG5cbnZhciByZWNvbXB1dGVQbGFjZWhvbGRlcnMgPSAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciBkcmFnZ2FibGUgPSBfcmVmMi5kcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZjIuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmMi5kcm9wcGFibGVzLFxuICAgICAgcHJldmlvdXNJbXBhY3QgPSBfcmVmMi5wcmV2aW91c0ltcGFjdCxcbiAgICAgIGltcGFjdCA9IF9yZWYyLmltcGFjdDtcbiAgdmFyIGNsZWFuZWQgPSBjbGVhclVudXNlZFBsYWNlaG9sZGVyKHtcbiAgICBwcmV2aW91c0ltcGFjdDogcHJldmlvdXNJbXBhY3QsXG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgZHJvcHBhYmxlczogZHJvcHBhYmxlc1xuICB9KTtcbiAgdmFyIGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG5cbiAgaWYgKCFpc092ZXIpIHtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuXG4gIHZhciBkcm9wcGFibGUgPSBkcm9wcGFibGVzW2lzT3Zlcl07XG5cbiAgaWYgKGlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSkge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG5cbiAgaWYgKGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG5cbiAgdmFyIHBhdGNoZWQgPSBhZGRQbGFjZWhvbGRlcihkcm9wcGFibGUsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcyk7XG4gIHJldHVybiBwYXRjaERyb3BwYWJsZU1hcChjbGVhbmVkLCBwYXRjaGVkKTtcbn0pO1xuXG52YXIgdXBkYXRlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBmb3JjZWRDbGllbnRTZWxlY3Rpb24gPSBfcmVmLmNsaWVudFNlbGVjdGlvbixcbiAgICAgIGZvcmNlZERpbWVuc2lvbnMgPSBfcmVmLmRpbWVuc2lvbnMsXG4gICAgICBmb3JjZWRWaWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBmb3JjZWRJbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0ID0gX3JlZi5zY3JvbGxKdW1wUmVxdWVzdDtcbiAgdmFyIHZpZXdwb3J0ID0gZm9yY2VkVmlld3BvcnQgfHwgc3RhdGUudmlld3BvcnQ7XG4gIHZhciBkaW1lbnNpb25zID0gZm9yY2VkRGltZW5zaW9ucyB8fCBzdGF0ZS5kaW1lbnNpb25zO1xuICB2YXIgY2xpZW50U2VsZWN0aW9uID0gZm9yY2VkQ2xpZW50U2VsZWN0aW9uIHx8IHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbjtcbiAgdmFyIG9mZnNldCA9IHN1YnRyYWN0KGNsaWVudFNlbGVjdGlvbiwgc3RhdGUuaW5pdGlhbC5jbGllbnQuc2VsZWN0aW9uKTtcbiAgdmFyIGNsaWVudCA9IHtcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBzZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChzdGF0ZS5pbml0aWFsLmNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIG9mZnNldClcbiAgfTtcbiAgdmFyIHBhZ2UgPSB7XG4gICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50KSxcbiAgICBvZmZzZXQ6IGFkZChjbGllbnQub2Zmc2V0LCB2aWV3cG9ydC5zY3JvbGwuZGlmZi52YWx1ZSlcbiAgfTtcbiAgdmFyIGN1cnJlbnQgPSB7XG4gICAgY2xpZW50OiBjbGllbnQsXG4gICAgcGFnZTogcGFnZVxuICB9O1xuXG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHBoYXNlOiAnQ09MTEVDVElORydcbiAgICB9LCBzdGF0ZSwge1xuICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIGN1cnJlbnQ6IGN1cnJlbnRcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgdmFyIG5ld0ltcGFjdCA9IGZvcmNlZEltcGFjdCB8fCBnZXREcmFnSW1wYWN0KHtcbiAgICBwYWdlT2Zmc2V0OiBwYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzLFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHZhciB3aXRoVXBkYXRlZFBsYWNlaG9sZGVycyA9IHJlY29tcHV0ZVBsYWNlaG9sZGVycyh7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgaW1wYWN0OiBuZXdJbXBhY3QsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzXG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZXM6IHdpdGhVcGRhdGVkUGxhY2Vob2xkZXJzXG4gICAgfSxcbiAgICBpbXBhY3Q6IG5ld0ltcGFjdCxcbiAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IHNjcm9sbEp1bXBSZXF1ZXN0IHx8IG51bGwsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBzY3JvbGxKdW1wUmVxdWVzdCA/IGZhbHNlIDogbnVsbFxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZXMkMShpZHMsIGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGRyYWdnYWJsZXNbaWRdO1xuICB9KTtcbn1cblxudmFyIHJlY29tcHV0ZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgaW1wYWN0ID0gX3JlZi5pbXBhY3QsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgZGVzdGluYXRpb24gPSBfcmVmLmRlc3RpbmF0aW9uLFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlID0gX3JlZi5mb3JjZVNob3VsZEFuaW1hdGU7XG4gIHZhciBsYXN0ID0gaW1wYWN0LmRpc3BsYWNlZDtcbiAgdmFyIGFmdGVyRHJhZ2dpbmcgPSBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpO1xuICB2YXIgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICBsYXN0OiBsYXN0XG4gIH0pO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGltcGFjdCwge1xuICAgIGRpc3BsYWNlZDogZGlzcGxhY2VkXG4gIH0pO1xufSk7XG5cbnZhciBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGltcGFjdCA9IF9yZWYuaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBkcm9wcGFibGUgPSBfcmVmLmRyb3BwYWJsZSxcbiAgICAgIGRyYWdnYWJsZXMgPSBfcmVmLmRyYWdnYWJsZXMsXG4gICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICBhZnRlckNyaXRpY2FsID0gX3JlZi5hZnRlckNyaXRpY2FsO1xuICB2YXIgcGFnZUJvcmRlckJveENlbnRlciA9IGdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0KHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZTogZHJvcHBhYmxlLFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlcih7XG4gICAgcGFnZUJvcmRlckJveENlbnRlcjogcGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgfSk7XG59KTtcblxudmFyIHJlZnJlc2hTbmFwID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBmb3JjZWREaW1lbnNpb25zID0gX3JlZi5kaW1lbnNpb25zLFxuICAgICAgZm9yY2VkVmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0O1xuICAhKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgbmVlZHNWaXNpYmlsaXR5Q2hlY2sgPSBzdGF0ZS5pbXBhY3Q7XG4gIHZhciB2aWV3cG9ydCA9IGZvcmNlZFZpZXdwb3J0IHx8IHN0YXRlLnZpZXdwb3J0O1xuICB2YXIgZGltZW5zaW9ucyA9IGZvcmNlZERpbWVuc2lvbnMgfHwgc3RhdGUuZGltZW5zaW9ucztcbiAgdmFyIGRyYWdnYWJsZXMgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzID0gZGltZW5zaW9ucy5kcm9wcGFibGVzO1xuICB2YXIgZHJhZ2dhYmxlID0gZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICB2YXIgaXNPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIobmVlZHNWaXNpYmlsaXR5Q2hlY2spO1xuICAhaXNPdmVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBvdmVyIGEgZGVzdGluYXRpb24gaW4gU05BUCBtb3ZlbWVudCBtb2RlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgZGVzdGluYXRpb24gPSBkcm9wcGFibGVzW2lzT3Zlcl07XG4gIHZhciBpbXBhY3QgPSByZWNvbXB1dGUoe1xuICAgIGltcGFjdDogbmVlZHNWaXNpYmlsaXR5Q2hlY2ssXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzXG4gIH0pO1xuICB2YXIgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyKHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIHJldHVybiB1cGRhdGUoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGNsaWVudFNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydFxuICB9KTtcbn0pO1xuXG52YXIgZ2V0SG9tZUxvY2F0aW9uID0gKGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgfTtcbn0pO1xuXG52YXIgZ2V0TGlmdEVmZmVjdCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZHJhZ2dhYmxlID0gX3JlZi5kcmFnZ2FibGUsXG4gICAgICBob21lID0gX3JlZi5ob21lLFxuICAgICAgZHJhZ2dhYmxlcyA9IF9yZWYuZHJhZ2dhYmxlcyxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydDtcbiAgdmFyIGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoaG9tZS5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIHZhciBpbnNpZGVIb21lID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShob21lLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICB2YXIgcmF3SW5kZXggPSBpbnNpZGVIb21lLmluZGV4T2YoZHJhZ2dhYmxlKTtcbiAgIShyYXdJbmRleCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZHJhZ2dhYmxlIHRvIGJlIGluc2lkZSBob21lIGxpc3QnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBhZnRlckRyYWdnaW5nID0gaW5zaWRlSG9tZS5zbGljZShyYXdJbmRleCArIDEpO1xuICB2YXIgZWZmZWN0ZWQgPSBhZnRlckRyYWdnaW5nLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGl0ZW0pIHtcbiAgICBwcmV2aW91c1tpdGVtLmRlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sIHt9KTtcbiAgdmFyIGFmdGVyQ3JpdGljYWwgPSB7XG4gICAgaW5WaXJ0dWFsTGlzdDogaG9tZS5kZXNjcmlwdG9yLm1vZGUgPT09ICd2aXJ0dWFsJyxcbiAgICBkaXNwbGFjZWRCeTogZGlzcGxhY2VkQnksXG4gICAgZWZmZWN0ZWQ6IGVmZmVjdGVkXG4gIH07XG4gIHZhciBkaXNwbGFjZWQgPSBnZXREaXNwbGFjZW1lbnRHcm91cHMoe1xuICAgIGFmdGVyRHJhZ2dpbmc6IGFmdGVyRHJhZ2dpbmcsXG4gICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IG51bGwsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIHZhciBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkOiBkaXNwbGFjZWQsXG4gICAgZGlzcGxhY2VkQnk6IGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjogZ2V0SG9tZUxvY2F0aW9uKGRyYWdnYWJsZS5kZXNjcmlwdG9yKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpbXBhY3Q6IGltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsXG4gIH07XG59KTtcblxudmFyIHBhdGNoRGltZW5zaW9uTWFwID0gKGZ1bmN0aW9uIChkaW1lbnNpb25zLCB1cGRhdGVkKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IHBhdGNoRHJvcHBhYmxlTWFwKGRpbWVuc2lvbnMuZHJvcHBhYmxlcywgdXBkYXRlZClcbiAgfTtcbn0pO1xuXG52YXIgc3RhcnQgPSBmdW5jdGlvbiBzdGFydChrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xudmFyIGZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaChrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG52YXIgb2Zmc2V0RHJhZ2dhYmxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcmFnZ2FibGUgPSBfcmVmLmRyYWdnYWJsZSxcbiAgICAgIG9mZnNldCQxID0gX3JlZi5vZmZzZXQsXG4gICAgICBpbml0aWFsV2luZG93U2Nyb2xsID0gX3JlZi5pbml0aWFsV2luZG93U2Nyb2xsO1xuICB2YXIgY2xpZW50ID0gb2Zmc2V0KGRyYWdnYWJsZS5jbGllbnQsIG9mZnNldCQxKTtcbiAgdmFyIHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgaW5pdGlhbFdpbmRvd1Njcm9sbCk7XG5cbiAgdmFyIG1vdmVkID0gX2V4dGVuZHMoe30sIGRyYWdnYWJsZSwge1xuICAgIHBsYWNlaG9sZGVyOiBfZXh0ZW5kcyh7fSwgZHJhZ2dhYmxlLnBsYWNlaG9sZGVyLCB7XG4gICAgICBjbGllbnQ6IGNsaWVudFxuICAgIH0pLFxuICAgIGNsaWVudDogY2xpZW50LFxuICAgIHBhZ2U6IHBhZ2VcbiAgfSk7XG5cbiAgcmV0dXJuIG1vdmVkO1xufSk7XG5cbnZhciBnZXRGcmFtZSA9IChmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgIWZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgRHJvcHBhYmxlIHRvIGhhdmUgYSBmcmFtZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZyYW1lO1xufSk7XG5cbnZhciBhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBhZGRpdGlvbnMgPSBfcmVmLmFkZGl0aW9ucyxcbiAgICAgIHVwZGF0ZWREcm9wcGFibGVzID0gX3JlZi51cGRhdGVkRHJvcHBhYmxlcyxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydDtcbiAgdmFyIHdpbmRvd1Njcm9sbENoYW5nZSA9IHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlO1xuICByZXR1cm4gYWRkaXRpb25zLm1hcChmdW5jdGlvbiAoZHJhZ2dhYmxlKSB7XG4gICAgdmFyIGRyb3BwYWJsZUlkID0gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQ7XG4gICAgdmFyIG1vZGlmaWVkID0gdXBkYXRlZERyb3BwYWJsZXNbZHJvcHBhYmxlSWRdO1xuICAgIHZhciBmcmFtZSA9IGdldEZyYW1lKG1vZGlmaWVkKTtcbiAgICB2YXIgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlID0gZnJhbWUuc2Nyb2xsLmRpZmYudmFsdWU7XG4gICAgdmFyIHRvdGFsQ2hhbmdlID0gYWRkKHdpbmRvd1Njcm9sbENoYW5nZSwgZHJvcHBhYmxlU2Nyb2xsQ2hhbmdlKTtcbiAgICB2YXIgbW92ZWQgPSBvZmZzZXREcmFnZ2FibGUoe1xuICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICBvZmZzZXQ6IHRvdGFsQ2hhbmdlLFxuICAgICAgaW5pdGlhbFdpbmRvd1Njcm9sbDogdmlld3BvcnQuc2Nyb2xsLmluaXRpYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbW92ZWQ7XG4gIH0pO1xufSk7XG5cbnZhciBwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgcHVibGlzaGVkID0gX3JlZi5wdWJsaXNoZWQ7XG4gIHN0YXJ0KCk7XG4gIHZhciB3aXRoU2Nyb2xsQ2hhbmdlID0gcHVibGlzaGVkLm1vZGlmaWVkLm1hcChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgdmFyIGV4aXN0aW5nID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3VwZGF0ZS5kcm9wcGFibGVJZF07XG4gICAgdmFyIHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKGV4aXN0aW5nLCB1cGRhdGUuc2Nyb2xsKTtcbiAgICByZXR1cm4gc2Nyb2xsZWQ7XG4gIH0pO1xuXG4gIHZhciBkcm9wcGFibGVzID0gX2V4dGVuZHMoe30sIHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcywge30sIHRvRHJvcHBhYmxlTWFwKHdpdGhTY3JvbGxDaGFuZ2UpKTtcblxuICB2YXIgdXBkYXRlZEFkZGl0aW9ucyA9IHRvRHJhZ2dhYmxlTWFwKGFkanVzdEFkZGl0aW9uc0ZvclNjcm9sbENoYW5nZXMoe1xuICAgIGFkZGl0aW9uczogcHVibGlzaGVkLmFkZGl0aW9ucyxcbiAgICB1cGRhdGVkRHJvcHBhYmxlczogZHJvcHBhYmxlcyxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnRcbiAgfSkpO1xuXG4gIHZhciBkcmFnZ2FibGVzID0gX2V4dGVuZHMoe30sIHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlcywge30sIHVwZGF0ZWRBZGRpdGlvbnMpO1xuXG4gIHB1Ymxpc2hlZC5yZW1vdmFscy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIGRlbGV0ZSBkcmFnZ2FibGVzW2lkXTtcbiAgfSk7XG4gIHZhciBkaW1lbnNpb25zID0ge1xuICAgIGRyb3BwYWJsZXM6IGRyb3BwYWJsZXMsXG4gICAgZHJhZ2dhYmxlczogZHJhZ2dhYmxlc1xuICB9O1xuICB2YXIgd2FzT3ZlcklkID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgdmFyIHdhc092ZXIgPSB3YXNPdmVySWQgPyBkaW1lbnNpb25zLmRyb3BwYWJsZXNbd2FzT3ZlcklkXSA6IG51bGw7XG4gIHZhciBkcmFnZ2FibGUgPSBkaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgdmFyIGhvbWUgPSBkaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcblxuICB2YXIgX2dldExpZnRFZmZlY3QgPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICBob21lOiBob21lLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0XG4gIH0pLFxuICAgICAgb25MaWZ0SW1wYWN0ID0gX2dldExpZnRFZmZlY3QuaW1wYWN0LFxuICAgICAgYWZ0ZXJDcml0aWNhbCA9IF9nZXRMaWZ0RWZmZWN0LmFmdGVyQ3JpdGljYWw7XG5cbiAgdmFyIHByZXZpb3VzSW1wYWN0ID0gd2FzT3ZlciAmJiB3YXNPdmVyLmlzQ29tYmluZUVuYWJsZWQgPyBzdGF0ZS5pbXBhY3QgOiBvbkxpZnRJbXBhY3Q7XG4gIHZhciBpbXBhY3QgPSBnZXREcmFnSW1wYWN0KHtcbiAgICBwYWdlT2Zmc2V0OiBzdGF0ZS5jdXJyZW50LnBhZ2Uub2Zmc2V0LFxuICAgIGRyYWdnYWJsZTogZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF0sXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICBwcmV2aW91c0ltcGFjdDogcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGZpbmlzaCgpO1xuXG4gIHZhciBkcmFnZ2luZ1N0YXRlID0gX2V4dGVuZHMoe1xuICAgIHBoYXNlOiAnRFJBR0dJTkcnXG4gIH0sIHN0YXRlLCB7XG4gICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgb25MaWZ0SW1wYWN0OiBvbkxpZnRJbXBhY3QsXG4gICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG5cbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmdTdGF0ZTtcbiAgfVxuXG4gIHZhciBkcm9wUGVuZGluZyA9IF9leHRlbmRzKHtcbiAgICBwaGFzZTogJ0RST1BfUEVORElORydcbiAgfSwgZHJhZ2dpbmdTdGF0ZSwge1xuICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICByZWFzb246IHN0YXRlLnJlYXNvbixcbiAgICBpc1dhaXRpbmc6IGZhbHNlXG4gIH0pO1xuXG4gIHJldHVybiBkcm9wUGVuZGluZztcbn0pO1xuXG52YXIgaXNTbmFwcGluZyA9IGZ1bmN0aW9uIGlzU25hcHBpbmcoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnO1xufTtcblxudmFyIHBvc3REcm9wcGFibGVDaGFuZ2UgPSBmdW5jdGlvbiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCB1cGRhdGVkLCBpc0VuYWJsZWRDaGFuZ2luZykge1xuICB2YXIgZGltZW5zaW9ucyA9IHBhdGNoRGltZW5zaW9uTWFwKHN0YXRlLmRpbWVuc2lvbnMsIHVwZGF0ZWQpO1xuXG4gIGlmICghaXNTbmFwcGluZyhzdGF0ZSkgfHwgaXNFbmFibGVkQ2hhbmdpbmcpIHtcbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZWZyZXNoU25hcCh7XG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnNcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiByZW1vdmVTY3JvbGxKdW1wUmVxdWVzdChzdGF0ZSkge1xuICBpZiAoc3RhdGUuaXNEcmFnZ2luZyAmJiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBwaGFzZTogJ0RSQUdHSU5HJ1xuICAgIH0sIHN0YXRlLCB7XG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG52YXIgaWRsZSA9IHtcbiAgcGhhc2U6ICdJRExFJyxcbiAgY29tcGxldGVkOiBudWxsLFxuICBzaG91bGRGbHVzaDogZmFsc2Vcbn07XG52YXIgcmVkdWNlciA9IChmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgIHN0YXRlID0gaWRsZTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaWRsZSwge1xuICAgICAgc2hvdWxkRmx1c2g6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0lOSVRJQUxfUFVCTElTSCcpIHtcbiAgICAhKHN0YXRlLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSU5JVElBTF9QVUJMSVNIIG11c3QgY29tZSBhZnRlciBhIElETEUgcGhhc2UnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9hY3Rpb24kcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICBjcml0aWNhbCA9IF9hY3Rpb24kcGF5bG9hZC5jcml0aWNhbCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uID0gX2FjdGlvbiRwYXlsb2FkLmNsaWVudFNlbGVjdGlvbixcbiAgICAgICAgdmlld3BvcnQgPSBfYWN0aW9uJHBheWxvYWQudmlld3BvcnQsXG4gICAgICAgIGRpbWVuc2lvbnMgPSBfYWN0aW9uJHBheWxvYWQuZGltZW5zaW9ucyxcbiAgICAgICAgbW92ZW1lbnRNb2RlID0gX2FjdGlvbiRwYXlsb2FkLm1vdmVtZW50TW9kZTtcbiAgICB2YXIgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW2NyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gICAgdmFyIGhvbWUgPSBkaW1lbnNpb25zLmRyb3BwYWJsZXNbY3JpdGljYWwuZHJvcHBhYmxlLmlkXTtcbiAgICB2YXIgY2xpZW50ID0ge1xuICAgICAgc2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICBib3JkZXJCb3hDZW50ZXI6IGRyYWdnYWJsZS5jbGllbnQuYm9yZGVyQm94LmNlbnRlcixcbiAgICAgIG9mZnNldDogb3JpZ2luXG4gICAgfTtcbiAgICB2YXIgaW5pdGlhbCA9IHtcbiAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgcGFnZToge1xuICAgICAgICBzZWxlY3Rpb246IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIGJvcmRlckJveENlbnRlcjogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsKSxcbiAgICAgICAgb2Zmc2V0OiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWUpXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaXNXaW5kb3dTY3JvbGxBbGxvd2VkID0gdG9Ecm9wcGFibGVMaXN0KGRpbWVuc2lvbnMuZHJvcHBhYmxlcykuZXZlcnkoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAhaXRlbS5pc0ZpeGVkT25QYWdlO1xuICAgIH0pO1xuXG4gICAgdmFyIF9nZXRMaWZ0RWZmZWN0ID0gZ2V0TGlmdEVmZmVjdCh7XG4gICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIGhvbWU6IGhvbWUsXG4gICAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgICB9KSxcbiAgICAgICAgaW1wYWN0ID0gX2dldExpZnRFZmZlY3QuaW1wYWN0LFxuICAgICAgICBhZnRlckNyaXRpY2FsID0gX2dldExpZnRFZmZlY3QuYWZ0ZXJDcml0aWNhbDtcblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBwaGFzZTogJ0RSQUdHSU5HJyxcbiAgICAgIGlzRHJhZ2dpbmc6IHRydWUsXG4gICAgICBjcml0aWNhbDogY3JpdGljYWwsXG4gICAgICBtb3ZlbWVudE1vZGU6IG1vdmVtZW50TW9kZSxcbiAgICAgIGRpbWVuc2lvbnM6IGRpbWVuc2lvbnMsXG4gICAgICBpbml0aWFsOiBpbml0aWFsLFxuICAgICAgY3VycmVudDogaW5pdGlhbCxcbiAgICAgIGlzV2luZG93U2Nyb2xsQWxsb3dlZDogaXNXaW5kb3dTY3JvbGxBbGxvd2VkLFxuICAgICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsOiBhZnRlckNyaXRpY2FsLFxuICAgICAgb25MaWZ0SW1wYWN0OiBpbXBhY3QsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogbnVsbCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogbnVsbFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0NPTExFQ1RJT05fU1RBUlRJTkcnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgZnJvbSBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgX3Jlc3VsdCA9IF9leHRlbmRzKHtcbiAgICAgIHBoYXNlOiAnQ09MTEVDVElORydcbiAgICB9LCBzdGF0ZSwge1xuICAgICAgcGhhc2U6ICdDT0xMRUNUSU5HJ1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9yZXN1bHQ7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdQVUJMSVNIX1dISUxFX0RSQUdHSU5HJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIlVuZXhwZWN0ZWQgXCIgKyBhY3Rpb24udHlwZSArIFwiIHJlY2VpdmVkIGluIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgcHVibGlzaGVkOiBhY3Rpb24ucGF5bG9hZFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRScpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYWN0aW9uLnR5cGUgKyBcIiBub3QgcGVybWl0dGVkIGluIHBoYXNlIFwiICsgc3RhdGUucGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgX2NsaWVudFNlbGVjdGlvbiA9IGFjdGlvbi5wYXlsb2FkLmNsaWVudDtcblxuICAgIGlmIChpc0VxdWFsKF9jbGllbnRTZWxlY3Rpb24sIHN0YXRlLmN1cnJlbnQuY2xpZW50LnNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGNsaWVudFNlbGVjdGlvbjogX2NsaWVudFNlbGVjdGlvbixcbiAgICAgIGltcGFjdDogaXNTbmFwcGluZyhzdGF0ZSkgPyBzdGF0ZS5pbXBhY3QgOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGFjdGlvbi50eXBlICsgXCIgbm90IHBlcm1pdHRlZCBpbiBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9hY3Rpb24kcGF5bG9hZDIgPSBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgaWQgPSBfYWN0aW9uJHBheWxvYWQyLmlkLFxuICAgICAgICBuZXdTY3JvbGwgPSBfYWN0aW9uJHBheWxvYWQyLm5ld1Njcm9sbDtcbiAgICB2YXIgdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2lkXTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKHRhcmdldCwgbmV3U2Nyb2xsKTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgc2Nyb2xsZWQsIGZhbHNlKTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfSVNfRU5BQkxFRCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJBdHRlbXB0aW5nIHRvIG1vdmUgaW4gYW4gdW5zdXBwb3J0ZWQgcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfYWN0aW9uJHBheWxvYWQzID0gYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIF9pZCA9IF9hY3Rpb24kcGF5bG9hZDMuaWQsXG4gICAgICAgIGlzRW5hYmxlZCA9IF9hY3Rpb24kcGF5bG9hZDMuaXNFbmFibGVkO1xuICAgIHZhciBfdGFyZ2V0ID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW19pZF07XG4gICAgIV90YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IGZpbmQgRHJvcHBhYmxlW2lkOiBcIiArIF9pZCArIFwiXSB0byB0b2dnbGUgaXRzIGVuYWJsZWQgc3RhdGVcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEoX3RhcmdldC5pc0VuYWJsZWQgIT09IGlzRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNFbmFibGVkIHRvIFwiICsgU3RyaW5nKGlzRW5hYmxlZCkgKyBcIlxcbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5IFwiICsgU3RyaW5nKF90YXJnZXQuaXNFbmFibGVkKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIHVwZGF0ZWQgPSBfZXh0ZW5kcyh7fSwgX3RhcmdldCwge1xuICAgICAgaXNFbmFibGVkOiBpc0VuYWJsZWRcbiAgICB9KTtcblxuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCB1cGRhdGVkLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfSVNfQ09NQklORV9FTkFCTEVEJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICAhaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkF0dGVtcHRpbmcgdG8gbW92ZSBpbiBhbiB1bnN1cHBvcnRlZCBwaGFzZSBcIiArIHN0YXRlLnBoYXNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9hY3Rpb24kcGF5bG9hZDQgPSBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgX2lkMiA9IF9hY3Rpb24kcGF5bG9hZDQuaWQsXG4gICAgICAgIGlzQ29tYmluZUVuYWJsZWQgPSBfYWN0aW9uJHBheWxvYWQ0LmlzQ29tYmluZUVuYWJsZWQ7XG4gICAgdmFyIF90YXJnZXQyID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW19pZDJdO1xuICAgICFfdGFyZ2V0MiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6IFwiICsgX2lkMiArIFwiXSB0byB0b2dnbGUgaXRzIGlzQ29tYmluZUVuYWJsZWQgc3RhdGVcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICEoX3RhcmdldDIuaXNDb21iaW5lRW5hYmxlZCAhPT0gaXNDb21iaW5lRW5hYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNDb21iaW5lRW5hYmxlZCB0byBcIiArIFN0cmluZyhpc0NvbWJpbmVFbmFibGVkKSArIFwiXFxuICAgICAgYnV0IGl0IGlzIGFscmVhZHkgXCIgKyBTdHJpbmcoX3RhcmdldDIuaXNDb21iaW5lRW5hYmxlZCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBfdXBkYXRlZCA9IF9leHRlbmRzKHt9LCBfdGFyZ2V0Miwge1xuICAgICAgaXNDb21iaW5lRW5hYmxlZDogaXNDb21iaW5lRW5hYmxlZFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvc3REcm9wcGFibGVDaGFuZ2Uoc3RhdGUsIF91cGRhdGVkLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfQllfV0lORE9XX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgbW92ZSBieSB3aW5kb3cgaW4gcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICFzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdXaW5kb3cgc2Nyb2xsaW5nIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGZvciBmaXhlZCBsaXN0cycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgX25ld1Njcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm5ld1Njcm9sbDtcblxuICAgIGlmIChpc0VxdWFsKHN0YXRlLnZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBfbmV3U2Nyb2xsKSkge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICB2YXIgX3ZpZXdwb3J0ID0gc2Nyb2xsVmlld3BvcnQoc3RhdGUudmlld3BvcnQsIF9uZXdTY3JvbGwpO1xuXG4gICAgaWYgKGlzU25hcHBpbmcoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gcmVmcmVzaFNuYXAoe1xuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIHZpZXdwb3J0OiBfdmlld3BvcnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgdmlld3BvcnQ6IF92aWV3cG9ydFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnVVBEQVRFX1ZJRVdQT1JUX01BWF9TQ1JPTEwnKSB7XG4gICAgaWYgKCFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgbWF4U2Nyb2xsID0gYWN0aW9uLnBheWxvYWQubWF4U2Nyb2xsO1xuXG4gICAgaWYgKGlzRXF1YWwobWF4U2Nyb2xsLCBzdGF0ZS52aWV3cG9ydC5zY3JvbGwubWF4KSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHZhciB3aXRoTWF4U2Nyb2xsID0gX2V4dGVuZHMoe30sIHN0YXRlLnZpZXdwb3J0LCB7XG4gICAgICBzY3JvbGw6IF9leHRlbmRzKHt9LCBzdGF0ZS52aWV3cG9ydC5zY3JvbGwsIHtcbiAgICAgICAgbWF4OiBtYXhTY3JvbGxcbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgcGhhc2U6ICdEUkFHR0lORydcbiAgICB9LCBzdGF0ZSwge1xuICAgICAgdmlld3BvcnQ6IHdpdGhNYXhTY3JvbGxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ01PVkVfVVAnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9ET1dOJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfTEVGVCcgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1JJR0hUJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBhY3Rpb24udHlwZSArIFwiIHJlY2VpdmVkIHdoaWxlIG5vdCBpbiBEUkFHR0lORyBwaGFzZVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgX3Jlc3VsdDIgPSBtb3ZlSW5EaXJlY3Rpb24oe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgdHlwZTogYWN0aW9uLnR5cGVcbiAgICB9KTtcblxuICAgIGlmICghX3Jlc3VsdDIpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGltcGFjdDogX3Jlc3VsdDIuaW1wYWN0LFxuICAgICAgY2xpZW50U2VsZWN0aW9uOiBfcmVzdWx0Mi5jbGllbnRTZWxlY3Rpb24sXG4gICAgICBzY3JvbGxKdW1wUmVxdWVzdDogX3Jlc3VsdDIuc2Nyb2xsSnVtcFJlcXVlc3RcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICB2YXIgcmVhc29uID0gYWN0aW9uLnBheWxvYWQucmVhc29uO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBtb3ZlIGludG8gdGhlIERST1BfUEVORElORyBwaGFzZSBmcm9tIHRoZSBDT0xMRUNUSU5HIHBoYXNlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5ld1N0YXRlID0gX2V4dGVuZHMoe1xuICAgICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnXG4gICAgfSwgc3RhdGUsIHtcbiAgICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICAgIGlzV2FpdGluZzogdHJ1ZSxcbiAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnKSB7XG4gICAgdmFyIF9hY3Rpb24kcGF5bG9hZDUgPSBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgY29tcGxldGVkID0gX2FjdGlvbiRwYXlsb2FkNS5jb21wbGV0ZWQsXG4gICAgICAgIGRyb3BEdXJhdGlvbiA9IF9hY3Rpb24kcGF5bG9hZDUuZHJvcER1cmF0aW9uLFxuICAgICAgICBuZXdIb21lQ2xpZW50T2Zmc2V0ID0gX2FjdGlvbiRwYXlsb2FkNS5uZXdIb21lQ2xpZW50T2Zmc2V0O1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgYW5pbWF0ZSBkcm9wIGZyb20gcGhhc2UgXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfcmVzdWx0MyA9IHtcbiAgICAgIHBoYXNlOiAnRFJPUF9BTklNQVRJTkcnLFxuICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWQsXG4gICAgICBkcm9wRHVyYXRpb246IGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXQ6IG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICBkaW1lbnNpb25zOiBzdGF0ZS5kaW1lbnNpb25zXG4gICAgfTtcbiAgICByZXR1cm4gX3Jlc3VsdDM7XG4gIH1cblxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX0NPTVBMRVRFJykge1xuICAgIHZhciBfY29tcGxldGVkID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkO1xuICAgIHJldHVybiB7XG4gICAgICBwaGFzZTogJ0lETEUnLFxuICAgICAgY29tcGxldGVkOiBfY29tcGxldGVkLFxuICAgICAgc2hvdWxkRmx1c2g6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn0pO1xuXG52YXIgYmVmb3JlSW5pdGlhbENhcHR1cmUgPSBmdW5jdGlvbiBiZWZvcmVJbml0aWFsQ2FwdHVyZShhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgbGlmdCA9IGZ1bmN0aW9uIGxpZnQoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdMSUZUJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIGluaXRpYWxQdWJsaXNoID0gZnVuY3Rpb24gaW5pdGlhbFB1Ymxpc2goYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdJTklUSUFMX1BVQkxJU0gnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgcHVibGlzaFdoaWxlRHJhZ2dpbmcgPSBmdW5jdGlvbiBwdWJsaXNoV2hpbGVEcmFnZ2luZyhhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgY29sbGVjdGlvblN0YXJ0aW5nID0gZnVuY3Rpb24gY29sbGVjdGlvblN0YXJ0aW5nKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdDT0xMRUNUSU9OX1NUQVJUSU5HJyxcbiAgICBwYXlsb2FkOiBudWxsXG4gIH07XG59O1xudmFyIHVwZGF0ZURyb3BwYWJsZVNjcm9sbCA9IGZ1bmN0aW9uIHVwZGF0ZURyb3BwYWJsZVNjcm9sbChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfU0NST0xMJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCA9IGZ1bmN0aW9uIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfSVNfRU5BQkxFRCcsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkID0gZnVuY3Rpb24gdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfSVNfQ09NQklORV9FTkFCTEVEJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIG1vdmUgPSBmdW5jdGlvbiBtb3ZlKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRScsXG4gICAgcGF5bG9hZDogYXJnc1xuICB9O1xufTtcbnZhciBtb3ZlQnlXaW5kb3dTY3JvbGwgPSBmdW5jdGlvbiBtb3ZlQnlXaW5kb3dTY3JvbGwoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0JZX1dJTkRPV19TQ1JPTEwnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwgPSBmdW5jdGlvbiB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1VQREFURV9WSUVXUE9SVF9NQVhfU0NST0xMJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIG1vdmVVcCA9IGZ1bmN0aW9uIG1vdmVVcCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9VUCcsXG4gICAgcGF5bG9hZDogbnVsbFxuICB9O1xufTtcbnZhciBtb3ZlRG93biA9IGZ1bmN0aW9uIG1vdmVEb3duKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0RPV04nLFxuICAgIHBheWxvYWQ6IG51bGxcbiAgfTtcbn07XG52YXIgbW92ZVJpZ2h0ID0gZnVuY3Rpb24gbW92ZVJpZ2h0KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX1JJR0hUJyxcbiAgICBwYXlsb2FkOiBudWxsXG4gIH07XG59O1xudmFyIG1vdmVMZWZ0ID0gZnVuY3Rpb24gbW92ZUxlZnQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ01PVkVfTEVGVCcsXG4gICAgcGF5bG9hZDogbnVsbFxuICB9O1xufTtcbnZhciBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdGTFVTSCcsXG4gICAgcGF5bG9hZDogbnVsbFxuICB9O1xufTtcbnZhciBhbmltYXRlRHJvcCA9IGZ1bmN0aW9uIGFuaW1hdGVEcm9wKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnRFJPUF9BTklNQVRFJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIGNvbXBsZXRlRHJvcCA9IGZ1bmN0aW9uIGNvbXBsZXRlRHJvcChhcmdzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0RST1BfQ09NUExFVEUnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdEUk9QJyxcbiAgICBwYXlsb2FkOiBhcmdzXG4gIH07XG59O1xudmFyIGRyb3BQZW5kaW5nID0gZnVuY3Rpb24gZHJvcFBlbmRpbmcoYXJncykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdEUk9QX1BFTkRJTkcnLFxuICAgIHBheWxvYWQ6IGFyZ3NcbiAgfTtcbn07XG52YXIgZHJvcEFuaW1hdGlvbkZpbmlzaGVkID0gZnVuY3Rpb24gZHJvcEFuaW1hdGlvbkZpbmlzaGVkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcsXG4gICAgcGF5bG9hZDogbnVsbFxuICB9O1xufTtcblxuZnVuY3Rpb24gY2hlY2tJbmRleGVzKGluc2lkZURlc3RpbmF0aW9uKSB7XG4gIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGggPD0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbmRleGVzID0gaW5zaWRlRGVzdGluYXRpb24ubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuZGVzY3JpcHRvci5pbmRleDtcbiAgfSk7XG4gIHZhciBlcnJvcnMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudCA9IGluZGV4ZXNbaV07XG4gICAgdmFyIHByZXZpb3VzID0gaW5kZXhlc1tpIC0gMV07XG5cbiAgICBpZiAoY3VycmVudCAhPT0gcHJldmlvdXMgKyAxKSB7XG4gICAgICBlcnJvcnNbY3VycmVudF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMoZXJyb3JzKS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZm9ybWF0dGVkID0gaW5kZXhlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGhhc0Vycm9yID0gQm9vbGVhbihlcnJvcnNbaW5kZXhdKTtcbiAgICByZXR1cm4gaGFzRXJyb3IgPyBcIltcXHVEODNEXFx1REQyNVwiICsgaW5kZXggKyBcIl1cIiA6IFwiXCIgKyBpbmRleDtcbiAgfSkuam9pbignLCAnKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICBEZXRlY3RlZCBub24tY29uc2VjdXRpdmUgPERyYWdnYWJsZSAvPiBpbmRleGVzLlxcblxcbiAgICAoVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBidWdzKVxcblxcbiAgICBcIiArIGZvcm1hdHRlZCArIFwiXFxuICBcIikgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoY3JpdGljYWwuZHJvcHBhYmxlLmlkLCBkaW1lbnNpb25zLmRyYWdnYWJsZXMpO1xuICAgIGNoZWNrSW5kZXhlcyhpbnNpZGVEZXN0aW5hdGlvbik7XG4gIH1cbn1cblxudmFyIGxpZnQkMSA9IChmdW5jdGlvbiAobWFyc2hhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2g7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgIT09ICdMSUZUJykge1xuICAgICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2FjdGlvbiRwYXlsb2FkID0gYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgICBpZCA9IF9hY3Rpb24kcGF5bG9hZC5pZCxcbiAgICAgICAgICAgIGNsaWVudFNlbGVjdGlvbiA9IF9hY3Rpb24kcGF5bG9hZC5jbGllbnRTZWxlY3Rpb24sXG4gICAgICAgICAgICBtb3ZlbWVudE1vZGUgPSBfYWN0aW9uJHBheWxvYWQubW92ZW1lbnRNb2RlO1xuICAgICAgICB2YXIgaW5pdGlhbCA9IGdldFN0YXRlKCk7XG5cbiAgICAgICAgaWYgKGluaXRpYWwucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgICAgICBkaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgICAgICAgICAgY29tcGxldGVkOiBpbml0aWFsLmNvbXBsZXRlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgICEoZ2V0U3RhdGUoKS5waGFzZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgcGhhc2UgdG8gc3RhcnQgYSBkcmFnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICBkaXNwYXRjaChmbHVzaCgpKTtcbiAgICAgICAgZGlzcGF0Y2goYmVmb3JlSW5pdGlhbENhcHR1cmUoe1xuICAgICAgICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICAgICAgICBtb3ZlbWVudE1vZGU6IG1vdmVtZW50TW9kZVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBzY3JvbGxPcHRpb25zID0ge1xuICAgICAgICAgIHNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseTogbW92ZW1lbnRNb2RlID09PSAnU05BUCdcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgZHJhZ2dhYmxlSWQ6IGlkLFxuICAgICAgICAgIHNjcm9sbE9wdGlvbnM6IHNjcm9sbE9wdGlvbnNcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX21hcnNoYWwkc3RhcnRQdWJsaXNoID0gbWFyc2hhbC5zdGFydFB1Ymxpc2hpbmcocmVxdWVzdCksXG4gICAgICAgICAgICBjcml0aWNhbCA9IF9tYXJzaGFsJHN0YXJ0UHVibGlzaC5jcml0aWNhbCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBfbWFyc2hhbCRzdGFydFB1Ymxpc2guZGltZW5zaW9ucyxcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gX21hcnNoYWwkc3RhcnRQdWJsaXNoLnZpZXdwb3J0O1xuXG4gICAgICAgIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucyk7XG4gICAgICAgIGRpc3BhdGNoKGluaXRpYWxQdWJsaXNoKHtcbiAgICAgICAgICBjcml0aWNhbDogY3JpdGljYWwsXG4gICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICAgICAgICBjbGllbnRTZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICAgICAgICBtb3ZlbWVudE1vZGU6IG1vdmVtZW50TW9kZSxcbiAgICAgICAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBzdHlsZSA9IChmdW5jdGlvbiAobWFyc2hhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICAgICAgIG1hcnNoYWwuZHJhZ2dpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQU5JTUFURScpIHtcbiAgICAgICAgICBtYXJzaGFsLmRyb3BwaW5nKGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQucmVhc29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgICAgICAgbWFyc2hhbC5yZXN0aW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGN1cnZlcyA9IHtcbiAgb3V0T2ZUaGVXYXk6ICdjdWJpYy1iZXppZXIoMC4yLCAwLCAwLCAxKScsXG4gIGRyb3A6ICdjdWJpYy1iZXppZXIoLjIsMSwuMSwxKSdcbn07XG52YXIgY29tYmluZSA9IHtcbiAgb3BhY2l0eToge1xuICAgIGRyb3A6IDAsXG4gICAgY29tYmluaW5nOiAwLjdcbiAgfSxcbiAgc2NhbGU6IHtcbiAgICBkcm9wOiAwLjc1XG4gIH1cbn07XG52YXIgdGltaW5ncyA9IHtcbiAgb3V0T2ZUaGVXYXk6IDAuMixcbiAgbWluRHJvcFRpbWU6IDAuMzMsXG4gIG1heERyb3BUaW1lOiAwLjU1XG59O1xudmFyIG91dE9mVGhlV2F5VGltaW5nID0gdGltaW5ncy5vdXRPZlRoZVdheSArIFwicyBcIiArIGN1cnZlcy5vdXRPZlRoZVdheTtcbnZhciB0cmFuc2l0aW9ucyA9IHtcbiAgZmx1aWQ6IFwib3BhY2l0eSBcIiArIG91dE9mVGhlV2F5VGltaW5nLFxuICBzbmFwOiBcInRyYW5zZm9ybSBcIiArIG91dE9mVGhlV2F5VGltaW5nICsgXCIsIG9wYWNpdHkgXCIgKyBvdXRPZlRoZVdheVRpbWluZyxcbiAgZHJvcDogZnVuY3Rpb24gZHJvcChkdXJhdGlvbikge1xuICAgIHZhciB0aW1pbmcgPSBkdXJhdGlvbiArIFwicyBcIiArIGN1cnZlcy5kcm9wO1xuICAgIHJldHVybiBcInRyYW5zZm9ybSBcIiArIHRpbWluZyArIFwiLCBvcGFjaXR5IFwiICsgdGltaW5nO1xuICB9LFxuICBvdXRPZlRoZVdheTogXCJ0cmFuc2Zvcm0gXCIgKyBvdXRPZlRoZVdheVRpbWluZyxcbiAgcGxhY2Vob2xkZXI6IFwiaGVpZ2h0IFwiICsgb3V0T2ZUaGVXYXlUaW1pbmcgKyBcIiwgd2lkdGggXCIgKyBvdXRPZlRoZVdheVRpbWluZyArIFwiLCBtYXJnaW4gXCIgKyBvdXRPZlRoZVdheVRpbWluZ1xufTtcblxudmFyIG1vdmVUbyA9IGZ1bmN0aW9uIG1vdmVUbyhvZmZzZXQpIHtcbiAgcmV0dXJuIGlzRXF1YWwob2Zmc2V0LCBvcmlnaW4pID8gbnVsbCA6IFwidHJhbnNsYXRlKFwiICsgb2Zmc2V0LnggKyBcInB4LCBcIiArIG9mZnNldC55ICsgXCJweClcIjtcbn07XG5cbnZhciB0cmFuc2Zvcm1zID0ge1xuICBtb3ZlVG86IG1vdmVUbyxcbiAgZHJvcDogZnVuY3Rpb24gZHJvcChvZmZzZXQsIGlzQ29tYmluaW5nKSB7XG4gICAgdmFyIHRyYW5zbGF0ZSA9IG1vdmVUbyhvZmZzZXQpO1xuXG4gICAgaWYgKCF0cmFuc2xhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZSArIFwiIHNjYWxlKFwiICsgY29tYmluZS5zY2FsZS5kcm9wICsgXCIpXCI7XG4gIH1cbn07XG5cbnZhciBtaW5Ecm9wVGltZSA9IHRpbWluZ3MubWluRHJvcFRpbWUsXG4gICAgbWF4RHJvcFRpbWUgPSB0aW1pbmdzLm1heERyb3BUaW1lO1xudmFyIGRyb3BUaW1lUmFuZ2UgPSBtYXhEcm9wVGltZSAtIG1pbkRyb3BUaW1lO1xudmFyIG1heERyb3BUaW1lQXREaXN0YW5jZSA9IDE1MDA7XG52YXIgY2FuY2VsRHJvcE1vZGlmaWVyID0gMC42O1xudmFyIGdldERyb3BEdXJhdGlvbiA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgY3VycmVudCA9IF9yZWYuY3VycmVudCxcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIHJlYXNvbiA9IF9yZWYucmVhc29uO1xuICB2YXIgZGlzdGFuY2UkMSA9IGRpc3RhbmNlKGN1cnJlbnQsIGRlc3RpbmF0aW9uKTtcblxuICBpZiAoZGlzdGFuY2UkMSA8PSAwKSB7XG4gICAgcmV0dXJuIG1pbkRyb3BUaW1lO1xuICB9XG5cbiAgaWYgKGRpc3RhbmNlJDEgPj0gbWF4RHJvcFRpbWVBdERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIG1heERyb3BUaW1lO1xuICB9XG5cbiAgdmFyIHBlcmNlbnRhZ2UgPSBkaXN0YW5jZSQxIC8gbWF4RHJvcFRpbWVBdERpc3RhbmNlO1xuICB2YXIgZHVyYXRpb24gPSBtaW5Ecm9wVGltZSArIGRyb3BUaW1lUmFuZ2UgKiBwZXJjZW50YWdlO1xuICB2YXIgd2l0aER1cmF0aW9uID0gcmVhc29uID09PSAnQ0FOQ0VMJyA/IGR1cmF0aW9uICogY2FuY2VsRHJvcE1vZGlmaWVyIDogZHVyYXRpb247XG4gIHJldHVybiBOdW1iZXIod2l0aER1cmF0aW9uLnRvRml4ZWQoMikpO1xufSk7XG5cbnZhciBnZXROZXdIb21lQ2xpZW50T2Zmc2V0ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBpbXBhY3QgPSBfcmVmLmltcGFjdCxcbiAgICAgIGRyYWdnYWJsZSA9IF9yZWYuZHJhZ2dhYmxlLFxuICAgICAgZGltZW5zaW9ucyA9IF9yZWYuZGltZW5zaW9ucyxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIGFmdGVyQ3JpdGljYWwgPSBfcmVmLmFmdGVyQ3JpdGljYWw7XG4gIHZhciBkcmFnZ2FibGVzID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgICAgZHJvcHBhYmxlcyA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlcztcbiAgdmFyIGRyb3BwYWJsZUlkID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgdmFyIGRlc3RpbmF0aW9uID0gZHJvcHBhYmxlSWQgPyBkcm9wcGFibGVzW2Ryb3BwYWJsZUlkXSA6IG51bGw7XG4gIHZhciBob21lID0gZHJvcHBhYmxlc1tkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZF07XG4gIHZhciBuZXdDbGllbnRDZW50ZXIgPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdDogaW1wYWN0LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIGRyYWdnYWJsZXM6IGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbDogYWZ0ZXJDcml0aWNhbCxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uIHx8IGhvbWUsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH0pO1xuICB2YXIgb2Zmc2V0ID0gc3VidHJhY3QobmV3Q2xpZW50Q2VudGVyLCBkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gb2Zmc2V0O1xufSk7XG5cbnZhciBnZXREcm9wSW1wYWN0ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcmFnZ2FibGVzID0gX3JlZi5kcmFnZ2FibGVzLFxuICAgICAgcmVhc29uID0gX3JlZi5yZWFzb24sXG4gICAgICBsYXN0SW1wYWN0ID0gX3JlZi5sYXN0SW1wYWN0LFxuICAgICAgaG9tZSA9IF9yZWYuaG9tZSxcbiAgICAgIHZpZXdwb3J0ID0gX3JlZi52aWV3cG9ydCxcbiAgICAgIG9uTGlmdEltcGFjdCA9IF9yZWYub25MaWZ0SW1wYWN0O1xuXG4gIGlmICghbGFzdEltcGFjdC5hdCB8fCByZWFzb24gIT09ICdEUk9QJykge1xuICAgIHZhciByZWNvbXB1dGVkSG9tZUltcGFjdCA9IHJlY29tcHV0ZSh7XG4gICAgICBkcmFnZ2FibGVzOiBkcmFnZ2FibGVzLFxuICAgICAgaW1wYWN0OiBvbkxpZnRJbXBhY3QsXG4gICAgICBkZXN0aW5hdGlvbjogaG9tZSxcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IHJlY29tcHV0ZWRIb21lSW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgaWYgKGxhc3RJbXBhY3QuYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGltcGFjdDogbGFzdEltcGFjdCxcbiAgICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdpdGhvdXRNb3ZlbWVudCA9IF9leHRlbmRzKHt9LCBsYXN0SW1wYWN0LCB7XG4gICAgZGlzcGxhY2VkOiBlbXB0eUdyb3Vwc1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGltcGFjdDogd2l0aG91dE1vdmVtZW50LFxuICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGU6IHRydWVcbiAgfTtcbn0pO1xuXG52YXIgZHJvcCQxID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGUsXG4gICAgICBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2g7XG4gIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QJykge1xuICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIHZhciByZWFzb24gPSBhY3Rpb24ucGF5bG9hZC5yZWFzb247XG5cbiAgICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgICAgIGRpc3BhdGNoKGRyb3BQZW5kaW5nKHtcbiAgICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNXYWl0aW5nRm9yRHJvcCA9IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJyAmJiBzdGF0ZS5pc1dhaXRpbmc7XG4gICAgICAhIWlzV2FpdGluZ0ZvckRyb3AgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERST1AgYWN0aW9uIG9jY3VycmVkIHdoaWxlIERST1BfUEVORElORyBhbmQgc3RpbGwgd2FpdGluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgZHJvcCBpbiBwaGFzZTogXCIgKyBzdGF0ZS5waGFzZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIGNyaXRpY2FsID0gc3RhdGUuY3JpdGljYWw7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHN0YXRlLmRpbWVuc2lvbnM7XG4gICAgICB2YXIgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG5cbiAgICAgIHZhciBfZ2V0RHJvcEltcGFjdCA9IGdldERyb3BJbXBhY3Qoe1xuICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgbGFzdEltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgICAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsLFxuICAgICAgICBvbkxpZnRJbXBhY3Q6IHN0YXRlLm9uTGlmdEltcGFjdCxcbiAgICAgICAgaG9tZTogc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF0sXG4gICAgICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgZHJhZ2dhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzXG4gICAgICB9KSxcbiAgICAgICAgICBpbXBhY3QgPSBfZ2V0RHJvcEltcGFjdC5pbXBhY3QsXG4gICAgICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZSA9IF9nZXREcm9wSW1wYWN0LmRpZERyb3BJbnNpZGVEcm9wcGFibGU7XG5cbiAgICAgIHZhciBkZXN0aW5hdGlvbiA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIDogbnVsbDtcbiAgICAgIHZhciBjb21iaW5lID0gZGlkRHJvcEluc2lkZURyb3BwYWJsZSA/IHRyeUdldENvbWJpbmUoaW1wYWN0KSA6IG51bGw7XG4gICAgICB2YXIgc291cmNlID0ge1xuICAgICAgICBpbmRleDogY3JpdGljYWwuZHJhZ2dhYmxlLmluZGV4LFxuICAgICAgICBkcm9wcGFibGVJZDogY3JpdGljYWwuZHJvcHBhYmxlLmlkXG4gICAgICB9O1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLFxuICAgICAgICB0eXBlOiBkcmFnZ2FibGUuZGVzY3JpcHRvci50eXBlLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgIG1vZGU6IHN0YXRlLm1vdmVtZW50TW9kZSxcbiAgICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uLFxuICAgICAgICBjb21iaW5lOiBjb21iaW5lXG4gICAgICB9O1xuICAgICAgdmFyIG5ld0hvbWVDbGllbnRPZmZzZXQgPSBnZXROZXdIb21lQ2xpZW50T2Zmc2V0KHtcbiAgICAgICAgaW1wYWN0OiBpbXBhY3QsXG4gICAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuICAgICAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgICAgIH0pO1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IHtcbiAgICAgICAgY3JpdGljYWw6IHN0YXRlLmNyaXRpY2FsLFxuICAgICAgICBhZnRlckNyaXRpY2FsOiBzdGF0ZS5hZnRlckNyaXRpY2FsLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgaW1wYWN0OiBpbXBhY3RcbiAgICAgIH07XG4gICAgICB2YXIgaXNBbmltYXRpb25SZXF1aXJlZCA9ICFpc0VxdWFsKHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldCwgbmV3SG9tZUNsaWVudE9mZnNldCkgfHwgQm9vbGVhbihyZXN1bHQuY29tYmluZSk7XG5cbiAgICAgIGlmICghaXNBbmltYXRpb25SZXF1aXJlZCkge1xuICAgICAgICBkaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHJvcER1cmF0aW9uID0gZ2V0RHJvcER1cmF0aW9uKHtcbiAgICAgICAgY3VycmVudDogc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LFxuICAgICAgICBkZXN0aW5hdGlvbjogbmV3SG9tZUNsaWVudE9mZnNldCxcbiAgICAgICAgcmVhc29uOiByZWFzb25cbiAgICAgIH0pO1xuICAgICAgdmFyIGFyZ3MgPSB7XG4gICAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXQ6IG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgIGRyb3BEdXJhdGlvbjogZHJvcER1cmF0aW9uLFxuICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZFxuICAgICAgfTtcbiAgICAgIGRpc3BhdGNoKGFuaW1hdGVEcm9wKGFyZ3MpKTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBnZXRXaW5kb3dTY3JvbGwgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCaW5kaW5nKHVwZGF0ZSkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IHdpbmRvdyAmJiBldmVudC50YXJnZXQgIT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsTGlzdGVuZXIoX3JlZikge1xuICB2YXIgb25XaW5kb3dTY3JvbGwgPSBfcmVmLm9uV2luZG93U2Nyb2xsO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICBvbldpbmRvd1Njcm9sbChnZXRXaW5kb3dTY3JvbGwoKSk7XG4gIH1cblxuICB2YXIgc2NoZWR1bGVkID0gcmFmU2NoZCh1cGRhdGVTY3JvbGwpO1xuICB2YXIgYmluZGluZyA9IGdldFdpbmRvd1Njcm9sbEJpbmRpbmcoc2NoZWR1bGVkKTtcbiAgdmFyIHVuYmluZCA9IG5vb3A7XG5cbiAgZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHVuYmluZCAhPT0gbm9vcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICEhaXNBY3RpdmUoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBzY3JvbGwgbGlzdGVuZXIgd2hlbiBhbHJlYWR5IGFjdGl2ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW2JpbmRpbmddKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgIWlzQWN0aXZlKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBzY3JvbGwgbGlzdGVuZXIgd2hlbiBub3QgYWN0aXZlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHNjaGVkdWxlZC5jYW5jZWwoKTtcbiAgICB1bmJpbmQoKTtcbiAgICB1bmJpbmQgPSBub29wO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgc3RvcDogc3RvcCxcbiAgICBpc0FjdGl2ZTogaXNBY3RpdmVcbiAgfTtcbn1cblxudmFyIHNob3VsZEVuZCA9IGZ1bmN0aW9uIHNob3VsZEVuZChhY3Rpb24pIHtcbiAgcmV0dXJuIGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRkxVU0gnO1xufTtcblxudmFyIHNjcm9sbExpc3RlbmVyID0gKGZ1bmN0aW9uIChzdG9yZSkge1xuICB2YXIgbGlzdGVuZXIgPSBnZXRTY3JvbGxMaXN0ZW5lcih7XG4gICAgb25XaW5kb3dTY3JvbGw6IGZ1bmN0aW9uIG9uV2luZG93U2Nyb2xsKG5ld1Njcm9sbCkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2gobW92ZUJ5V2luZG93U2Nyb2xsKHtcbiAgICAgICAgbmV3U2Nyb2xsOiBuZXdTY3JvbGxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgaWYgKCFsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICAgICBsaXN0ZW5lci5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGlzdGVuZXIuaXNBY3RpdmUoKSAmJiBzaG91bGRFbmQoYWN0aW9uKSkge1xuICAgICAgICBsaXN0ZW5lci5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBnZXRFeHBpcmluZ0Fubm91bmNlID0gKGZ1bmN0aW9uIChhbm5vdW5jZSkge1xuICB2YXIgd2FzQ2FsbGVkID0gZmFsc2U7XG4gIHZhciBpc0V4cGlyZWQgPSBmYWxzZTtcbiAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlzRXhwaXJlZCA9IHRydWU7XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbiByZXN1bHQobWVzc2FnZSkge1xuICAgIGlmICh3YXNDYWxsZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ0Fubm91bmNlbWVudCBhbHJlYWR5IG1hZGUuIE5vdCBtYWtpbmcgYSBzZWNvbmQgYW5ub3VuY2VtZW50JykgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzRXhwaXJlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgICAgQW5ub3VuY2VtZW50cyBjYW5ub3QgYmUgbWFkZSBhc3luY2hyb25vdXNseS5cXG4gICAgICAgIERlZmF1bHQgbWVzc2FnZSBoYXMgYWxyZWFkeSBiZWVuIGFubm91bmNlZC5cXG4gICAgICBcIikgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FzQ2FsbGVkID0gdHJ1ZTtcbiAgICBhbm5vdW5jZShtZXNzYWdlKTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfTtcblxuICByZXN1bHQud2FzQ2FsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3YXNDYWxsZWQ7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgZ2V0QXN5bmNNYXJzaGFsID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcblxuICB2YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUodGltZXJJZCkge1xuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleChlbnRyaWVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0udGltZXJJZCA9PT0gdGltZXJJZDtcbiAgICB9KTtcbiAgICAhKGluZGV4ICE9PSAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCB0aW1lcicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciBfZW50cmllcyRzcGxpY2UgPSBlbnRyaWVzLnNwbGljZShpbmRleCwgMSksXG4gICAgICAgIGVudHJ5ID0gX2VudHJpZXMkc3BsaWNlWzBdO1xuXG4gICAgZW50cnkuY2FsbGJhY2soKTtcbiAgfTtcblxuICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGZuKSB7XG4gICAgdmFyIHRpbWVySWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleGVjdXRlKHRpbWVySWQpO1xuICAgIH0pO1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIHRpbWVySWQ6IHRpbWVySWQsXG4gICAgICBjYWxsYmFjazogZm5cbiAgICB9O1xuICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gIH07XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaGFsbG93ID0gW10uY29uY2F0KGVudHJpZXMpO1xuICAgIGVudHJpZXMubGVuZ3RoID0gMDtcbiAgICBzaGFsbG93LmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICBjbGVhclRpbWVvdXQoZW50cnkudGltZXJJZCk7XG4gICAgICBlbnRyeS5jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYWRkOiBhZGQsXG4gICAgZmx1c2g6IGZsdXNoXG4gIH07XG59KTtcblxudmFyIGFyZUxvY2F0aW9uc0VxdWFsID0gZnVuY3Rpb24gYXJlTG9jYXRpb25zRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICBpZiAoZmlyc3QgPT0gbnVsbCAmJiBzZWNvbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZCAmJiBmaXJzdC5pbmRleCA9PT0gc2Vjb25kLmluZGV4O1xufTtcbnZhciBpc0NvbWJpbmVFcXVhbCA9IGZ1bmN0aW9uIGlzQ29tYmluZUVxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09IG51bGwgJiYgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChmaXJzdCA9PSBudWxsIHx8IHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGZpcnN0LmRyYWdnYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlSWQgJiYgZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZDtcbn07XG52YXIgaXNDcml0aWNhbEVxdWFsID0gZnVuY3Rpb24gaXNDcml0aWNhbEVxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpc0RyYWdnYWJsZUVxdWFsID0gZmlyc3QuZHJhZ2dhYmxlLmlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmlkICYmIGZpcnN0LmRyYWdnYWJsZS5kcm9wcGFibGVJZCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5kcm9wcGFibGVJZCAmJiBmaXJzdC5kcmFnZ2FibGUudHlwZSA9PT0gc2Vjb25kLmRyYWdnYWJsZS50eXBlICYmIGZpcnN0LmRyYWdnYWJsZS5pbmRleCA9PT0gc2Vjb25kLmRyYWdnYWJsZS5pbmRleDtcbiAgdmFyIGlzRHJvcHBhYmxlRXF1YWwgPSBmaXJzdC5kcm9wcGFibGUuaWQgPT09IHNlY29uZC5kcm9wcGFibGUuaWQgJiYgZmlyc3QuZHJvcHBhYmxlLnR5cGUgPT09IHNlY29uZC5kcm9wcGFibGUudHlwZTtcbiAgcmV0dXJuIGlzRHJhZ2dhYmxlRXF1YWwgJiYgaXNEcm9wcGFibGVFcXVhbDtcbn07XG5cbnZhciB3aXRoVGltaW5ncyA9IGZ1bmN0aW9uIHdpdGhUaW1pbmdzKGtleSwgZm4pIHtcbiAgc3RhcnQoKTtcbiAgZm4oKTtcbiAgZmluaXNoKCk7XG59O1xuXG52YXIgZ2V0RHJhZ1N0YXJ0ID0gZnVuY3Rpb24gZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlSWQ6IGNyaXRpY2FsLmRyYWdnYWJsZS5pZCxcbiAgICB0eXBlOiBjcml0aWNhbC5kcm9wcGFibGUudHlwZSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWQsXG4gICAgICBpbmRleDogY3JpdGljYWwuZHJhZ2dhYmxlLmluZGV4XG4gICAgfSxcbiAgICBtb2RlOiBtb2RlXG4gIH07XG59O1xuXG52YXIgZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUocmVzcG9uZGVyLCBkYXRhLCBhbm5vdW5jZSwgZ2V0RGVmYXVsdE1lc3NhZ2UpIHtcbiAgaWYgKCFyZXNwb25kZXIpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpbGxFeHBpcmUgPSBnZXRFeHBpcmluZ0Fubm91bmNlKGFubm91bmNlKTtcbiAgdmFyIHByb3ZpZGVkID0ge1xuICAgIGFubm91bmNlOiB3aWxsRXhwaXJlXG4gIH07XG4gIHJlc3BvbmRlcihkYXRhLCBwcm92aWRlZCk7XG5cbiAgaWYgKCF3aWxsRXhwaXJlLndhc0NhbGxlZCgpKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICB9XG59O1xuXG52YXIgZ2V0UHVibGlzaGVyID0gKGZ1bmN0aW9uIChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkge1xuICB2YXIgYXN5bmNNYXJzaGFsID0gZ2V0QXN5bmNNYXJzaGFsKCk7XG4gIHZhciBkcmFnZ2luZyA9IG51bGw7XG5cbiAgdmFyIGJlZm9yZUNhcHR1cmUgPSBmdW5jdGlvbiBiZWZvcmVDYXB0dXJlKGRyYWdnYWJsZUlkLCBtb2RlKSB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlQ2FwdHVyZSBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgd2l0aFRpbWluZ3MoJ29uQmVmb3JlQ2FwdHVyZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZUNhcHR1cmU7XG5cbiAgICAgIGlmIChmbikge1xuICAgICAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgICBtb2RlOiBtb2RlXG4gICAgICAgIH07XG4gICAgICAgIGZuKGJlZm9yZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGJlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gYmVmb3JlU3RhcnQoY3JpdGljYWwsIG1vZGUpIHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZURyYWdTdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZURyYWdTdGFydDtcblxuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGNyaXRpY2FsLCBtb2RlKSB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlRHJhZ1N0YXJ0IGFzIGEgZHJhZyBzdGFydCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZGF0YSA9IGdldERyYWdTdGFydChjcml0aWNhbCwgbW9kZSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgbGFzdENyaXRpY2FsOiBjcml0aWNhbCxcbiAgICAgIGxhc3RMb2NhdGlvbjogZGF0YS5zb3VyY2UsXG4gICAgICBsYXN0Q29tYmluZTogbnVsbFxuICAgIH07XG4gICAgYXN5bmNNYXJzaGFsLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICB3aXRoVGltaW5ncygnb25EcmFnU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlKGdldFJlc3BvbmRlcnMoKS5vbkRyYWdTdGFydCwgZGF0YSwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdTdGFydCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGNyaXRpY2FsLCBpbXBhY3QpIHtcbiAgICB2YXIgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpO1xuICAgIHZhciBjb21iaW5lID0gdHJ5R2V0Q29tYmluZShpbXBhY3QpO1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ01vdmUgd2hlbiBvbkRyYWdTdGFydCBoYXMgbm90IGJlZW4gY2FsbGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBoYXNDcml0aWNhbENoYW5nZWQgPSAhaXNDcml0aWNhbEVxdWFsKGNyaXRpY2FsLCBkcmFnZ2luZy5sYXN0Q3JpdGljYWwpO1xuXG4gICAgaWYgKGhhc0NyaXRpY2FsQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdENyaXRpY2FsID0gY3JpdGljYWw7XG4gICAgfVxuXG4gICAgdmFyIGhhc0xvY2F0aW9uQ2hhbmdlZCA9ICFhcmVMb2NhdGlvbnNFcXVhbChkcmFnZ2luZy5sYXN0TG9jYXRpb24sIGxvY2F0aW9uKTtcblxuICAgIGlmIChoYXNMb2NhdGlvbkNoYW5nZWQpIHtcbiAgICAgIGRyYWdnaW5nLmxhc3RMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIH1cblxuICAgIHZhciBoYXNHcm91cGluZ0NoYW5nZWQgPSAhaXNDb21iaW5lRXF1YWwoZHJhZ2dpbmcubGFzdENvbWJpbmUsIGNvbWJpbmUpO1xuXG4gICAgaWYgKGhhc0dyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdENvbWJpbmUgPSBjb21iaW5lO1xuICAgIH1cblxuICAgIGlmICghaGFzQ3JpdGljYWxDaGFuZ2VkICYmICFoYXNMb2NhdGlvbkNoYW5nZWQgJiYgIWhhc0dyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gX2V4dGVuZHMoe30sIGdldERyYWdTdGFydChjcml0aWNhbCwgZHJhZ2dpbmcubW9kZSksIHtcbiAgICAgIGNvbWJpbmU6IGNvbWJpbmUsXG4gICAgICBkZXN0aW5hdGlvbjogbG9jYXRpb25cbiAgICB9KTtcblxuICAgIGFzeW5jTWFyc2hhbC5hZGQoZnVuY3Rpb24gKCkge1xuICAgICAgd2l0aFRpbWluZ3MoJ29uRHJhZ1VwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ1VwZGF0ZSwgZGF0YSwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgZmx1c2ggcmVzcG9uZGVycyB3aGlsZSBkcmFnZ2luZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBhc3luY01hcnNoYWwuZmx1c2goKTtcbiAgfTtcblxuICB2YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AocmVzdWx0KSB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnRW5kIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgb25EcmFnU3RhcnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgZHJhZ2dpbmcgPSBudWxsO1xuICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdFbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZShnZXRSZXNwb25kZXJzKCkub25EcmFnRW5kLCByZXN1bHQsIGFubm91bmNlLCBwcmVzZXQub25EcmFnRW5kKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IF9leHRlbmRzKHt9LCBnZXREcmFnU3RhcnQoZHJhZ2dpbmcubGFzdENyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSwge1xuICAgICAgY29tYmluZTogbnVsbCxcbiAgICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgICAgcmVhc29uOiAnQ0FOQ0VMJ1xuICAgIH0pO1xuXG4gICAgZHJvcChyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYmVmb3JlQ2FwdHVyZTogYmVmb3JlQ2FwdHVyZSxcbiAgICBiZWZvcmVTdGFydDogYmVmb3JlU3RhcnQsXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIGZsdXNoOiBmbHVzaCxcbiAgICBkcm9wOiBkcm9wLFxuICAgIGFib3J0OiBhYm9ydFxuICB9O1xufSk7XG5cbnZhciByZXNwb25kZXJzID0gKGZ1bmN0aW9uIChnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSkge1xuICB2YXIgcHVibGlzaGVyID0gZ2V0UHVibGlzaGVyKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnQkVGT1JFX0lOSVRJQUxfQ0FQVFVSRScpIHtcbiAgICAgICAgICBwdWJsaXNoZXIuYmVmb3JlQ2FwdHVyZShhY3Rpb24ucGF5bG9hZC5kcmFnZ2FibGVJZCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdJTklUSUFMX1BVQkxJU0gnKSB7XG4gICAgICAgICAgdmFyIGNyaXRpY2FsID0gYWN0aW9uLnBheWxvYWQuY3JpdGljYWw7XG4gICAgICAgICAgcHVibGlzaGVyLmJlZm9yZVN0YXJ0KGNyaXRpY2FsLCBhY3Rpb24ucGF5bG9hZC5tb3ZlbWVudE1vZGUpO1xuICAgICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICBwdWJsaXNoZXIuc3RhcnQoY3JpdGljYWwsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgICAgICBwdWJsaXNoZXIuZmx1c2goKTtcbiAgICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgcHVibGlzaGVyLmRyb3AocmVzdWx0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KGFjdGlvbik7XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRkxVU0gnKSB7XG4gICAgICAgICAgcHVibGlzaGVyLmFib3J0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgICBwdWJsaXNoZXIudXBkYXRlKHN0YXRlLmNyaXRpY2FsLCBzdGF0ZS5pbXBhY3QpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59KTtcblxudmFyIGRyb3BBbmltYXRpb25GaW5pc2ggPSAoZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLnR5cGUgIT09ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpIHtcbiAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAhKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaW5pc2ggYSBkcm9wIGFuaW1hdGluZyB3aGVuIG5vIGRyb3AgaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgc3RvcmUuZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICAgICAgY29tcGxldGVkOiBzdGF0ZS5jb21wbGV0ZWRcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCA9IChmdW5jdGlvbiAoc3RvcmUpIHtcbiAgdmFyIHVuYmluZCA9IG51bGw7XG4gIHZhciBmcmFtZUlkID0gbnVsbDtcblxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodW5iaW5kKSB7XG4gICAgICB1bmJpbmQoKTtcbiAgICAgIHVuYmluZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJyB8fCBhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSB7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIG5leHQoYWN0aW9uKTtcblxuICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSAnRFJPUF9BTklNQVRFJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiaW5kaW5nID0ge1xuICAgICAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGZuOiBmdW5jdGlvbiBmbHVzaERyb3BBbmltYXRpb24oKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goZHJvcEFuaW1hdGlvbkZpbmlzaGVkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICAgICAgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFtiaW5kaW5nXSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBkaW1lbnNpb25NYXJzaGFsU3RvcHBlciA9IChmdW5jdGlvbiAobWFyc2hhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScgfHwgYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnKSB7XG4gICAgICAgICAgbWFyc2hhbC5zdG9wUHVibGlzaGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBmb2N1cyA9IChmdW5jdGlvbiAobWFyc2hhbCkge1xuICB2YXIgaXNXYXRjaGluZyA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICAgICAgIGlzV2F0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgIG1hcnNoYWwudHJ5UmVjb3JkRm9jdXMoYWN0aW9uLnBheWxvYWQuY3JpdGljYWwuZHJhZ2dhYmxlLmlkKTtcbiAgICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoYWN0aW9uKTtcblxuICAgICAgICBpZiAoIWlzV2F0Y2hpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdGTFVTSCcpIHtcbiAgICAgICAgICBpc1dhdGNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5jb21iaW5lKSB7XG4gICAgICAgICAgICBtYXJzaGFsLnRyeVNoaWZ0UmVjb3JkKHJlc3VsdC5kcmFnZ2FibGVJZCwgcmVzdWx0LmNvbWJpbmUuZHJhZ2dhYmxlSWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBzaG91bGRTdG9wID0gZnVuY3Rpb24gc2hvdWxkU3RvcChhY3Rpb24pIHtcbiAgcmV0dXJuIGFjdGlvbi50eXBlID09PSAnRFJPUF9DT01QTEVURScgfHwgYWN0aW9uLnR5cGUgPT09ICdEUk9QX0FOSU1BVEUnIHx8IGFjdGlvbi50eXBlID09PSAnRkxVU0gnO1xufTtcblxudmFyIGF1dG9TY3JvbGwgPSAoZnVuY3Rpb24gKGF1dG9TY3JvbGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoc2hvdWxkU3RvcChhY3Rpb24pKSB7XG4gICAgICAgICAgYXV0b1Njcm9sbGVyLnN0b3AoKTtcbiAgICAgICAgICBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcGhhc2UgdG8gYmUgRFJBR0dJTkcgYWZ0ZXIgSU5JVElBTF9QVUJMSVNIJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICAgIGF1dG9TY3JvbGxlci5zdGFydChzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgICBhdXRvU2Nyb2xsZXIuc2Nyb2xsKHN0b3JlLmdldFN0YXRlKCkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBwZW5kaW5nRHJvcCA9IChmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIG5leHQoYWN0aW9uKTtcblxuICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSAnUFVCTElTSF9XSElMRV9EUkFHR0lORycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zdEFjdGlvblN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgaWYgKHBvc3RBY3Rpb25TdGF0ZS5waGFzZSAhPT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zdEFjdGlvblN0YXRlLmlzV2FpdGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3Aoe1xuICAgICAgICByZWFzb246IHBvc3RBY3Rpb25TdGF0ZS5yZWFzb25cbiAgICAgIH0pKTtcbiAgICB9O1xuICB9O1xufSk7XG5cbnZhciBjb21wb3NlRW5oYW5jZXJzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyh7XG4gIG5hbWU6ICdyZWFjdC1iZWF1dGlmdWwtZG5kJ1xufSkgOiBjb21wb3NlO1xudmFyIGNyZWF0ZVN0b3JlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkaW1lbnNpb25NYXJzaGFsID0gX3JlZi5kaW1lbnNpb25NYXJzaGFsLFxuICAgICAgZm9jdXNNYXJzaGFsID0gX3JlZi5mb2N1c01hcnNoYWwsXG4gICAgICBzdHlsZU1hcnNoYWwgPSBfcmVmLnN0eWxlTWFyc2hhbCxcbiAgICAgIGdldFJlc3BvbmRlcnMgPSBfcmVmLmdldFJlc3BvbmRlcnMsXG4gICAgICBhbm5vdW5jZSA9IF9yZWYuYW5ub3VuY2UsXG4gICAgICBhdXRvU2Nyb2xsZXIgPSBfcmVmLmF1dG9TY3JvbGxlcjtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlJDEocmVkdWNlciwgY29tcG9zZUVuaGFuY2VycyhhcHBseU1pZGRsZXdhcmUoc3R5bGUoc3R5bGVNYXJzaGFsKSwgZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIoZGltZW5zaW9uTWFyc2hhbCksIGxpZnQkMShkaW1lbnNpb25NYXJzaGFsKSwgZHJvcCQxLCBkcm9wQW5pbWF0aW9uRmluaXNoLCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbCwgcGVuZGluZ0Ryb3AsIGF1dG9TY3JvbGwoYXV0b1Njcm9sbGVyKSwgc2Nyb2xsTGlzdGVuZXIsIGZvY3VzKGZvY3VzTWFyc2hhbCksIHJlc3BvbmRlcnMoZ2V0UmVzcG9uZGVycywgYW5ub3VuY2UpKSkpO1xufSk7XG5cbnZhciBjbGVhbiQxID0gZnVuY3Rpb24gY2xlYW4oKSB7XG4gIHJldHVybiB7XG4gICAgYWRkaXRpb25zOiB7fSxcbiAgICByZW1vdmFsczoge30sXG4gICAgbW9kaWZpZWQ6IHt9XG4gIH07XG59O1xuZnVuY3Rpb24gY3JlYXRlUHVibGlzaGVyKF9yZWYpIHtcbiAgdmFyIHJlZ2lzdHJ5ID0gX3JlZi5yZWdpc3RyeSxcbiAgICAgIGNhbGxiYWNrcyA9IF9yZWYuY2FsbGJhY2tzO1xuICB2YXIgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgdmFyIGZyYW1lSWQgPSBudWxsO1xuXG4gIHZhciBjb2xsZWN0ID0gZnVuY3Rpb24gY29sbGVjdCgpIHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmcoKTtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgc3RhcnQoKTtcbiAgICAgIHZhciBfc3RhZ2luZyA9IHN0YWdpbmcsXG4gICAgICAgICAgYWRkaXRpb25zID0gX3N0YWdpbmcuYWRkaXRpb25zLFxuICAgICAgICAgIHJlbW92YWxzID0gX3N0YWdpbmcucmVtb3ZhbHMsXG4gICAgICAgICAgbW9kaWZpZWQgPSBfc3RhZ2luZy5tb2RpZmllZDtcbiAgICAgIHZhciBhZGRlZCA9IE9iamVjdC5rZXlzKGFkZGl0aW9ucykubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoaWQpLmdldERpbWVuc2lvbihvcmlnaW4pO1xuICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4O1xuICAgICAgfSk7XG4gICAgICB2YXIgdXBkYXRlZCA9IE9iamVjdC5rZXlzKG1vZGlmaWVkKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKTtcbiAgICAgICAgdmFyIHNjcm9sbCA9IGVudHJ5LmNhbGxiYWNrcy5nZXRTY3JvbGxXaGlsZURyYWdnaW5nKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZHJvcHBhYmxlSWQ6IGlkLFxuICAgICAgICAgIHNjcm9sbDogc2Nyb2xsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGFkZGl0aW9uczogYWRkZWQsXG4gICAgICAgIHJlbW92YWxzOiBPYmplY3Qua2V5cyhyZW1vdmFscyksXG4gICAgICAgIG1vZGlmaWVkOiB1cGRhdGVkXG4gICAgICB9O1xuICAgICAgc3RhZ2luZyA9IGNsZWFuJDEoKTtcbiAgICAgIGZpbmlzaCgpO1xuICAgICAgY2FsbGJhY2tzLnB1Ymxpc2gocmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGVudHJ5KSB7XG4gICAgdmFyIGlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICBzdGFnaW5nLmFkZGl0aW9uc1tpZF0gPSBlbnRyeTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2VudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcblxuICAgIGlmIChzdGFnaW5nLnJlbW92YWxzW2lkXSkge1xuICAgICAgZGVsZXRlIHN0YWdpbmcucmVtb3ZhbHNbaWRdO1xuICAgIH1cblxuICAgIGNvbGxlY3QoKTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGVudHJ5KSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHN0YWdpbmcucmVtb3ZhbHNbZGVzY3JpcHRvci5pZF0gPSB0cnVlO1xuICAgIHN0YWdpbmcubW9kaWZpZWRbZGVzY3JpcHRvci5kcm9wcGFibGVJZF0gPSB0cnVlO1xuXG4gICAgaWYgKHN0YWdpbmcuYWRkaXRpb25zW2Rlc2NyaXB0b3IuaWRdKSB7XG4gICAgICBkZWxldGUgc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF07XG4gICAgfVxuXG4gICAgY29sbGVjdCgpO1xuICB9O1xuXG4gIHZhciBzdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoIWZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICBmcmFtZUlkID0gbnVsbDtcbiAgICBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYWRkOiBhZGQsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgc3RvcDogc3RvcFxuICB9O1xufVxuXG52YXIgZ2V0TWF4U2Nyb2xsID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzY3JvbGxIZWlnaHQgPSBfcmVmLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoID0gX3JlZi5zY3JvbGxXaWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoO1xuICB2YXIgbWF4U2Nyb2xsID0gc3VidHJhY3Qoe1xuICAgIHg6IHNjcm9sbFdpZHRoLFxuICAgIHk6IHNjcm9sbEhlaWdodFxuICB9LCB7XG4gICAgeDogd2lkdGgsXG4gICAgeTogaGVpZ2h0XG4gIH0pO1xuICB2YXIgYWRqdXN0ZWRNYXhTY3JvbGwgPSB7XG4gICAgeDogTWF0aC5tYXgoMCwgbWF4U2Nyb2xsLngpLFxuICAgIHk6IE1hdGgubWF4KDAsIG1heFNjcm9sbC55KVxuICB9O1xuICByZXR1cm4gYWRqdXN0ZWRNYXhTY3JvbGw7XG59KTtcblxudmFyIGdldERvY3VtZW50RWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICFkb2MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2M7XG59KTtcblxudmFyIGdldE1heFdpbmRvd1Njcm9sbCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2MgPSBnZXREb2N1bWVudEVsZW1lbnQoKTtcbiAgdmFyIG1heFNjcm9sbCA9IGdldE1heFNjcm9sbCh7XG4gICAgc2Nyb2xsSGVpZ2h0OiBkb2Muc2Nyb2xsSGVpZ2h0LFxuICAgIHNjcm9sbFdpZHRoOiBkb2Muc2Nyb2xsV2lkdGgsXG4gICAgd2lkdGg6IGRvYy5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGRvYy5jbGllbnRIZWlnaHRcbiAgfSk7XG4gIHJldHVybiBtYXhTY3JvbGw7XG59KTtcblxudmFyIGdldFZpZXdwb3J0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbCgpO1xuICB2YXIgbWF4U2Nyb2xsID0gZ2V0TWF4V2luZG93U2Nyb2xsKCk7XG4gIHZhciB0b3AgPSBzY3JvbGwueTtcbiAgdmFyIGxlZnQgPSBzY3JvbGwueDtcbiAgdmFyIGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICB2YXIgd2lkdGggPSBkb2MuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBkb2MuY2xpZW50SGVpZ2h0O1xuICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gIHZhciBmcmFtZSA9IGdldFJlY3Qoe1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGJvdHRvbTogYm90dG9tXG4gIH0pO1xuICB2YXIgdmlld3BvcnQgPSB7XG4gICAgZnJhbWU6IGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsLFxuICAgICAgY3VycmVudDogc2Nyb2xsLFxuICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gdmlld3BvcnQ7XG59KTtcblxudmFyIGdldEluaXRpYWxQdWJsaXNoID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjcml0aWNhbCA9IF9yZWYuY3JpdGljYWwsXG4gICAgICBzY3JvbGxPcHRpb25zID0gX3JlZi5zY3JvbGxPcHRpb25zLFxuICAgICAgcmVnaXN0cnkgPSBfcmVmLnJlZ2lzdHJ5O1xuICBzdGFydCgpO1xuICB2YXIgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCgpO1xuICB2YXIgd2luZG93U2Nyb2xsID0gdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQ7XG4gIHZhciBob21lID0gY3JpdGljYWwuZHJvcHBhYmxlO1xuICB2YXIgZHJvcHBhYmxlcyA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmNhbGxiYWNrcy5nZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCh3aW5kb3dTY3JvbGwsIHNjcm9sbE9wdGlvbnMpO1xuICB9KTtcbiAgdmFyIGRyYWdnYWJsZXMgPSByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QWxsQnlUeXBlKGNyaXRpY2FsLmRyYWdnYWJsZS50eXBlKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmdldERpbWVuc2lvbih3aW5kb3dTY3JvbGwpO1xuICB9KTtcbiAgdmFyIGRpbWVuc2lvbnMgPSB7XG4gICAgZHJhZ2dhYmxlczogdG9EcmFnZ2FibGVNYXAoZHJhZ2dhYmxlcyksXG4gICAgZHJvcHBhYmxlczogdG9Ecm9wcGFibGVNYXAoZHJvcHBhYmxlcylcbiAgfTtcbiAgZmluaXNoKCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcbiAgICBjcml0aWNhbDogY3JpdGljYWwsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZnVuY3Rpb24gc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGVudHJ5KSB7XG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLmlkID09PSBkcmFnZ2luZy5pZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChlbnRyeS5kZXNjcmlwdG9yLnR5cGUgIT09IGRyYWdnaW5nLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuXG4gIGlmIChob21lLmRlc2NyaXB0b3IubW9kZSAhPT0gJ3ZpcnR1YWwnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgIFlvdSBhcmUgYXR0ZW1wdGluZyB0byBhZGQgb3IgcmVtb3ZlIGEgRHJhZ2dhYmxlIFtpZDogXCIgKyBlbnRyeS5kZXNjcmlwdG9yLmlkICsgXCJdXFxuICAgICAgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgdmlydHVhbCBsaXN0cy5cXG5cXG4gICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvcGF0dGVybnMvdmlydHVhbC1saXN0cy5tZFxcbiAgICBcIikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBjcmVhdGVEaW1lbnNpb25NYXJzaGFsID0gKGZ1bmN0aW9uIChyZWdpc3RyeSwgY2FsbGJhY2tzKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gbnVsbDtcbiAgdmFyIHB1Ymxpc2hlciA9IGNyZWF0ZVB1Ymxpc2hlcih7XG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBwdWJsaXNoOiBjYWxsYmFja3MucHVibGlzaFdoaWxlRHJhZ2dpbmcsXG4gICAgICBjb2xsZWN0aW9uU3RhcnRpbmc6IGNhbGxiYWNrcy5jb2xsZWN0aW9uU3RhcnRpbmdcbiAgICB9LFxuICAgIHJlZ2lzdHJ5OiByZWdpc3RyeVxuICB9KTtcblxuICB2YXIgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gZnVuY3Rpb24gdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKGlkLCBpc0VuYWJsZWQpIHtcbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IHVwZGF0ZSBpcyBlbmFibGVkIGZsYWcgb2YgRHJvcHBhYmxlIFwiICsgaWQgKyBcIiBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZFwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlzRW5hYmxlZDogaXNFbmFibGVkXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQgPSBmdW5jdGlvbiB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKGlkLCBpc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCB1cGRhdGUgaXNDb21iaW5lRW5hYmxlZCBmbGFnIG9mIERyb3BwYWJsZSBcIiArIGlkICsgXCIgYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWRcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gZnVuY3Rpb24gdXBkYXRlRHJvcHBhYmxlU2Nyb2xsKGlkLCBuZXdTY3JvbGwpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IHVwZGF0ZSB0aGUgc2Nyb2xsIG9uIERyb3BwYWJsZSBcIiArIGlkICsgXCIgYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNhbGxiYWNrcy51cGRhdGVEcm9wcGFibGVTY3JvbGwoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgbmV3U2Nyb2xsOiBuZXdTY3JvbGxcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc2Nyb2xsRHJvcHBhYmxlID0gZnVuY3Rpb24gc2Nyb2xsRHJvcHBhYmxlKGlkLCBjaGFuZ2UpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCkuY2FsbGJhY2tzLnNjcm9sbChjaGFuZ2UpO1xuICB9O1xuXG4gIHZhciBzdG9wUHVibGlzaGluZyA9IGZ1bmN0aW9uIHN0b3BQdWJsaXNoaW5nKCkge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1Ymxpc2hlci5zdG9wKCk7XG4gICAgdmFyIGhvbWUgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QWxsQnlUeXBlKGhvbWUudHlwZSkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5jYWxsYmFja3MuZHJhZ1N0b3BwZWQoKTtcbiAgICB9KTtcbiAgICBjb2xsZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgY29sbGVjdGlvbiA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHN1YnNjcmliZXIgPSBmdW5jdGlvbiBzdWJzY3JpYmVyKGV2ZW50KSB7XG4gICAgIWNvbGxlY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgb25seSBiZSBzdWJzY3JpYmVkIHdoZW4gYSBjb2xsZWN0aW9uIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZHJhZ2dpbmcgPSBjb2xsZWN0aW9uLmNyaXRpY2FsLmRyYWdnYWJsZTtcblxuICAgIGlmIChldmVudC50eXBlID09PSAnQURESVRJT04nKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIuYWRkKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ1JFTU9WQUwnKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIucmVtb3ZlKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0YXJ0UHVibGlzaGluZyA9IGZ1bmN0aW9uIHN0YXJ0UHVibGlzaGluZyhyZXF1ZXN0KSB7XG4gICAgISFjb2xsZWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGNhcHR1cmluZyBjcml0aWNhbCBkaW1lbnNpb25zIGFzIHRoZXJlIGlzIGFscmVhZHkgYSBjb2xsZWN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKHJlcXVlc3QuZHJhZ2dhYmxlSWQpO1xuICAgIHZhciBob21lID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZCk7XG4gICAgdmFyIGNyaXRpY2FsID0ge1xuICAgICAgZHJhZ2dhYmxlOiBlbnRyeS5kZXNjcmlwdG9yLFxuICAgICAgZHJvcHBhYmxlOiBob21lLmRlc2NyaXB0b3JcbiAgICB9O1xuICAgIHZhciB1bnN1YnNjcmliZSA9IHJlZ2lzdHJ5LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICBjb2xsZWN0aW9uID0ge1xuICAgICAgY3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0SW5pdGlhbFB1Ymxpc2goe1xuICAgICAgY3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgcmVnaXN0cnk6IHJlZ2lzdHJ5LFxuICAgICAgc2Nyb2xsT3B0aW9uczogcmVxdWVzdC5zY3JvbGxPcHRpb25zXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG1hcnNoYWwgPSB7XG4gICAgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkOiB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZDogdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBzY3JvbGxEcm9wcGFibGU6IHNjcm9sbERyb3BwYWJsZSxcbiAgICB1cGRhdGVEcm9wcGFibGVTY3JvbGw6IHVwZGF0ZURyb3BwYWJsZVNjcm9sbCxcbiAgICBzdGFydFB1Ymxpc2hpbmc6IHN0YXJ0UHVibGlzaGluZyxcbiAgICBzdG9wUHVibGlzaGluZzogc3RvcFB1Ymxpc2hpbmdcbiAgfTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59KTtcblxudmFyIGNhblN0YXJ0RHJhZyA9IChmdW5jdGlvbiAoc3RhdGUsIGlkKSB7XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0lETEUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc3RhdGUucGhhc2UgIT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuY29tcGxldGVkLnJlc3VsdC5yZWFzb24gPT09ICdEUk9QJztcbn0pO1xuXG52YXIgc2Nyb2xsV2luZG93ID0gKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgd2luZG93LnNjcm9sbEJ5KGNoYW5nZS54LCBjaGFuZ2UueSk7XG59KTtcblxudmFyIGdldFNjcm9sbGFibGVEcm9wcGFibGVzID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoZHJvcHBhYmxlcykge1xuICByZXR1cm4gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihmdW5jdGlvbiAoZHJvcHBhYmxlKSB7XG4gICAgaWYgKCFkcm9wcGFibGUuaXNFbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFkcm9wcGFibGUuZnJhbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59KTtcblxudmFyIGdldFNjcm9sbGFibGVEcm9wcGFibGVPdmVyID0gZnVuY3Rpb24gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIodGFyZ2V0LCBkcm9wcGFibGVzKSB7XG4gIHZhciBtYXliZSA9IGZpbmQoZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMoZHJvcHBhYmxlcyksIGZ1bmN0aW9uIChkcm9wcGFibGUpIHtcbiAgICAhZHJvcHBhYmxlLmZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCByZXN1bHQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGlzUG9zaXRpb25JbkZyYW1lKGRyb3BwYWJsZS5mcmFtZS5wYWdlTWFyZ2luQm94KSh0YXJnZXQpO1xuICB9KTtcbiAgcmV0dXJuIG1heWJlO1xufTtcblxudmFyIGdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjZW50ZXIgPSBfcmVmLmNlbnRlcixcbiAgICAgIGRlc3RpbmF0aW9uID0gX3JlZi5kZXN0aW5hdGlvbixcbiAgICAgIGRyb3BwYWJsZXMgPSBfcmVmLmRyb3BwYWJsZXM7XG5cbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgdmFyIF9kaW1lbnNpb24gPSBkcm9wcGFibGVzW2Rlc3RpbmF0aW9uXTtcblxuICAgIGlmICghX2RpbWVuc2lvbi5mcmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kaW1lbnNpb247XG4gIH1cblxuICB2YXIgZGltZW5zaW9uID0gZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIoY2VudGVyLCBkcm9wcGFibGVzKTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn0pO1xuXG52YXIgY29uZmlnID0ge1xuICBzdGFydEZyb21QZXJjZW50YWdlOiAwLjI1LFxuICBtYXhTY3JvbGxBdFBlcmNlbnRhZ2U6IDAuMDUsXG4gIG1heFBpeGVsU2Nyb2xsOiAyOCxcbiAgZWFzZTogZnVuY3Rpb24gZWFzZShwZXJjZW50YWdlKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHBlcmNlbnRhZ2UsIDIpO1xuICB9LFxuICBkdXJhdGlvbkRhbXBlbmluZzoge1xuICAgIHN0b3BEYW1wZW5pbmdBdDogMTIwMCxcbiAgICBhY2NlbGVyYXRlQXQ6IDM2MFxuICB9XG59O1xuXG52YXIgZ2V0RGlzdGFuY2VUaHJlc2hvbGRzID0gKGZ1bmN0aW9uIChjb250YWluZXIsIGF4aXMpIHtcbiAgdmFyIHN0YXJ0U2Nyb2xsaW5nRnJvbSA9IGNvbnRhaW5lcltheGlzLnNpemVdICogY29uZmlnLnN0YXJ0RnJvbVBlcmNlbnRhZ2U7XG4gIHZhciBtYXhTY3JvbGxWYWx1ZUF0ID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBjb25maWcubWF4U2Nyb2xsQXRQZXJjZW50YWdlO1xuICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICBzdGFydFNjcm9sbGluZ0Zyb206IHN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBtYXhTY3JvbGxWYWx1ZUF0OiBtYXhTY3JvbGxWYWx1ZUF0XG4gIH07XG4gIHJldHVybiB0aHJlc2hvbGRzO1xufSk7XG5cbnZhciBnZXRQZXJjZW50YWdlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzdGFydE9mUmFuZ2UgPSBfcmVmLnN0YXJ0T2ZSYW5nZSxcbiAgICAgIGVuZE9mUmFuZ2UgPSBfcmVmLmVuZE9mUmFuZ2UsXG4gICAgICBjdXJyZW50ID0gX3JlZi5jdXJyZW50O1xuICB2YXIgcmFuZ2UgPSBlbmRPZlJhbmdlIC0gc3RhcnRPZlJhbmdlO1xuXG4gIGlmIChyYW5nZSA9PT0gMCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICBEZXRlY3RlZCBkaXN0YW5jZSByYW5nZSBvZiAwIGluIHRoZSBmbHVpZCBhdXRvIHNjcm9sbGVyXFxuICAgICAgVGhpcyBpcyB1bmV4cGVjdGVkIGFuZCB3b3VsZCBjYXVzZSBhIGRpdmlkZSBieSAwIGlzc3VlLlxcbiAgICAgIE5vdCBhbGxvd2luZyBhbiBhdXRvIHNjcm9sbFxcbiAgICBcIikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgY3VycmVudEluUmFuZ2UgPSBjdXJyZW50IC0gc3RhcnRPZlJhbmdlO1xuICB2YXIgcGVyY2VudGFnZSA9IGN1cnJlbnRJblJhbmdlIC8gcmFuZ2U7XG4gIHJldHVybiBwZXJjZW50YWdlO1xufSk7XG5cbnZhciBtaW5TY3JvbGwgPSAxO1xuXG52YXIgZ2V0VmFsdWVGcm9tRGlzdGFuY2UgPSAoZnVuY3Rpb24gKGRpc3RhbmNlVG9FZGdlLCB0aHJlc2hvbGRzKSB7XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA+IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPD0gdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0KSB7XG4gICAgcmV0dXJuIGNvbmZpZy5tYXhQaXhlbFNjcm9sbDtcbiAgfVxuXG4gIGlmIChkaXN0YW5jZVRvRWRnZSA9PT0gdGhyZXNob2xkcy5zdGFydFNjcm9sbGluZ0Zyb20pIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG5cbiAgdmFyIHBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdCA9IGdldFBlcmNlbnRhZ2Uoe1xuICAgIHN0YXJ0T2ZSYW5nZTogdGhyZXNob2xkcy5tYXhTY3JvbGxWYWx1ZUF0LFxuICAgIGVuZE9mUmFuZ2U6IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tLFxuICAgIGN1cnJlbnQ6IGRpc3RhbmNlVG9FZGdlXG4gIH0pO1xuICB2YXIgcGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20gPSAxIC0gcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0O1xuICB2YXIgc2Nyb2xsID0gY29uZmlnLm1heFBpeGVsU2Nyb2xsICogY29uZmlnLmVhc2UocGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20pO1xuICByZXR1cm4gTWF0aC5jZWlsKHNjcm9sbCk7XG59KTtcblxudmFyIGFjY2VsZXJhdGVBdCA9IGNvbmZpZy5kdXJhdGlvbkRhbXBlbmluZy5hY2NlbGVyYXRlQXQ7XG52YXIgc3RvcEF0ID0gY29uZmlnLmR1cmF0aW9uRGFtcGVuaW5nLnN0b3BEYW1wZW5pbmdBdDtcbnZhciBkYW1wZW5WYWx1ZUJ5VGltZSA9IChmdW5jdGlvbiAocHJvcG9zZWRTY3JvbGwsIGRyYWdTdGFydFRpbWUpIHtcbiAgdmFyIHN0YXJ0T2ZSYW5nZSA9IGRyYWdTdGFydFRpbWU7XG4gIHZhciBlbmRPZlJhbmdlID0gc3RvcEF0O1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgdmFyIHJ1blRpbWUgPSBub3cgLSBzdGFydE9mUmFuZ2U7XG5cbiAgaWYgKHJ1blRpbWUgPj0gc3RvcEF0KSB7XG4gICAgcmV0dXJuIHByb3Bvc2VkU2Nyb2xsO1xuICB9XG5cbiAgaWYgKHJ1blRpbWUgPCBhY2NlbGVyYXRlQXQpIHtcbiAgICByZXR1cm4gbWluU2Nyb2xsO1xuICB9XG5cbiAgdmFyIGJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlID0gZ2V0UGVyY2VudGFnZSh7XG4gICAgc3RhcnRPZlJhbmdlOiBhY2NlbGVyYXRlQXQsXG4gICAgZW5kT2ZSYW5nZTogZW5kT2ZSYW5nZSxcbiAgICBjdXJyZW50OiBydW5UaW1lXG4gIH0pO1xuICB2YXIgc2Nyb2xsID0gcHJvcG9zZWRTY3JvbGwgKiBjb25maWcuZWFzZShiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSk7XG4gIHJldHVybiBNYXRoLmNlaWwoc2Nyb2xsKTtcbn0pO1xuXG52YXIgZ2V0VmFsdWUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGRpc3RhbmNlVG9FZGdlID0gX3JlZi5kaXN0YW5jZVRvRWRnZSxcbiAgICAgIHRocmVzaG9sZHMgPSBfcmVmLnRocmVzaG9sZHMsXG4gICAgICBkcmFnU3RhcnRUaW1lID0gX3JlZi5kcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZztcbiAgdmFyIHNjcm9sbCA9IGdldFZhbHVlRnJvbURpc3RhbmNlKGRpc3RhbmNlVG9FZGdlLCB0aHJlc2hvbGRzKTtcblxuICBpZiAoc2Nyb2xsID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIXNob3VsZFVzZVRpbWVEYW1wZW5pbmcpIHtcbiAgICByZXR1cm4gc2Nyb2xsO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4KGRhbXBlblZhbHVlQnlUaW1lKHNjcm9sbCwgZHJhZ1N0YXJ0VGltZSksIG1pblNjcm9sbCk7XG59KTtcblxudmFyIGdldFNjcm9sbE9uQXhpcyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICBkaXN0YW5jZVRvRWRnZXMgPSBfcmVmLmRpc3RhbmNlVG9FZGdlcyxcbiAgICAgIGRyYWdTdGFydFRpbWUgPSBfcmVmLmRyYWdTdGFydFRpbWUsXG4gICAgICBheGlzID0gX3JlZi5heGlzLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZztcbiAgdmFyIHRocmVzaG9sZHMgPSBnZXREaXN0YW5jZVRocmVzaG9sZHMoY29udGFpbmVyLCBheGlzKTtcbiAgdmFyIGlzQ2xvc2VyVG9FbmQgPSBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdIDwgZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdO1xuXG4gIGlmIChpc0Nsb3NlclRvRW5kKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKHtcbiAgICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdLFxuICAgICAgdGhyZXNob2xkczogdGhyZXNob2xkcyxcbiAgICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gLTEgKiBnZXRWYWx1ZSh7XG4gICAgZGlzdGFuY2VUb0VkZ2U6IGRpc3RhbmNlVG9FZGdlc1theGlzLnN0YXJ0XSxcbiAgICB0aHJlc2hvbGRzOiB0aHJlc2hvbGRzLFxuICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICB9KTtcbn0pO1xuXG52YXIgYWRqdXN0Rm9yU2l6ZUxpbWl0cyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gX3JlZi5zdWJqZWN0LFxuICAgICAgcHJvcG9zZWRTY3JvbGwgPSBfcmVmLnByb3Bvc2VkU2Nyb2xsO1xuICB2YXIgaXNUb29CaWdWZXJ0aWNhbGx5ID0gc3ViamVjdC5oZWlnaHQgPiBjb250YWluZXIuaGVpZ2h0O1xuICB2YXIgaXNUb29CaWdIb3Jpem9udGFsbHkgPSBzdWJqZWN0LndpZHRoID4gY29udGFpbmVyLndpZHRoO1xuXG4gIGlmICghaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgIWlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuXG4gIGlmIChpc1Rvb0JpZ0hvcml6b250YWxseSAmJiBpc1Rvb0JpZ1ZlcnRpY2FsbHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogaXNUb29CaWdIb3Jpem9udGFsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueCxcbiAgICB5OiBpc1Rvb0JpZ1ZlcnRpY2FsbHkgPyAwIDogcHJvcG9zZWRTY3JvbGwueVxuICB9O1xufSk7XG5cbnZhciBjbGVhbiQyID0gYXBwbHkoZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbn0pO1xudmFyIGdldFNjcm9sbCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIGNvbnRhaW5lciA9IF9yZWYuY29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IF9yZWYuc3ViamVjdCxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9yZWYuc2hvdWxkVXNlVGltZURhbXBlbmluZztcbiAgdmFyIGRpc3RhbmNlVG9FZGdlcyA9IHtcbiAgICB0b3A6IGNlbnRlci55IC0gY29udGFpbmVyLnRvcCxcbiAgICByaWdodDogY29udGFpbmVyLnJpZ2h0IC0gY2VudGVyLngsXG4gICAgYm90dG9tOiBjb250YWluZXIuYm90dG9tIC0gY2VudGVyLnksXG4gICAgbGVmdDogY2VudGVyLnggLSBjb250YWluZXIubGVmdFxuICB9O1xuICB2YXIgeSA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzOiBkaXN0YW5jZVRvRWRnZXMsXG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBheGlzOiB2ZXJ0aWNhbCxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gIH0pO1xuICB2YXIgeCA9IGdldFNjcm9sbE9uQXhpcyh7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzOiBkaXN0YW5jZVRvRWRnZXMsXG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBheGlzOiBob3Jpem9udGFsLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgfSk7XG4gIHZhciByZXF1aXJlZCA9IGNsZWFuJDIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KTtcblxuICBpZiAoaXNFcXVhbChyZXF1aXJlZCwgb3JpZ2luKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpbWl0ZWQgPSBhZGp1c3RGb3JTaXplTGltaXRzKHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIHByb3Bvc2VkU2Nyb2xsOiByZXF1aXJlZFxuICB9KTtcblxuICBpZiAoIWxpbWl0ZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBpc0VxdWFsKGxpbWl0ZWQsIG9yaWdpbikgPyBudWxsIDogbGltaXRlZDtcbn0pO1xuXG52YXIgc21hbGxlc3RTaWduZWQgPSBhcHBseShmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xO1xufSk7XG52YXIgZ2V0T3ZlcmxhcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdldFJlbWFpbmRlciA9IGZ1bmN0aW9uIGdldFJlbWFpbmRlcih0YXJnZXQsIG1heCkge1xuICAgIGlmICh0YXJnZXQgPCAwKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQgPiBtYXgpIHtcbiAgICAgIHJldHVybiB0YXJnZXQgLSBtYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBfcmVmLmN1cnJlbnQsXG4gICAgICAgIG1heCA9IF9yZWYubWF4LFxuICAgICAgICBjaGFuZ2UgPSBfcmVmLmNoYW5nZTtcbiAgICB2YXIgdGFyZ2V0U2Nyb2xsID0gYWRkKGN1cnJlbnQsIGNoYW5nZSk7XG4gICAgdmFyIG92ZXJsYXAgPSB7XG4gICAgICB4OiBnZXRSZW1haW5kZXIodGFyZ2V0U2Nyb2xsLngsIG1heC54KSxcbiAgICAgIHk6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueSwgbWF4LnkpXG4gICAgfTtcblxuICAgIGlmIChpc0VxdWFsKG92ZXJsYXAsIG9yaWdpbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBvdmVybGFwO1xuICB9O1xufSgpO1xudmFyIGNhblBhcnRpYWxseVNjcm9sbCA9IGZ1bmN0aW9uIGNhblBhcnRpYWxseVNjcm9sbChfcmVmMikge1xuICB2YXIgcmF3TWF4ID0gX3JlZjIubWF4LFxuICAgICAgY3VycmVudCA9IF9yZWYyLmN1cnJlbnQsXG4gICAgICBjaGFuZ2UgPSBfcmVmMi5jaGFuZ2U7XG4gIHZhciBtYXggPSB7XG4gICAgeDogTWF0aC5tYXgoY3VycmVudC54LCByYXdNYXgueCksXG4gICAgeTogTWF0aC5tYXgoY3VycmVudC55LCByYXdNYXgueSlcbiAgfTtcbiAgdmFyIHNtYWxsZXN0Q2hhbmdlID0gc21hbGxlc3RTaWduZWQoY2hhbmdlKTtcbiAgdmFyIG92ZXJsYXAgPSBnZXRPdmVybGFwKHtcbiAgICBtYXg6IG1heCxcbiAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgIGNoYW5nZTogc21hbGxlc3RDaGFuZ2VcbiAgfSk7XG5cbiAgaWYgKCFvdmVybGFwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc21hbGxlc3RDaGFuZ2UueCAhPT0gMCAmJiBvdmVybGFwLnggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzbWFsbGVzdENoYW5nZS55ICE9PSAwICYmIG92ZXJsYXAueSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBjYW5TY3JvbGxXaW5kb3cgPSBmdW5jdGlvbiBjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkge1xuICByZXR1cm4gY2FuUGFydGlhbGx5U2Nyb2xsKHtcbiAgICBjdXJyZW50OiB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCxcbiAgICBtYXg6IHZpZXdwb3J0LnNjcm9sbC5tYXgsXG4gICAgY2hhbmdlOiBjaGFuZ2VcbiAgfSk7XG59O1xudmFyIGdldFdpbmRvd092ZXJsYXAgPSBmdW5jdGlvbiBnZXRXaW5kb3dPdmVybGFwKHZpZXdwb3J0LCBjaGFuZ2UpIHtcbiAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXggPSB2aWV3cG9ydC5zY3JvbGwubWF4O1xuICB2YXIgY3VycmVudCA9IHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50O1xuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudDogY3VycmVudCxcbiAgICBtYXg6IG1heCxcbiAgICBjaGFuZ2U6IGNoYW5nZVxuICB9KTtcbn07XG52YXIgY2FuU2Nyb2xsRHJvcHBhYmxlID0gZnVuY3Rpb24gY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSB7XG4gIHZhciBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNhblBhcnRpYWxseVNjcm9sbCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZTogY2hhbmdlXG4gIH0pO1xufTtcbnZhciBnZXREcm9wcGFibGVPdmVybGFwID0gZnVuY3Rpb24gZ2V0RHJvcHBhYmxlT3ZlcmxhcChkcm9wcGFibGUsIGNoYW5nZSkge1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0T3ZlcmxhcCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZTogY2hhbmdlXG4gIH0pO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbENoYW5nZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgc3ViamVjdCA9IF9yZWYuc3ViamVjdCxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcgPSBfcmVmLnNob3VsZFVzZVRpbWVEYW1wZW5pbmc7XG4gIHZhciBzY3JvbGwgPSBnZXRTY3JvbGwoe1xuICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgY29udGFpbmVyOiB2aWV3cG9ydC5mcmFtZSxcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmc6IHNob3VsZFVzZVRpbWVEYW1wZW5pbmdcbiAgfSk7XG4gIHJldHVybiBzY3JvbGwgJiYgY2FuU2Nyb2xsV2luZG93KHZpZXdwb3J0LCBzY3JvbGwpID8gc2Nyb2xsIDogbnVsbDtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlU2Nyb2xsQ2hhbmdlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkcm9wcGFibGUgPSBfcmVmLmRyb3BwYWJsZSxcbiAgICAgIHN1YmplY3QgPSBfcmVmLnN1YmplY3QsXG4gICAgICBjZW50ZXIgPSBfcmVmLmNlbnRlcixcbiAgICAgIGRyYWdTdGFydFRpbWUgPSBfcmVmLmRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nID0gX3JlZi5zaG91bGRVc2VUaW1lRGFtcGVuaW5nO1xuICB2YXIgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG5cbiAgaWYgKCFmcmFtZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjcm9sbCA9IGdldFNjcm9sbCh7XG4gICAgZHJhZ1N0YXJ0VGltZTogZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IGZyYW1lLnBhZ2VNYXJnaW5Cb3gsXG4gICAgc3ViamVjdDogc3ViamVjdCxcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gIH0pO1xuICByZXR1cm4gc2Nyb2xsICYmIGNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufSk7XG5cbnZhciBzY3JvbGwkMSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgZHJhZ1N0YXJ0VGltZSA9IF9yZWYuZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcgPSBfcmVmLnNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBzY3JvbGxXaW5kb3cgPSBfcmVmLnNjcm9sbFdpbmRvdyxcbiAgICAgIHNjcm9sbERyb3BwYWJsZSA9IF9yZWYuc2Nyb2xsRHJvcHBhYmxlO1xuICB2YXIgY2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgdmFyIGRyYWdnYWJsZSA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICB2YXIgc3ViamVjdCA9IGRyYWdnYWJsZS5wYWdlLm1hcmdpbkJveDtcblxuICBpZiAoc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkKSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gc3RhdGUudmlld3BvcnQ7XG5cbiAgICB2YXIgX2NoYW5nZSA9IGdldFdpbmRvd1Njcm9sbENoYW5nZSh7XG4gICAgICBkcmFnU3RhcnRUaW1lOiBkcmFnU3RhcnRUaW1lLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgc3ViamVjdDogc3ViamVjdCxcbiAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICAgIH0pO1xuXG4gICAgaWYgKF9jaGFuZ2UpIHtcbiAgICAgIHNjcm9sbFdpbmRvdyhfY2hhbmdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICB2YXIgZHJvcHBhYmxlID0gZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUoe1xuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIGRlc3RpbmF0aW9uOiB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpLFxuICAgIGRyb3BwYWJsZXM6IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1xuICB9KTtcblxuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGFuZ2UgPSBnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2Uoe1xuICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGUsXG4gICAgc3ViamVjdDogc3ViamVjdCxcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBzaG91bGRVc2VUaW1lRGFtcGVuaW5nXG4gIH0pO1xuXG4gIGlmIChjaGFuZ2UpIHtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGNoYW5nZSk7XG4gIH1cbn0pO1xuXG52YXIgY3JlYXRlRmx1aWRTY3JvbGxlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc2Nyb2xsV2luZG93ID0gX3JlZi5zY3JvbGxXaW5kb3csXG4gICAgICBzY3JvbGxEcm9wcGFibGUgPSBfcmVmLnNjcm9sbERyb3BwYWJsZTtcbiAgdmFyIHNjaGVkdWxlV2luZG93U2Nyb2xsID0gcmFmU2NoZChzY3JvbGxXaW5kb3cpO1xuICB2YXIgc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwgPSByYWZTY2hkKHNjcm9sbERyb3BwYWJsZSk7XG4gIHZhciBkcmFnZ2luZyA9IG51bGw7XG5cbiAgdmFyIHRyeVNjcm9sbCA9IGZ1bmN0aW9uIHRyeVNjcm9sbChzdGF0ZSkge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmbHVpZCBzY3JvbGwgaWYgbm90IGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBfZHJhZ2dpbmcgPSBkcmFnZ2luZyxcbiAgICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyA9IF9kcmFnZ2luZy5zaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgICBkcmFnU3RhcnRUaW1lID0gX2RyYWdnaW5nLmRyYWdTdGFydFRpbWU7XG4gICAgc2Nyb2xsJDEoe1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2Nyb2xsV2luZG93OiBzY2hlZHVsZVdpbmRvd1Njcm9sbCxcbiAgICAgIHNjcm9sbERyb3BwYWJsZTogc2NoZWR1bGVEcm9wcGFibGVTY3JvbGwsXG4gICAgICBkcmFnU3RhcnRUaW1lOiBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogc2hvdWxkVXNlVGltZURhbXBlbmluZ1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzdGFydCQxID0gZnVuY3Rpb24gc3RhcnQkMShzdGF0ZSkge1xuICAgIHN0YXJ0KCk7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdGFydCBhdXRvIHNjcm9sbGluZyB3aGVuIGFscmVhZHkgc3RhcnRlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgZHJhZ1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdmFyIHdhc1Njcm9sbE5lZWRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGZha2VTY3JvbGxDYWxsYmFjayA9IGZ1bmN0aW9uIGZha2VTY3JvbGxDYWxsYmFjaygpIHtcbiAgICAgIHdhc1Njcm9sbE5lZWRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIHNjcm9sbCQxKHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGRyYWdTdGFydFRpbWU6IDAsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBmYWxzZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBmYWtlU2Nyb2xsQ2FsbGJhY2tcbiAgICB9KTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIGRyYWdTdGFydFRpbWU6IGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiB3YXNTY3JvbGxOZWVkZWRcbiAgICB9O1xuICAgIGZpbmlzaCgpO1xuXG4gICAgaWYgKHdhc1Njcm9sbE5lZWRlZCkge1xuICAgICAgdHJ5U2Nyb2xsKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVdpbmRvd1Njcm9sbC5jYW5jZWwoKTtcbiAgICBzY2hlZHVsZURyb3BwYWJsZVNjcm9sbC5jYW5jZWwoKTtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQkMSxcbiAgICBzdG9wOiBzdG9wLFxuICAgIHNjcm9sbDogdHJ5U2Nyb2xsXG4gIH07XG59KTtcblxudmFyIGNyZWF0ZUp1bXBTY3JvbGxlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbW92ZSA9IF9yZWYubW92ZSxcbiAgICAgIHNjcm9sbERyb3BwYWJsZSA9IF9yZWYuc2Nyb2xsRHJvcHBhYmxlLFxuICAgICAgc2Nyb2xsV2luZG93ID0gX3JlZi5zY3JvbGxXaW5kb3c7XG5cbiAgdmFyIG1vdmVCeU9mZnNldCA9IGZ1bmN0aW9uIG1vdmVCeU9mZnNldChzdGF0ZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGNsaWVudCA9IGFkZChzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb24sIG9mZnNldCk7XG4gICAgbW92ZSh7XG4gICAgICBjbGllbnQ6IGNsaWVudFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuID0gZnVuY3Rpb24gc2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbihkcm9wcGFibGUsIGNoYW5nZSkge1xuICAgIGlmICghY2FuU2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZSwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxhcCA9IGdldERyb3BwYWJsZU92ZXJsYXAoZHJvcHBhYmxlLCBjaGFuZ2UpO1xuXG4gICAgaWYgKCFvdmVybGFwKSB7XG4gICAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICB2YXIgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuXG4gIHZhciBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuID0gZnVuY3Rpb24gc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbihpc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBjaGFuZ2UpIHtcbiAgICBpZiAoIWlzV2luZG93U2Nyb2xsQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICBpZiAoIWNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxhcCA9IGdldFdpbmRvd092ZXJsYXAodmlld3BvcnQsIGNoYW5nZSk7XG5cbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbFdpbmRvdyhjaGFuZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwgPSBzdWJ0cmFjdChjaGFuZ2UsIG92ZXJsYXApO1xuICAgIHNjcm9sbFdpbmRvdyh3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICB2YXIgcmVtYWluZGVyID0gc3VidHJhY3QoY2hhbmdlLCB3aGF0VGhlV2luZG93Q2FuU2Nyb2xsKTtcbiAgICByZXR1cm4gcmVtYWluZGVyO1xuICB9O1xuXG4gIHZhciBqdW1wU2Nyb2xsZXIgPSBmdW5jdGlvbiBqdW1wU2Nyb2xsZXIoc3RhdGUpIHtcbiAgICB2YXIgcmVxdWVzdCA9IHN0YXRlLnNjcm9sbEp1bXBSZXF1ZXN0O1xuXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc3RpbmF0aW9uID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgICAhZGVzdGluYXRpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcGVyZm9ybSBhIGp1bXAgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZGVzdGluYXRpb24nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGRyb3BwYWJsZVJlbWFpbmRlciA9IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4oc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW2Rlc3RpbmF0aW9uXSwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIWRyb3BwYWJsZVJlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIHZhciB3aW5kb3dSZW1haW5kZXIgPSBzY3JvbGxXaW5kb3dBc011Y2hBc0l0Q2FuKHN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCwgdmlld3BvcnQsIGRyb3BwYWJsZVJlbWFpbmRlcik7XG5cbiAgICBpZiAoIXdpbmRvd1JlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vdmVCeU9mZnNldChzdGF0ZSwgd2luZG93UmVtYWluZGVyKTtcbiAgfTtcblxuICByZXR1cm4ganVtcFNjcm9sbGVyO1xufSk7XG5cbnZhciBjcmVhdGVBdXRvU2Nyb2xsZXIgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHNjcm9sbERyb3BwYWJsZSA9IF9yZWYuc2Nyb2xsRHJvcHBhYmxlLFxuICAgICAgc2Nyb2xsV2luZG93ID0gX3JlZi5zY3JvbGxXaW5kb3csXG4gICAgICBtb3ZlID0gX3JlZi5tb3ZlO1xuICB2YXIgZmx1aWRTY3JvbGxlciA9IGNyZWF0ZUZsdWlkU2Nyb2xsZXIoe1xuICAgIHNjcm9sbFdpbmRvdzogc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZTogc2Nyb2xsRHJvcHBhYmxlXG4gIH0pO1xuICB2YXIganVtcFNjcm9sbCA9IGNyZWF0ZUp1bXBTY3JvbGxlcih7XG4gICAgbW92ZTogbW92ZSxcbiAgICBzY3JvbGxXaW5kb3c6IHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGU6IHNjcm9sbERyb3BwYWJsZVxuICB9KTtcblxuICB2YXIgc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ0ZMVUlEJykge1xuICAgICAgZmx1aWRTY3JvbGxlci5zY3JvbGwoc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBqdW1wU2Nyb2xsKHN0YXRlKTtcbiAgfTtcblxuICB2YXIgc2Nyb2xsZXIgPSB7XG4gICAgc2Nyb2xsOiBzY3JvbGwsXG4gICAgc3RhcnQ6IGZsdWlkU2Nyb2xsZXIuc3RhcnQsXG4gICAgc3RvcDogZmx1aWRTY3JvbGxlci5zdG9wXG4gIH07XG4gIHJldHVybiBzY3JvbGxlcjtcbn0pO1xuXG52YXIgcHJlZml4JDEgPSAnZGF0YS1yYmQnO1xudmFyIGRyYWdIYW5kbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXNlID0gcHJlZml4JDEgKyBcIi1kcmFnLWhhbmRsZVwiO1xuICByZXR1cm4ge1xuICAgIGJhc2U6IGJhc2UsXG4gICAgZHJhZ2dhYmxlSWQ6IGJhc2UgKyBcIi1kcmFnZ2FibGUtaWRcIixcbiAgICBjb250ZXh0SWQ6IGJhc2UgKyBcIi1jb250ZXh0LWlkXCJcbiAgfTtcbn0oKTtcbnZhciBkcmFnZ2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXNlID0gcHJlZml4JDEgKyBcIi1kcmFnZ2FibGVcIjtcbiAgcmV0dXJuIHtcbiAgICBiYXNlOiBiYXNlLFxuICAgIGNvbnRleHRJZDogYmFzZSArIFwiLWNvbnRleHQtaWRcIixcbiAgICBpZDogYmFzZSArIFwiLWlkXCJcbiAgfTtcbn0oKTtcbnZhciBkcm9wcGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXNlID0gcHJlZml4JDEgKyBcIi1kcm9wcGFibGVcIjtcbiAgcmV0dXJuIHtcbiAgICBiYXNlOiBiYXNlLFxuICAgIGNvbnRleHRJZDogYmFzZSArIFwiLWNvbnRleHQtaWRcIixcbiAgICBpZDogYmFzZSArIFwiLWlkXCJcbiAgfTtcbn0oKTtcbnZhciBzY3JvbGxDb250YWluZXIgPSB7XG4gIGNvbnRleHRJZDogcHJlZml4JDEgKyBcIi1zY3JvbGwtY29udGFpbmVyLWNvbnRleHQtaWRcIlxufTtcblxudmFyIG1ha2VHZXRTZWxlY3RvciA9IGZ1bmN0aW9uIG1ha2VHZXRTZWxlY3Rvcihjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIFwiW1wiICsgYXR0cmlidXRlICsgXCI9XFxcIlwiICsgY29udGV4dCArIFwiXFxcIl1cIjtcbiAgfTtcbn07XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiBnZXRTdHlsZXMocnVsZXMsIHByb3BlcnR5KSB7XG4gIHJldHVybiBydWxlcy5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICB2YXIgdmFsdWUgPSBydWxlLnN0eWxlc1twcm9wZXJ0eV07XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGUuc2VsZWN0b3IgKyBcIiB7IFwiICsgdmFsdWUgKyBcIiB9XCI7XG4gIH0pLmpvaW4oJyAnKTtcbn07XG5cbnZhciBub1BvaW50ZXJFdmVudHMgPSAncG9pbnRlci1ldmVudHM6IG5vbmU7JztcbnZhciBnZXRTdHlsZXMkMSA9IChmdW5jdGlvbiAoY29udGV4dElkKSB7XG4gIHZhciBnZXRTZWxlY3RvciA9IG1ha2VHZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuXG4gIHZhciBkcmFnSGFuZGxlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdyYWJDdXJzb3IgPSBcIlxcbiAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcbiAgICAgIGN1cnNvcjogZ3JhYjtcXG4gICAgXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnSGFuZGxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgYWx3YXlzOiBcIlxcbiAgICAgICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTtcXG4gICAgICAgICAgdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb247XFxuICAgICAgICBcIixcbiAgICAgICAgcmVzdGluZzogZ3JhYkN1cnNvcixcbiAgICAgICAgZHJhZ2dpbmc6IG5vUG9pbnRlckV2ZW50cyxcbiAgICAgICAgZHJvcEFuaW1hdGluZzogZ3JhYkN1cnNvclxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgZHJhZ2dhYmxlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRyYW5zaXRpb24gPSBcIlxcbiAgICAgIHRyYW5zaXRpb246IFwiICsgdHJhbnNpdGlvbnMub3V0T2ZUaGVXYXkgKyBcIjtcXG4gICAgXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdG9yOiBnZXRTZWxlY3RvcihkcmFnZ2FibGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBkcmFnZ2luZzogdHJhbnNpdGlvbixcbiAgICAgICAgZHJvcEFuaW1hdGluZzogdHJhbnNpdGlvbixcbiAgICAgICAgdXNlckNhbmNlbDogdHJhbnNpdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgZHJvcHBhYmxlJDEgPSB7XG4gICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyb3BwYWJsZS5jb250ZXh0SWQpLFxuICAgIHN0eWxlczoge1xuICAgICAgYWx3YXlzOiBcIm92ZXJmbG93LWFuY2hvcjogbm9uZTtcIlxuICAgIH1cbiAgfTtcbiAgdmFyIGJvZHkgPSB7XG4gICAgc2VsZWN0b3I6ICdib2R5JyxcbiAgICBzdHlsZXM6IHtcbiAgICAgIGRyYWdnaW5nOiBcIlxcbiAgICAgICAgY3Vyc29yOiBncmFiYmluZztcXG4gICAgICAgIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcXG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICBvdmVyZmxvdy1hbmNob3I6IG5vbmU7XFxuICAgICAgXCJcbiAgICB9XG4gIH07XG4gIHZhciBydWxlcyA9IFtkcmFnZ2FibGUkMSwgZHJhZ0hhbmRsZSQxLCBkcm9wcGFibGUkMSwgYm9keV07XG4gIHJldHVybiB7XG4gICAgYWx3YXlzOiBnZXRTdHlsZXMocnVsZXMsICdhbHdheXMnKSxcbiAgICByZXN0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdyZXN0aW5nJyksXG4gICAgZHJhZ2dpbmc6IGdldFN0eWxlcyhydWxlcywgJ2RyYWdnaW5nJyksXG4gICAgZHJvcEFuaW1hdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJvcEFuaW1hdGluZycpLFxuICAgIHVzZXJDYW5jZWw6IGdldFN0eWxlcyhydWxlcywgJ3VzZXJDYW5jZWwnKVxuICB9O1xufSk7XG5cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxudmFyIGdldEhlYWQgPSBmdW5jdGlvbiBnZXRIZWFkKCkge1xuICB2YXIgaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgIWhlYWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCB0aGUgaGVhZCB0byBhcHBlbmQgYSBzdHlsZSB0bycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGhlYWQ7XG59O1xuXG52YXIgY3JlYXRlU3R5bGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWwobm9uY2UpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBpZiAobm9uY2UpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG5cbiAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIHJldHVybiBlbDtcbn07XG5cbmZ1bmN0aW9uIHVzZVN0eWxlTWFyc2hhbChjb250ZXh0SWQsIG5vbmNlKSB7XG4gIHZhciBzdHlsZXMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0U3R5bGVzJDEoY29udGV4dElkKTtcbiAgfSwgW2NvbnRleHRJZF0pO1xuICB2YXIgYWx3YXlzUmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgZHluYW1pY1JlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNldER5bmFtaWNTdHlsZSA9IHVzZUNhbGxiYWNrKG1lbW9pemVPbmUoZnVuY3Rpb24gKHByb3Bvc2VkKSB7XG4gICAgdmFyIGVsID0gZHluYW1pY1JlZi5jdXJyZW50O1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzZXQgZHluYW1pYyBzdHlsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgZWwudGV4dENvbnRlbnQgPSBwcm9wb3NlZDtcbiAgfSksIFtdKTtcbiAgdmFyIHNldEFsd2F5c1N0eWxlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHByb3Bvc2VkKSB7XG4gICAgdmFyIGVsID0gYWx3YXlzUmVmLmN1cnJlbnQ7XG4gICAgIWVsID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNldCBkeW5hbWljIHN0eWxlIGVsZW1lbnQgaWYgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICEoIWFsd2F5c1JlZi5jdXJyZW50ICYmICFkeW5hbWljUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnc3R5bGUgZWxlbWVudHMgYWxyZWFkeSBtb3VudGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBhbHdheXMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICB2YXIgZHluYW1pYyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIGFsd2F5c1JlZi5jdXJyZW50ID0gYWx3YXlzO1xuICAgIGR5bmFtaWNSZWYuY3VycmVudCA9IGR5bmFtaWM7XG4gICAgYWx3YXlzLnNldEF0dHJpYnV0ZShwcmVmaXgkMSArIFwiLWFsd2F5c1wiLCBjb250ZXh0SWQpO1xuICAgIGR5bmFtaWMuc2V0QXR0cmlidXRlKHByZWZpeCQxICsgXCItZHluYW1pY1wiLCBjb250ZXh0SWQpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChhbHdheXMpO1xuICAgIGdldEhlYWQoKS5hcHBlbmRDaGlsZChkeW5hbWljKTtcbiAgICBzZXRBbHdheXNTdHlsZShzdHlsZXMuYWx3YXlzKTtcbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHJlZikge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICAhY3VycmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCB1bm1vdW50IHJlZiBhcyBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICBnZXRIZWFkKCkucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHJlbW92ZShhbHdheXNSZWYpO1xuICAgICAgcmVtb3ZlKGR5bmFtaWNSZWYpO1xuICAgIH07XG4gIH0sIFtub25jZSwgc2V0QWx3YXlzU3R5bGUsIHNldER5bmFtaWNTdHlsZSwgc3R5bGVzLmFsd2F5cywgc3R5bGVzLnJlc3RpbmcsIGNvbnRleHRJZF0pO1xuICB2YXIgZHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJhZ2dpbmcpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJhZ2dpbmddKTtcbiAgdmFyIGRyb3BwaW5nID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChyZWFzb24gPT09ICdEUk9QJykge1xuICAgICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcm9wQW5pbWF0aW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnVzZXJDYW5jZWwpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJvcEFuaW1hdGluZywgc3R5bGVzLnVzZXJDYW5jZWxdKTtcbiAgdmFyIHJlc3RpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkeW5hbWljUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXREeW5hbWljU3R5bGUoc3R5bGVzLnJlc3RpbmcpO1xuICB9LCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMucmVzdGluZ10pO1xuICB2YXIgbWFyc2hhbCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkcmFnZ2luZzogZHJhZ2dpbmcsXG4gICAgICBkcm9wcGluZzogZHJvcHBpbmcsXG4gICAgICByZXN0aW5nOiByZXN0aW5nXG4gICAgfTtcbiAgfSwgW2RyYWdnaW5nLCBkcm9wcGluZywgcmVzdGluZ10pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxudmFyIGdldFdpbmRvd0Zyb21FbCA9IChmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsICYmIGVsLm93bmVyRG9jdW1lbnQgPyBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufSk7XG5cbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ2V0V2luZG93RnJvbUVsKGVsKS5IVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICB2YXIgc2VsZWN0b3IgPSBcIltcIiArIGRyYWdIYW5kbGUuY29udGV4dElkICsgXCI9XFxcIlwiICsgY29udGV4dElkICsgXCJcXFwiXVwiO1xuICB2YXIgcG9zc2libGUgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcblxuICBpZiAoIXBvc3NpYmxlLmxlbmd0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJVbmFibGUgdG8gZmluZCBhbnkgZHJhZyBoYW5kbGVzIGluIHRoZSBjb250ZXh0IFxcXCJcIiArIGNvbnRleHRJZCArIFwiXFxcIlwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBoYW5kbGUgPSBmaW5kKHBvc3NpYmxlLCBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG5cbiAgaWYgKCFoYW5kbGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGUgd2l0aCBpZCBcXFwiXCIgKyBkcmFnZ2FibGVJZCArIFwiXFxcIiBhcyBubyBoYW5kbGUgd2l0aCBhIG1hdGNoaW5nIGlkIHdhcyBmb3VuZFwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbmVlZHMgdG8gYmUgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdXNlRm9jdXNNYXJzaGFsKGNvbnRleHRJZCkge1xuICB2YXIgZW50cmllc1JlZiA9IHVzZVJlZih7fSk7XG4gIHZhciByZWNvcmRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciByZXN0b3JlRm9jdXNGcmFtZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGlzTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciByZWdpc3RlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHJlZ2lzdGVyKGlkLCBmb2N1cykge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGZvY3VzOiBmb2N1c1xuICAgIH07XG4gICAgZW50cmllc1JlZi5jdXJyZW50W2lkXSA9IGVudHJ5O1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzUmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgY3VycmVudCA9IGVudHJpZXNbaWRdO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gZW50cnkpIHtcbiAgICAgICAgZGVsZXRlIGVudHJpZXNbaWRdO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIHRyeUdpdmVGb2N1cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeUdpdmVGb2N1cyh0cnlHaXZlRm9jdXNUbykge1xuICAgIHZhciBoYW5kbGUgPSBmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIHRyeUdpdmVGb2N1c1RvKTtcblxuICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICBoYW5kbGUuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFtjb250ZXh0SWRdKTtcbiAgdmFyIHRyeVNoaWZ0UmVjb3JkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U2hpZnRSZWNvcmQocHJldmlvdXMsIHJlZGlyZWN0VG8pIHtcbiAgICBpZiAocmVjb3JkUmVmLmN1cnJlbnQgPT09IHByZXZpb3VzKSB7XG4gICAgICByZWNvcmRSZWYuY3VycmVudCA9IHJlZGlyZWN0VG87XG4gICAgfVxuICB9LCBbXSk7XG4gIHZhciB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCkge1xuICAgIGlmIChyZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB2YXIgcmVjb3JkID0gcmVjb3JkUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgdHJ5R2l2ZUZvY3VzKHJlY29yZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFt0cnlHaXZlRm9jdXNdKTtcbiAgdmFyIHRyeVJlY29yZEZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVjb3JkRm9jdXMoaWQpIHtcbiAgICByZWNvcmRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzZWQuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpICE9PSBpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlY29yZFJlZi5jdXJyZW50ID0gaWQ7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jdGlvbiBjbGVhckZyYW1lT25Vbm1vdW50KCkge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHZhciBmcmFtZUlkID0gcmVzdG9yZUZvY3VzRnJhbWVSZWYuY3VycmVudDtcblxuICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgbWFyc2hhbCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlcjogcmVnaXN0ZXIsXG4gICAgICB0cnlSZWNvcmRGb2N1czogdHJ5UmVjb3JkRm9jdXMsXG4gICAgICB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZDogdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsXG4gICAgICB0cnlTaGlmdFJlY29yZDogdHJ5U2hpZnRSZWNvcmRcbiAgICB9O1xuICB9LCBbcmVnaXN0ZXIsIHRyeVJlY29yZEZvY3VzLCB0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCwgdHJ5U2hpZnRSZWNvcmRdKTtcbiAgcmV0dXJuIG1hcnNoYWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZ2lzdHJ5KCkge1xuICB2YXIgZW50cmllcyA9IHtcbiAgICBkcmFnZ2FibGVzOiB7fSxcbiAgICBkcm9wcGFibGVzOiB7fVxuICB9O1xuICB2YXIgc3Vic2NyaWJlcnMgPSBbXTtcblxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2IpIHtcbiAgICBzdWJzY3JpYmVycy5wdXNoKGNiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICB2YXIgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNiKTtcblxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRHJhZ2dhYmxlQnlJZChpZCkge1xuICAgIHJldHVybiBlbnRyaWVzLmRyYWdnYWJsZXNbaWRdIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREcmFnZ2FibGVCeUlkKGlkKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZERyYWdnYWJsZUJ5SWQoaWQpO1xuICAgICFlbnRyeSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJDYW5ub3QgZmluZCBkcmFnZ2FibGUgZW50cnkgd2l0aCBpZCBbXCIgKyBpZCArIFwiXVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgdmFyIGRyYWdnYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZW50cnkpIHtcbiAgICAgIGVudHJpZXMuZHJhZ2dhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmlkXSA9IGVudHJ5O1xuICAgICAgbm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ0FERElUSU9OJyxcbiAgICAgICAgdmFsdWU6IGVudHJ5XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGVudHJ5LCBsYXN0KSB7XG4gICAgICB2YXIgY3VycmVudCA9IGVudHJpZXMuZHJhZ2dhYmxlc1tsYXN0LmRlc2NyaXB0b3IuaWRdO1xuXG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudC51bmlxdWVJZCAhPT0gZW50cnkudW5pcXVlSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG4gICAgICBlbnRyaWVzLmRyYWdnYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXIoZW50cnkpIHtcbiAgICAgIHZhciBkcmFnZ2FibGVJZCA9IGVudHJ5LmRlc2NyaXB0b3IuaWQ7XG4gICAgICB2YXIgY3VycmVudCA9IGZpbmREcmFnZ2FibGVCeUlkKGRyYWdnYWJsZUlkKTtcblxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGVudHJpZXMuZHJhZ2dhYmxlc1tkcmFnZ2FibGVJZF07XG4gICAgICBub3RpZnkoe1xuICAgICAgICB0eXBlOiAnUkVNT1ZBTCcsXG4gICAgICAgIHZhbHVlOiBlbnRyeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcmFnZ2FibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJhZ2dhYmxlQnlJZCxcbiAgICBleGlzdHM6IGZ1bmN0aW9uIGV4aXN0cyhpZCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZmluZERyYWdnYWJsZUJ5SWQoaWQpKTtcbiAgICB9LFxuICAgIGdldEFsbEJ5VHlwZTogZnVuY3Rpb24gZ2V0QWxsQnlUeXBlKHR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMoZW50cmllcy5kcmFnZ2FibGVzKS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZERyb3BwYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcm9wcGFibGVzW2lkXSB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RHJvcHBhYmxlQnlJZChpZCkge1xuICAgIHZhciBlbnRyeSA9IGZpbmREcm9wcGFibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQ2Fubm90IGZpbmQgZHJvcHBhYmxlIGVudHJ5IHdpdGggaWQgW1wiICsgaWQgKyBcIl1cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuXG4gIHZhciBkcm9wcGFibGVBUEkgPSB7XG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGVudHJ5KSB7XG4gICAgICBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXIoZW50cnkpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZmluZERyb3BwYWJsZUJ5SWQoZW50cnkuZGVzY3JpcHRvci5pZCk7XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS51bmlxdWVJZCAhPT0gY3VycmVudC51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF07XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcm9wcGFibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJvcHBhYmxlQnlJZCxcbiAgICBleGlzdHM6IGZ1bmN0aW9uIGV4aXN0cyhpZCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZmluZERyb3BwYWJsZUJ5SWQoaWQpKTtcbiAgICB9LFxuICAgIGdldEFsbEJ5VHlwZTogZnVuY3Rpb24gZ2V0QWxsQnlUeXBlKHR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMoZW50cmllcy5kcm9wcGFibGVzKS5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgZW50cmllcy5kcmFnZ2FibGVzID0ge307XG4gICAgZW50cmllcy5kcm9wcGFibGVzID0ge307XG4gICAgc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGVBUEksXG4gICAgZHJvcHBhYmxlOiBkcm9wcGFibGVBUEksXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgY2xlYW46IGNsZWFuXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVJlZ2lzdHJ5KCkge1xuICB2YXIgcmVnaXN0cnkgPSB1c2VNZW1vKGNyZWF0ZVJlZ2lzdHJ5LCBbXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVnaXN0cnkuY2xlYW4pO1xuICAgIH07XG4gIH0sIFtyZWdpc3RyeV0pO1xuICByZXR1cm4gcmVnaXN0cnk7XG59XG5cbnZhciBTdG9yZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG52YXIgZ2V0Qm9keUVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICFib2R5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgZG9jdW1lbnQuYm9keScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGJvZHk7XG59KTtcblxudmFyIHZpc3VhbGx5SGlkZGVuID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgd2lkdGg6ICcxcHgnLFxuICBoZWlnaHQ6ICcxcHgnLFxuICBtYXJnaW46ICctMXB4JyxcbiAgYm9yZGVyOiAnMCcsXG4gIHBhZGRpbmc6ICcwJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICdjbGlwLXBhdGgnOiAnaW5zZXQoMTAwJSknXG59O1xuXG52YXIgZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZChjb250ZXh0SWQpIHtcbiAgcmV0dXJuIFwicmJkLWFubm91bmNlbWVudC1cIiArIGNvbnRleHRJZDtcbn07XG5mdW5jdGlvbiB1c2VBbm5vdW5jZXIoY29udGV4dElkKSB7XG4gIHZhciBpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRJZChjb250ZXh0SWQpO1xuICB9LCBbY29udGV4dElkXSk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XG5cbiAgICBfZXh0ZW5kcyhlbC5zdHlsZSwgdmlzdWFsbHlIaWRkZW4pO1xuXG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuXG4gICAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsID09PSByZWYuY3VycmVudCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2lkXSk7XG4gIHZhciBhbm5vdW5jZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdmFyIGVsID0gcmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgQSBzY3JlZW4gcmVhZGVyIG1lc3NhZ2Ugd2FzIHRyeWluZyB0byBiZSBhbm5vdW5jZWQgYnV0IGl0IHdhcyB1bmFibGUgdG8gZG8gc28uXFxuICAgICAgVGhpcyBjYW4gb2NjdXIgaWYgeW91IHVubW91bnQgeW91ciA8RHJhZ0Ryb3BDb250ZXh0IC8+IGluIHlvdXIgb25EcmFnRW5kLlxcbiAgICAgIENvbnNpZGVyIGNhbGxpbmcgcHJvdmlkZWQuYW5ub3VuY2UoKSBiZWZvcmUgdGhlIHVubW91bnQgc28gdGhhdCB0aGUgaW5zdHJ1Y3Rpb24gd2lsbFxcbiAgICAgIG5vdCBiZSBsb3N0IGZvciB1c2VycyByZWx5aW5nIG9uIGEgc2NyZWVuIHJlYWRlci5cXG5cXG4gICAgICBNZXNzYWdlIG5vdCBwYXNzZWQgdG8gc2NyZWVuIHJlYWRlcjpcXG5cXG4gICAgICBcXFwiXCIgKyBtZXNzYWdlICsgXCJcXFwiXFxuICAgIFwiKSA6IHZvaWQgMDtcbiAgfSwgW10pO1xuICByZXR1cm4gYW5ub3VuY2U7XG59XG5cbnZhciBjb3VudCA9IDA7XG52YXIgZGVmYXVsdHMgPSB7XG4gIHNlcGFyYXRvcjogJzo6J1xufTtcbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb3VudCA9IDA7XG59XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChwcmVmaXgsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cztcbiAgfVxuXG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIG9wdGlvbnMuc2VwYXJhdG9yICsgY291bnQrKztcbiAgfSwgW29wdGlvbnMuc2VwYXJhdG9yLCBwcmVmaXhdKTtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudElkKF9yZWYpIHtcbiAgdmFyIGNvbnRleHRJZCA9IF9yZWYuY29udGV4dElkLFxuICAgICAgdW5pcXVlSWQgPSBfcmVmLnVuaXF1ZUlkO1xuICByZXR1cm4gXCJyYmQtaGlkZGVuLXRleHQtXCIgKyBjb250ZXh0SWQgKyBcIi1cIiArIHVuaXF1ZUlkO1xufVxuZnVuY3Rpb24gdXNlSGlkZGVuVGV4dEVsZW1lbnQoX3JlZjIpIHtcbiAgdmFyIGNvbnRleHRJZCA9IF9yZWYyLmNvbnRleHRJZCxcbiAgICAgIHRleHQgPSBfcmVmMi50ZXh0O1xuICB2YXIgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnaGlkZGVuLXRleHQnLCB7XG4gICAgc2VwYXJhdG9yOiAnLSdcbiAgfSk7XG4gIHZhciBpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50SWQoe1xuICAgICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgICB1bmlxdWVJZDogdW5pcXVlSWRcbiAgICB9KTtcbiAgfSwgW3VuaXF1ZUlkLCBjb250ZXh0SWRdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB2YXIgYm9keSA9IGdldEJvZHlFbGVtZW50KCk7XG5cbiAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaWQsIHRleHRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG52YXIgQXBwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuXHRyZWFjdDogXCJeMTYuOC41IHx8IF4xNy4wLjAgfHwgXjE4LjAuMFwiLFxuXHRcInJlYWN0LWRvbVwiOiBcIl4xNi44LjUgfHwgXjE3LjAuMCB8fCBeMTguMC4wXCJcbn07XG5cbnZhciBzZW12ZXIgPSAvKFxcZCspXFwuKFxcZCspXFwuKFxcZCspLztcblxudmFyIGdldFZlcnNpb24gPSBmdW5jdGlvbiBnZXRWZXJzaW9uKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBzZW12ZXIuZXhlYyh2YWx1ZSk7XG4gICEocmVzdWx0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIlVuYWJsZSB0byBwYXJzZSBSZWFjdCB2ZXJzaW9uIFwiICsgdmFsdWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG1ham9yID0gTnVtYmVyKHJlc3VsdFsxXSk7XG4gIHZhciBtaW5vciA9IE51bWJlcihyZXN1bHRbMl0pO1xuICB2YXIgcGF0Y2ggPSBOdW1iZXIocmVzdWx0WzNdKTtcbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogbWFqb3IsXG4gICAgbWlub3I6IG1pbm9yLFxuICAgIHBhdGNoOiBwYXRjaCxcbiAgICByYXc6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgaXNTYXRpc2ZpZWQgPSBmdW5jdGlvbiBpc1NhdGlzZmllZChleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhY3R1YWwubWFqb3IgPiBleHBlY3RlZC5tYWpvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFjdHVhbC5tYWpvciA8IGV4cGVjdGVkLm1ham9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFjdHVhbC5taW5vciA+IGV4cGVjdGVkLm1pbm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYWN0dWFsLm1pbm9yIDwgZXhwZWN0ZWQubWlub3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYWN0dWFsLnBhdGNoID49IGV4cGVjdGVkLnBhdGNoO1xufTtcblxudmFyIGNoZWNrUmVhY3RWZXJzaW9uID0gKGZ1bmN0aW9uIChwZWVyRGVwVmFsdWUsIGFjdHVhbFZhbHVlKSB7XG4gIHZhciBwZWVyRGVwID0gZ2V0VmVyc2lvbihwZWVyRGVwVmFsdWUpO1xuICB2YXIgYWN0dWFsID0gZ2V0VmVyc2lvbihhY3R1YWxWYWx1ZSk7XG5cbiAgaWYgKGlzU2F0aXNmaWVkKHBlZXJEZXAsIGFjdHVhbCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgIFJlYWN0IHZlcnNpb246IFtcIiArIGFjdHVhbC5yYXcgKyBcIl1cXG4gICAgZG9lcyBub3Qgc2F0aXNmeSBleHBlY3RlZCBwZWVyIGRlcGVuZGVuY3kgdmVyc2lvbjogW1wiICsgcGVlckRlcC5yYXcgKyBcIl1cXG5cXG4gICAgVGhpcyBjYW4gcmVzdWx0IGluIHJ1biB0aW1lIGJ1Z3MsIGFuZCBldmVuIGZhdGFsIGNyYXNoZXNcXG4gIFwiKSA6IHZvaWQgMDtcbn0pO1xuXG52YXIgc3VmZml4ID0gXCJcXG4gIFdlIGV4cGVjdCBhIGh0bWw1IGRvY3R5cGU6IDwhZG9jdHlwZSBodG1sPlxcbiAgVGhpcyBpcyB0byBlbnN1cmUgY29uc2lzdGVudCBicm93c2VyIGxheW91dCBhbmQgbWVhc3VyZW1lbnRcXG5cXG4gIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9ibG9iL21hc3Rlci9kb2NzL2d1aWRlcy9kb2N0eXBlLm1kXFxuXCI7XG52YXIgY2hlY2tEb2N0eXBlID0gKGZ1bmN0aW9uIChkb2MpIHtcbiAgdmFyIGRvY3R5cGUgPSBkb2MuZG9jdHlwZTtcblxuICBpZiAoIWRvY3R5cGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgTm8gPCFkb2N0eXBlIGh0bWw+IGZvdW5kLlxcblxcbiAgICAgIFwiICsgc3VmZml4ICsgXCJcXG4gICAgXCIpIDogdm9pZCAwO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkb2N0eXBlLm5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBmb3VuZDogKFwiICsgZG9jdHlwZS5uYW1lICsgXCIpXFxuXFxuICAgICAgXCIgKyBzdWZmaXggKyBcIlxcbiAgICBcIikgOiB2b2lkIDA7XG4gIH1cblxuICBpZiAoZG9jdHlwZS5wdWJsaWNJZCAhPT0gJycpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgICAgVW5leHBlY3RlZCA8IWRvY3R5cGU+IHB1YmxpY0lkIGZvdW5kOiAoXCIgKyBkb2N0eXBlLnB1YmxpY0lkICsgXCIpXFxuICAgICAgQSBodG1sNSBkb2N0eXBlIGRvZXMgbm90IGhhdmUgYSBwdWJsaWNJZFxcblxcbiAgICAgIFwiICsgc3VmZml4ICsgXCJcXG4gICAgXCIpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdXNlRGV2KHVzZUhvb2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1c2VIb29rKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlRGV2U2V0dXBXYXJuaW5nKGZuLCBpbnB1dHMpIHtcbiAgdXNlRGV2KGZ1bmN0aW9uICgpIHtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoXCJcXG4gICAgICAgICAgQSBzZXR1cCBwcm9ibGVtIHdhcyBlbmNvdW50ZXJlZC5cXG5cXG4gICAgICAgICAgPiBcIiArIGUubWVzc2FnZSArIFwiXFxuICAgICAgICBcIik7XG4gICAgICB9XG4gICAgfSwgaW5wdXRzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN0YXJ0dXBWYWxpZGF0aW9uKCkge1xuICB1c2VEZXZTZXR1cFdhcm5pbmcoZnVuY3Rpb24gKCkge1xuICAgIGNoZWNrUmVhY3RWZXJzaW9uKHBlZXJEZXBlbmRlbmNpZXMucmVhY3QsIFJlYWN0LnZlcnNpb24pO1xuICAgIGNoZWNrRG9jdHlwZShkb2N1bWVudCk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlUHJldmlvdXMoY3VycmVudCkge1xuICB2YXIgcmVmID0gdXNlUmVmKGN1cnJlbnQpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZi5jdXJyZW50ID0gY3VycmVudDtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGxvY2sgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGlzQ2xhaW1lZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbihsb2NrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsb2NrO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhaW0oYWJhbmRvbikge1xuICAgICEhbG9jayA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjbGFpbSBsb2NrIGFzIGl0IGlzIGFscmVhZHkgY2xhaW1lZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgbmV3TG9jayA9IHtcbiAgICAgIGFiYW5kb246IGFiYW5kb25cbiAgICB9O1xuICAgIGxvY2sgPSBuZXdMb2NrO1xuICAgIHJldHVybiBuZXdMb2NrO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVsZWFzZSgpIHtcbiAgICAhbG9jayA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCByZWxlYXNlIGxvY2sgd2hlbiB0aGVyZSBpcyBubyBsb2NrJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGxvY2sgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5QWJhbmRvbigpIHtcbiAgICBpZiAobG9jaykge1xuICAgICAgbG9jay5hYmFuZG9uKCk7XG4gICAgICByZWxlYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0NsYWltZWQ6IGlzQ2xhaW1lZCxcbiAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgY2xhaW06IGNsYWltLFxuICAgIHJlbGVhc2U6IHJlbGVhc2UsXG4gICAgdHJ5QWJhbmRvbjogdHJ5QWJhbmRvblxuICB9O1xufVxuXG52YXIgdGFiID0gOTtcbnZhciBlbnRlciA9IDEzO1xudmFyIGVzY2FwZSA9IDI3O1xudmFyIHNwYWNlID0gMzI7XG52YXIgcGFnZVVwID0gMzM7XG52YXIgcGFnZURvd24gPSAzNDtcbnZhciBlbmQgPSAzNTtcbnZhciBob21lID0gMzY7XG52YXIgYXJyb3dMZWZ0ID0gMzc7XG52YXIgYXJyb3dVcCA9IDM4O1xudmFyIGFycm93UmlnaHQgPSAzOTtcbnZhciBhcnJvd0Rvd24gPSA0MDtcblxudmFyIF9wcmV2ZW50ZWRLZXlzO1xudmFyIHByZXZlbnRlZEtleXMgPSAoX3ByZXZlbnRlZEtleXMgPSB7fSwgX3ByZXZlbnRlZEtleXNbZW50ZXJdID0gdHJ1ZSwgX3ByZXZlbnRlZEtleXNbdGFiXSA9IHRydWUsIF9wcmV2ZW50ZWRLZXlzKTtcbnZhciBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMgPSAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmIChwcmV2ZW50ZWRLZXlzW2V2ZW50LmtleUNvZGVdKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufSk7XG5cbnZhciBzdXBwb3J0ZWRFdmVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXNlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlcyA9IFtiYXNlLCBcIm1zXCIgKyBiYXNlLCBcIndlYmtpdFwiICsgYmFzZSwgXCJtb3pcIiArIGJhc2UsIFwib1wiICsgYmFzZV07XG4gIHZhciBzdXBwb3J0ZWQgPSBmaW5kKGNhbmRpZGF0ZXMsIGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICByZXR1cm4gXCJvblwiICsgZXZlbnROYW1lIGluIGRvY3VtZW50O1xuICB9KTtcbiAgcmV0dXJuIHN1cHBvcnRlZCB8fCBiYXNlO1xufSgpO1xuXG52YXIgcHJpbWFyeUJ1dHRvbiA9IDA7XG52YXIgc2xvcHB5Q2xpY2tUaHJlc2hvbGQgPSA1O1xuXG5mdW5jdGlvbiBpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQob3JpZ2luYWwsIGN1cnJlbnQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGN1cnJlbnQueCAtIG9yaWdpbmFsLngpID49IHNsb3BweUNsaWNrVGhyZXNob2xkIHx8IE1hdGguYWJzKGN1cnJlbnQueSAtIG9yaWdpbmFsLnkpID49IHNsb3BweUNsaWNrVGhyZXNob2xkO1xufVxuXG52YXIgaWRsZSQxID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG5cbmZ1bmN0aW9uIGdldENhcHR1cmVCaW5kaW5ncyhfcmVmKSB7XG4gIHZhciBjYW5jZWwgPSBfcmVmLmNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZCA9IF9yZWYuY29tcGxldGVkLFxuICAgICAgZ2V0UGhhc2UgPSBfcmVmLmdldFBoYXNlLFxuICAgICAgc2V0UGhhc2UgPSBfcmVmLnNldFBoYXNlO1xuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdtb3VzZW1vdmUnLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbixcbiAgICAgICAgICBjbGllbnRYID0gZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcblxuICAgICAgaWYgKGJ1dHRvbiAhPT0gcHJpbWFyeUJ1dHRvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHBoYXNlLmFjdGlvbnMubW92ZShwb2ludCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGJlIElETEUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgcGVuZGluZyA9IHBoYXNlLnBvaW50O1xuXG4gICAgICBpZiAoIWlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZChwZW5kaW5nLCBwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGFjdGlvbnMgPSBwaGFzZS5hY3Rpb25zLmZsdWlkTGlmdChwb2ludCk7XG4gICAgICBzZXRQaGFzZSh7XG4gICAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICAgIGFjdGlvbnM6IGFjdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNldXAnLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcblxuICAgICAgaWYgKHBoYXNlLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgdmFyIHBoYXNlID0gZ2V0UGhhc2UoKTtcblxuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyhldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIHBoYXNlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocGhhc2UuYWN0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cblxuZnVuY3Rpb24gdXNlTW91c2VTZW5zb3IoYXBpKSB7XG4gIHZhciBwaGFzZVJlZiA9IHVzZVJlZihpZGxlJDEpO1xuICB2YXIgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3ApO1xuICB2YXIgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgICAgZm46IGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gcHJpbWFyeUJ1dHRvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdnYWJsZUlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuXG4gICAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghYWN0aW9ucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgICAgfTtcbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FwaV0pO1xuICB2YXIgcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50TmFtZTogJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLFxuICAgICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFwaS5maW5kT3B0aW9uc0ZvckRyYWdnYWJsZShpZCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFwaS5jYW5HZXRMb2NrKGlkKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FwaV0pO1xuICB2YXIgbGlzdGVuRm9yQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGxpc3RlbkZvckNhcHR1cmUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddLCBvcHRpb25zKTtcbiAgfSwgW3ByZXZlbnRGb3JjZVByZXNzQmluZGluZywgc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICB2YXIgc3RvcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gaWRsZSQxO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICB9LCBbbGlzdGVuRm9yQ2FwdHVyZV0pO1xuICB2YXIgY2FuY2VsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgc3RvcCgpO1xuXG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuYWJvcnQoKTtcbiAgICB9XG4gIH0sIFtzdG9wXSk7XG4gIHZhciBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGJpbmRpbmdzID0gZ2V0Q2FwdHVyZUJpbmRpbmdzKHtcbiAgICAgIGNhbmNlbDogY2FuY2VsLFxuICAgICAgY29tcGxldGVkOiBzdG9wLFxuICAgICAgZ2V0UGhhc2U6IGZ1bmN0aW9uIGdldFBoYXNlKCkge1xuICAgICAgICByZXR1cm4gcGhhc2VSZWYuY3VycmVudDtcbiAgICAgIH0sXG4gICAgICBzZXRQaGFzZTogZnVuY3Rpb24gc2V0UGhhc2UocGhhc2UpIHtcbiAgICAgICAgcGhhc2VSZWYuY3VycmVudCA9IHBoYXNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIGJpbmRpbmdzLCBvcHRpb25zKTtcbiAgfSwgW2NhbmNlbCwgc3RvcF0pO1xuICB2YXIgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKHBoYXNlUmVmLmN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0ge1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgYWN0aW9uczogYWN0aW9uc1xuICAgIH07XG4gICAgYmluZENhcHR1cmluZ0V2ZW50cygpO1xuICB9LCBbYmluZENhcHR1cmluZ0V2ZW50c10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxudmFyIF9zY3JvbGxKdW1wS2V5cztcblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxudmFyIHNjcm9sbEp1bXBLZXlzID0gKF9zY3JvbGxKdW1wS2V5cyA9IHt9LCBfc2Nyb2xsSnVtcEtleXNbcGFnZURvd25dID0gdHJ1ZSwgX3Njcm9sbEp1bXBLZXlzW3BhZ2VVcF0gPSB0cnVlLCBfc2Nyb2xsSnVtcEtleXNbaG9tZV0gPSB0cnVlLCBfc2Nyb2xsSnVtcEtleXNbZW5kXSA9IHRydWUsIF9zY3JvbGxKdW1wS2V5cyk7XG5cbmZ1bmN0aW9uIGdldERyYWdnaW5nQmluZGluZ3MoYWN0aW9ucywgc3RvcCkge1xuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuY2FuY2VsKCk7XG4gIH1cblxuICBmdW5jdGlvbiBkcm9wKCkge1xuICAgIHN0b3AoKTtcbiAgICBhY3Rpb25zLmRyb3AoKTtcbiAgfVxuXG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gc3BhY2UpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZHJvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd0Rvd24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlRG93bigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd1VwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZVVwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGFycm93UmlnaHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlUmlnaHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dMZWZ0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZUxlZnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Nyb2xsSnVtcEtleXNbZXZlbnQua2V5Q29kZV0pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcmV2ZW50U3RhbmRhcmRLZXlFdmVudHMoZXZlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ21vdXNlZG93bicsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2V1cCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoc3RhcnQnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Jlc2l6ZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnd2hlZWwnLFxuICAgIGZuOiBjYW5jZWwsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5cbmZ1bmN0aW9uIHVzZUtleWJvYXJkU2Vuc29yKGFwaSkge1xuICB2YXIgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3AkMSk7XG4gIHZhciBzdGFydENhcHR1cmVCaW5kaW5nID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgICAgZm46IGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9PSBzcGFjZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnZ2FibGVJZCA9IGFwaS5maW5kQ2xvc2VzdERyYWdnYWJsZUlkKGV2ZW50KTtcblxuICAgICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZURyYWcgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXByZURyYWcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgaXNDYXB0dXJpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHByZURyYWcuc25hcExpZnQoKTtcbiAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcblxuICAgICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICFpc0NhcHR1cmluZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIGNhcHR1cmluZyBhIGtleWJvYXJkIGRyYWcgd2hlbiBub3QgY2FwdHVyaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICAgIGlzQ2FwdHVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBnZXREcmFnZ2luZ0JpbmRpbmdzKGFjdGlvbnMsIHN0b3ApLCB7XG4gICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYXBpXSk7XG4gIHZhciBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U3RhcnRDYXB0dXJlKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxudmFyIGlkbGUkMiA9IHtcbiAgdHlwZTogJ0lETEUnXG59O1xudmFyIHRpbWVGb3JMb25nUHJlc3MgPSAxMjA7XG52YXIgZm9yY2VQcmVzc1RocmVzaG9sZCA9IDAuMTU7XG5cbmZ1bmN0aW9uIGdldFdpbmRvd0JpbmRpbmdzKF9yZWYpIHtcbiAgdmFyIGNhbmNlbCA9IF9yZWYuY2FuY2VsLFxuICAgICAgZ2V0UGhhc2UgPSBfcmVmLmdldFBoYXNlO1xuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICdvcmllbnRhdGlvbmNoYW5nZScsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdjb250ZXh0bWVudScsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2tleWRvd24nLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gZXNjYXBlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5cbmZ1bmN0aW9uIGdldEhhbmRsZUJpbmRpbmdzKF9yZWYyKSB7XG4gIHZhciBjYW5jZWwgPSBfcmVmMi5jYW5jZWwsXG4gICAgICBjb21wbGV0ZWQgPSBfcmVmMi5jb21wbGV0ZWQsXG4gICAgICBnZXRQaGFzZSA9IF9yZWYyLmdldFBoYXNlO1xuICByZXR1cm4gW3tcbiAgICBldmVudE5hbWU6ICd0b3VjaG1vdmUnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogZnVuY3Rpb24gZm4oZXZlbnQpIHtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBoYXNlLmhhc01vdmVkID0gdHJ1ZTtcbiAgICAgIHZhciBfZXZlbnQkdG91Y2hlcyQgPSBldmVudC50b3VjaGVzWzBdLFxuICAgICAgICAgIGNsaWVudFggPSBfZXZlbnQkdG91Y2hlcyQuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX2V2ZW50JHRvdWNoZXMkLmNsaWVudFk7XG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd0b3VjaGVuZCcsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICB2YXIgcGhhc2UgPSBnZXRQaGFzZSgpO1xuXG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcGhhc2UuYWN0aW9ucy5kcm9wKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hjYW5jZWwnLFxuICAgIGZuOiBmdW5jdGlvbiBmbihldmVudCkge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hmb3JjZWNoYW5nZScsXG4gICAgZm46IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XG4gICAgICB2YXIgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgIShwaGFzZS50eXBlICE9PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuXG4gICAgICBpZiAoIXRvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzRm9yY2VQcmVzcyA9IHRvdWNoLmZvcmNlID49IGZvcmNlUHJlc3NUaHJlc2hvbGQ7XG5cbiAgICAgIGlmICghaXNGb3JjZVByZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZFJlc3BlY3QgPSBwaGFzZS5hY3Rpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgaWYgKHBoYXNlLmhhc01vdmVkKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5cbmZ1bmN0aW9uIHVzZVRvdWNoU2Vuc29yKGFwaSkge1xuICB2YXIgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSQyKTtcbiAgdmFyIHVuYmluZEV2ZW50c1JlZiA9IHVzZVJlZihub29wKTtcbiAgdmFyIGdldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gZ2V0UGhhc2UoKSB7XG4gICAgcmV0dXJuIHBoYXNlUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdmFyIHNldFBoYXNlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gc2V0UGhhc2UocGhhc2UpIHtcbiAgICBwaGFzZVJlZi5jdXJyZW50ID0gcGhhc2U7XG4gIH0sIFtdKTtcbiAgdmFyIHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgICBmbjogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdnYWJsZUlkID0gYXBpLmZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQoZXZlbnQpO1xuXG4gICAgICAgIGlmICghZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWN0aW9ucyA9IGFwaS50cnlHZXRMb2NrKGRyYWdnYWJsZUlkLCBzdG9wLCB7XG4gICAgICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghYWN0aW9ucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgIHZhciBjbGllbnRYID0gdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgICB5OiBjbGllbnRZXG4gICAgICAgIH07XG4gICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICAgIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthcGldKTtcbiAgdmFyIGxpc3RlbkZvckNhcHR1cmUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBsaXN0ZW5Gb3JDYXB0dXJlKCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICB2YXIgc3RvcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IHBoYXNlUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIGNsZWFyVGltZW91dChjdXJyZW50LmxvbmdQcmVzc1RpbWVySWQpO1xuICAgIH1cblxuICAgIHNldFBoYXNlKGlkbGUkMik7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICBsaXN0ZW5Gb3JDYXB0dXJlKCk7XG4gIH0sIFtsaXN0ZW5Gb3JDYXB0dXJlLCBzZXRQaGFzZV0pO1xuICB2YXIgY2FuY2VsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgc3RvcCgpO1xuXG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuYWJvcnQoKTtcbiAgICB9XG4gIH0sIFtzdG9wXSk7XG4gIHZhciBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIGFyZ3MgPSB7XG4gICAgICBjYW5jZWw6IGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlOiBnZXRQaGFzZVxuICAgIH07XG4gICAgdmFyIHVuYmluZFRhcmdldCA9IGJpbmRFdmVudHMod2luZG93LCBnZXRIYW5kbGVCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgdmFyIHVuYmluZFdpbmRvdyA9IGJpbmRFdmVudHMod2luZG93LCBnZXRXaW5kb3dCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG5cbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGZ1bmN0aW9uIHVuYmluZEFsbCgpIHtcbiAgICAgIHVuYmluZFRhcmdldCgpO1xuICAgICAgdW5iaW5kV2luZG93KCk7XG4gICAgfTtcbiAgfSwgW2NhbmNlbCwgZ2V0UGhhc2UsIHN0b3BdKTtcbiAgdmFyIHN0YXJ0RHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydERyYWdnaW5nKCkge1xuICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBzdGFydCBkcmFnZ2luZyBmcm9tIHBoYXNlIFwiICsgcGhhc2UudHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb25zID0gcGhhc2UuYWN0aW9ucy5mbHVpZExpZnQocGhhc2UucG9pbnQpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgaGFzTW92ZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sIFtnZXRQaGFzZSwgc2V0UGhhc2VdKTtcbiAgdmFyIHN0YXJ0UGVuZGluZ0RyYWcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KSB7XG4gICAgIShnZXRQaGFzZSgpLnR5cGUgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBtb3ZlIGZyb20gSURMRSB0byBQRU5ESU5HIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGxvbmdQcmVzc1RpbWVySWQgPSBzZXRUaW1lb3V0KHN0YXJ0RHJhZ2dpbmcsIHRpbWVGb3JMb25nUHJlc3MpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdQRU5ESU5HJyxcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICBsb25nUHJlc3NUaW1lcklkOiBsb25nUHJlc3NUaW1lcklkXG4gICAgfSk7XG4gICAgYmluZENhcHR1cmluZ0V2ZW50cygpO1xuICB9LCBbYmluZENhcHR1cmluZ0V2ZW50cywgZ2V0UGhhc2UsIHNldFBoYXNlLCBzdGFydERyYWdnaW5nXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgbGlzdGVuRm9yQ2FwdHVyZSgpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQoKTtcbiAgICAgIHZhciBwaGFzZSA9IGdldFBoYXNlKCk7XG5cbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBoYXNlLmxvbmdQcmVzc1RpbWVySWQpO1xuICAgICAgICBzZXRQaGFzZShpZGxlJDIpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtnZXRQaGFzZSwgbGlzdGVuRm9yQ2FwdHVyZSwgc2V0UGhhc2VdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiB3ZWJraXRIYWNrKCkge1xuICAgIHZhciB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiB1bmJpbmQ7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlVmFsaWRhdGVTZW5zb3JIb29rcyhzZW5zb3JIb29rcykge1xuICB1c2VEZXYoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2aW91c1JlZiA9IHVzZVByZXZpb3VzKHNlbnNvckhvb2tzKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoZnVuY3Rpb24gKCkge1xuICAgICAgIShwcmV2aW91c1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gc2Vuc29ySG9va3MubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjaGFuZ2UgdGhlIGFtb3VudCBvZiBzZW5zb3IgaG9va3MgYWZ0ZXIgbW91bnRpbmcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgaW50ZXJhY3RpdmVUYWdOYW1lcyA9IHtcbiAgaW5wdXQ6IHRydWUsXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWUsXG4gIHNlbGVjdDogdHJ1ZSxcbiAgb3B0aW9uOiB0cnVlLFxuICBvcHRncm91cDogdHJ1ZSxcbiAgdmlkZW86IHRydWUsXG4gIGF1ZGlvOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudCkge1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhhc0FuSW50ZXJhY3RpdmVUYWcgPSBCb29sZWFuKGludGVyYWN0aXZlVGFnTmFtZXNbY3VycmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCldKTtcblxuICBpZiAoaGFzQW5JbnRlcmFjdGl2ZVRhZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGF0dHJpYnV0ZSA9IGN1cnJlbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcblxuICBpZiAoYXR0cmlidXRlID09PSAndHJ1ZScgfHwgYXR0cmlidXRlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgPT09IHBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudC5wYXJlbnRFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICBpZiAoIWlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KGRyYWdnYWJsZSwgdGFyZ2V0KTtcbn1cblxudmFyIGdldEJvcmRlckJveENlbnRlclBvc2l0aW9uID0gKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZ2V0UmVjdChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkuY2VudGVyO1xufSk7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkVsZW1lbnQ7XG59XG5cbnZhciBzdXBwb3J0ZWRNYXRjaGVzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhc2UgPSAnbWF0Y2hlcyc7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVzID0gW2Jhc2UsICdtc01hdGNoZXNTZWxlY3RvcicsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXTtcbiAgdmFyIHZhbHVlID0gZmluZChjYW5kaWRhdGVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIEVsZW1lbnQucHJvdG90eXBlO1xuICB9KTtcbiAgcmV0dXJuIHZhbHVlIHx8IGJhc2U7XG59KCk7XG5cbmZ1bmN0aW9uIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChlbFtzdXBwb3J0ZWRNYXRjaGVzTmFtZV0oc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbC5wYXJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3QkMShlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbnRleHRJZCkge1xuICByZXR1cm4gXCJbXCIgKyBkcmFnSGFuZGxlLmNvbnRleHRJZCArIFwiPVxcXCJcIiArIGNvbnRleHRJZCArIFwiXFxcIl1cIjtcbn1cblxuZnVuY3Rpb24gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZXZlbnQudGFyZ2V0IG11c3QgYmUgYSBFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICB2YXIgaGFuZGxlID0gY2xvc2VzdCQxKHRhcmdldCwgc2VsZWN0b3IpO1xuXG4gIGlmICghaGFuZGxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzSHRtbEVsZW1lbnQoaGFuZGxlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2RyYWcgaGFuZGxlIG11c3QgYmUgYSBIVE1MRWxlbWVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZnVuY3Rpb24gdHJ5R2V0Q2xvc2VzdERyYWdnYWJsZUlkRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgdmFyIGhhbmRsZSA9IGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcblxuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZS5nZXRBdHRyaWJ1dGUoZHJhZ0hhbmRsZS5kcmFnZ2FibGVJZCk7XG59XG5cbmZ1bmN0aW9uIGZpbmREcmFnZ2FibGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICB2YXIgc2VsZWN0b3IgPSBcIltcIiArIGRyYWdnYWJsZS5jb250ZXh0SWQgKyBcIj1cXFwiXCIgKyBjb250ZXh0SWQgKyBcIlxcXCJdXCI7XG4gIHZhciBwb3NzaWJsZSA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB2YXIgZHJhZ2dhYmxlJDEgPSBmaW5kKHBvc3NpYmxlLCBmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdnYWJsZS5pZCkgPT09IGRyYWdnYWJsZUlkO1xuICB9KTtcblxuICBpZiAoIWRyYWdnYWJsZSQxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzSHRtbEVsZW1lbnQoZHJhZ2dhYmxlJDEpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnRHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBkcmFnZ2FibGUkMTtcbn1cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gX2lzQWN0aXZlKF9yZWYpIHtcbiAgdmFyIGV4cGVjdGVkID0gX3JlZi5leHBlY3RlZCxcbiAgICAgIHBoYXNlID0gX3JlZi5waGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSA9IF9yZWYuaXNMb2NrQWN0aXZlLFxuICAgICAgc2hvdWxkV2FybiA9IF9yZWYuc2hvdWxkV2FybjtcblxuICBpZiAoIWlzTG9ja0FjdGl2ZSgpKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cXG4gICAgICAgIFRoZSBzZW5zb3Igbm8gbG9uZ2VyIGhhcyBhbiBhY3Rpb24gbG9jay5cXG5cXG4gICAgICAgIFRpcHM6XFxuXFxuICAgICAgICAtIFRocm93IGF3YXkgeW91ciBhY3Rpb24gaGFuZGxlcnMgd2hlbiBmb3JjZVN0b3AoKSBpcyBjYWxsZWRcXG4gICAgICAgIC0gQ2hlY2sgYWN0aW9ucy5pc0FjdGl2ZSgpIGlmIHlvdSByZWFsbHkgbmVlZCB0b1xcbiAgICAgIFwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgIT09IHBoYXNlKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cXG4gICAgICAgIFRoZSBhY3Rpb25zIHlvdSB1c2VkIGJlbG9uZyB0byBhbiBvdXRkYXRlZCBwaGFzZVxcblxcbiAgICAgICAgQ3VycmVudCBwaGFzZTogXCIgKyBleHBlY3RlZCArIFwiXFxuICAgICAgICBZb3UgY2FsbGVkIGFuIGFjdGlvbiBmcm9tIG91dGRhdGVkIHBoYXNlOiBcIiArIHBoYXNlICsgXCJcXG5cXG4gICAgICAgIFRpcHM6XFxuXFxuICAgICAgICAtIERvIG5vdCB1c2UgcHJlRHJhZ0FjdGlvbnMgYWN0aW9ucyBhZnRlciBjYWxsaW5nIHByZURyYWdBY3Rpb25zLmxpZnQoKVxcbiAgICAgIFwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2FuU3RhcnQoX3JlZjIpIHtcbiAgdmFyIGxvY2tBUEkgPSBfcmVmMi5sb2NrQVBJLFxuICAgICAgc3RvcmUgPSBfcmVmMi5zdG9yZSxcbiAgICAgIHJlZ2lzdHJ5ID0gX3JlZjIucmVnaXN0cnksXG4gICAgICBkcmFnZ2FibGVJZCA9IF9yZWYyLmRyYWdnYWJsZUlkO1xuXG4gIGlmIChsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmZpbmRCeUlkKGRyYWdnYWJsZUlkKTtcblxuICBpZiAoIWVudHJ5KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlVuYWJsZSB0byBmaW5kIGRyYWdnYWJsZSB3aXRoIGlkOiBcIiArIGRyYWdnYWJsZUlkKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWVudHJ5Lm9wdGlvbnMuaXNFbmFibGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjYW5TdGFydERyYWcoc3RvcmUuZ2V0U3RhdGUoKSwgZHJhZ2dhYmxlSWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHRyeVN0YXJ0KF9yZWYzKSB7XG4gIHZhciBsb2NrQVBJID0gX3JlZjMubG9ja0FQSSxcbiAgICAgIGNvbnRleHRJZCA9IF9yZWYzLmNvbnRleHRJZCxcbiAgICAgIHN0b3JlID0gX3JlZjMuc3RvcmUsXG4gICAgICByZWdpc3RyeSA9IF9yZWYzLnJlZ2lzdHJ5LFxuICAgICAgZHJhZ2dhYmxlSWQgPSBfcmVmMy5kcmFnZ2FibGVJZCxcbiAgICAgIGZvcmNlU2Vuc29yU3RvcCA9IF9yZWYzLmZvcmNlU2Vuc29yU3RvcCxcbiAgICAgIHNvdXJjZUV2ZW50ID0gX3JlZjMuc291cmNlRXZlbnQ7XG4gIHZhciBzaG91bGRTdGFydCA9IGNhblN0YXJ0KHtcbiAgICBsb2NrQVBJOiBsb2NrQVBJLFxuICAgIHN0b3JlOiBzdG9yZSxcbiAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgZHJhZ2dhYmxlSWQ6IGRyYWdnYWJsZUlkXG4gIH0pO1xuXG4gIGlmICghc2hvdWxkU3RhcnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5nZXRCeUlkKGRyYWdnYWJsZUlkKTtcbiAgdmFyIGVsID0gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuXG4gIGlmICghZWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIGVsZW1lbnQgd2l0aCBpZDogXCIgKyBkcmFnZ2FibGVJZCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc291cmNlRXZlbnQgJiYgIWVudHJ5Lm9wdGlvbnMuY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgJiYgaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGVsLCBzb3VyY2VFdmVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsb2NrID0gbG9ja0FQSS5jbGFpbShmb3JjZVNlbnNvclN0b3AgfHwgbm9vcCk7XG4gIHZhciBwaGFzZSA9ICdQUkVfRFJBRyc7XG5cbiAgZnVuY3Rpb24gZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSB7XG4gICAgcmV0dXJuIGVudHJ5Lm9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xvY2tBY3RpdmUoKSB7XG4gICAgcmV0dXJuIGxvY2tBUEkuaXNBY3RpdmUobG9jayk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlEaXNwYXRjaChleHBlY3RlZCwgZ2V0QWN0aW9uKSB7XG4gICAgaWYgKF9pc0FjdGl2ZSh7XG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBwaGFzZTogcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmU6IGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZ2V0QWN0aW9uKCkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyA9IHRyeURpc3BhdGNoLmJpbmQobnVsbCwgJ0RSQUdHSU5HJyk7XG5cbiAgZnVuY3Rpb24gbGlmdCQxKGFyZ3MpIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICAgIHBoYXNlID0gJ0NPTVBMRVRFRCc7XG4gICAgfVxuXG4gICAgaWYgKHBoYXNlICE9PSAnUFJFX0RSQUcnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgICEocGhhc2UgPT09ICdQUkVfRFJBRycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIkNhbm5vdCBsaWZ0IGluIHBoYXNlIFwiICsgcGhhc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBzdG9yZS5kaXNwYXRjaChsaWZ0KGFyZ3MubGlmdEFjdGlvbkFyZ3MpKTtcbiAgICBwaGFzZSA9ICdEUkFHR0lORyc7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2gocmVhc29uLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MuY2xlYW51cCgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5zaG91bGRCbG9ja05leHRDbGljaykge1xuICAgICAgICB2YXIgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICAgICAgZXZlbnROYW1lOiAnY2xpY2snLFxuICAgICAgICAgIGZuOiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XSk7XG4gICAgICAgIHNldFRpbWVvdXQodW5iaW5kKTtcbiAgICAgIH1cblxuICAgICAgY29tcGxldGVkKCk7XG4gICAgICBzdG9yZS5kaXNwYXRjaChkcm9wKHtcbiAgICAgICAgcmVhc29uOiByZWFzb25cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gX2lzQWN0aXZlKHtcbiAgICAgICAgICBleHBlY3RlZDogJ0RSQUdHSU5HJyxcbiAgICAgICAgICBwaGFzZTogcGhhc2UsXG4gICAgICAgICAgaXNMb2NrQWN0aXZlOiBpc0xvY2tBY3RpdmUsXG4gICAgICAgICAgc2hvdWxkV2FybjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgZHJvcDogZnVuY3Rpb24gZHJvcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goJ0RST1AnLCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goJ0NBTkNFTCcsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sIGFyZ3MuYWN0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVpZExpZnQoY2xpZW50U2VsZWN0aW9uKSB7XG4gICAgdmFyIG1vdmUkMSA9IHJhZlNjaGQoZnVuY3Rpb24gKGNsaWVudCkge1xuICAgICAgdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW92ZSh7XG4gICAgICAgICAgY2xpZW50OiBjbGllbnRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgYXBpID0gbGlmdCQxKHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uOiBjbGllbnRTZWxlY3Rpb24sXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ0ZMVUlEJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIHJldHVybiBtb3ZlJDEuY2FuY2VsKCk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBtb3ZlOiBtb3ZlJDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFwaSwge1xuICAgICAgbW92ZTogbW92ZSQxXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzbmFwTGlmdCgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IHtcbiAgICAgIG1vdmVVcDogZnVuY3Rpb24gbW92ZVVwJDEoKSB7XG4gICAgICAgIHJldHVybiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlVXApO1xuICAgICAgfSxcbiAgICAgIG1vdmVSaWdodDogZnVuY3Rpb24gbW92ZVJpZ2h0JDEoKSB7XG4gICAgICAgIHJldHVybiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlUmlnaHQpO1xuICAgICAgfSxcbiAgICAgIG1vdmVEb3duOiBmdW5jdGlvbiBtb3ZlRG93biQxKCkge1xuICAgICAgICByZXR1cm4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZURvd24pO1xuICAgICAgfSxcbiAgICAgIG1vdmVMZWZ0OiBmdW5jdGlvbiBtb3ZlTGVmdCQxKCkge1xuICAgICAgICByZXR1cm4gdHJ5RGlzcGF0Y2hXaGVuRHJhZ2dpbmcobW92ZUxlZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpZnQkMSh7XG4gICAgICBsaWZ0QWN0aW9uQXJnczoge1xuICAgICAgICBpZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbjogZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24oZWwpLFxuICAgICAgICBtb3ZlbWVudE1vZGU6ICdTTkFQJ1xuICAgICAgfSxcbiAgICAgIGNsZWFudXA6IG5vb3AsXG4gICAgICBhY3Rpb25zOiBhY3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydFByZURyYWcoKSB7XG4gICAgdmFyIHNob3VsZFJlbGVhc2UgPSBfaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICBwaGFzZTogcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmU6IGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRSZWxlYXNlKSB7XG4gICAgICBsb2NrQVBJLnJlbGVhc2UoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJlRHJhZyA9IHtcbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gX2lzQWN0aXZlKHtcbiAgICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgICAgaXNMb2NrQWN0aXZlOiBpc0xvY2tBY3RpdmUsXG4gICAgICAgIHNob3VsZFdhcm46IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBmbHVpZExpZnQ6IGZsdWlkTGlmdCxcbiAgICBzbmFwTGlmdDogc25hcExpZnQsXG4gICAgYWJvcnQ6IGFib3J0UHJlRHJhZ1xuICB9O1xuICByZXR1cm4gcHJlRHJhZztcbn1cblxudmFyIGRlZmF1bHRTZW5zb3JzID0gW3VzZU1vdXNlU2Vuc29yLCB1c2VLZXlib2FyZFNlbnNvciwgdXNlVG91Y2hTZW5zb3JdO1xuZnVuY3Rpb24gdXNlU2Vuc29yTWFyc2hhbChfcmVmNCkge1xuICB2YXIgY29udGV4dElkID0gX3JlZjQuY29udGV4dElkLFxuICAgICAgc3RvcmUgPSBfcmVmNC5zdG9yZSxcbiAgICAgIHJlZ2lzdHJ5ID0gX3JlZjQucmVnaXN0cnksXG4gICAgICBjdXN0b21TZW5zb3JzID0gX3JlZjQuY3VzdG9tU2Vuc29ycyxcbiAgICAgIGVuYWJsZURlZmF1bHRTZW5zb3JzID0gX3JlZjQuZW5hYmxlRGVmYXVsdFNlbnNvcnM7XG4gIHZhciB1c2VTZW5zb3JzID0gW10uY29uY2F0KGVuYWJsZURlZmF1bHRTZW5zb3JzID8gZGVmYXVsdFNlbnNvcnMgOiBbXSwgY3VzdG9tU2Vuc29ycyB8fCBbXSk7XG4gIHZhciBsb2NrQVBJID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGUoKTtcbiAgfSlbMF07XG4gIHZhciB0cnlBYmFuZG9uTG9jayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeUFiYW5kb25Mb2NrKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgaWYgKHByZXZpb3VzLmlzRHJhZ2dpbmcgJiYgIWN1cnJlbnQuaXNEcmFnZ2luZykge1xuICAgICAgbG9ja0FQSS50cnlBYmFuZG9uKCk7XG4gICAgfVxuICB9LCBbbG9ja0FQSV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIGxpc3RlblRvU3RvcmUoKSB7XG4gICAgdmFyIHByZXZpb3VzID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2xvY2tBUEksIHN0b3JlLCB0cnlBYmFuZG9uTG9ja10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9ja0FQSS50cnlBYmFuZG9uO1xuICB9LCBbbG9ja0FQSS50cnlBYmFuZG9uXSk7XG4gIHZhciBjYW5HZXRMb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGRyYWdnYWJsZUlkKSB7XG4gICAgcmV0dXJuIGNhblN0YXJ0KHtcbiAgICAgIGxvY2tBUEk6IGxvY2tBUEksXG4gICAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgICBzdG9yZTogc3RvcmUsXG4gICAgICBkcmFnZ2FibGVJZDogZHJhZ2dhYmxlSWRcbiAgICB9KTtcbiAgfSwgW2xvY2tBUEksIHJlZ2lzdHJ5LCBzdG9yZV0pO1xuICB2YXIgdHJ5R2V0TG9jayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChkcmFnZ2FibGVJZCwgZm9yY2VTdG9wLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRyeVN0YXJ0KHtcbiAgICAgIGxvY2tBUEk6IGxvY2tBUEksXG4gICAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2FibGVJZCxcbiAgICAgIGZvcmNlU2Vuc29yU3RvcDogZm9yY2VTdG9wLFxuICAgICAgc291cmNlRXZlbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zb3VyY2VFdmVudCA/IG9wdGlvbnMuc291cmNlRXZlbnQgOiBudWxsXG4gICAgfSk7XG4gIH0sIFtjb250ZXh0SWQsIGxvY2tBUEksIHJlZ2lzdHJ5LCBzdG9yZV0pO1xuICB2YXIgZmluZENsb3Nlc3REcmFnZ2FibGVJZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCk7XG4gIH0sIFtjb250ZXh0SWRdKTtcbiAgdmFyIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmZpbmRCeUlkKGlkKTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeS5vcHRpb25zIDogbnVsbDtcbiAgfSwgW3JlZ2lzdHJ5LmRyYWdnYWJsZV0pO1xuICB2YXIgdHJ5UmVsZWFzZUxvY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlSZWxlYXNlTG9jaygpIHtcbiAgICBpZiAoIWxvY2tBUEkuaXNDbGFpbWVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2NrQVBJLnRyeUFiYW5kb24oKTtcblxuICAgIGlmIChzdG9yZS5nZXRTdGF0ZSgpLnBoYXNlICE9PSAnSURMRScpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEksIHN0b3JlXSk7XG4gIHZhciBpc0xvY2tDbGFpbWVkID0gdXNlQ2FsbGJhY2sobG9ja0FQSS5pc0NsYWltZWQsIFtsb2NrQVBJXSk7XG4gIHZhciBhcGkgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuR2V0TG9jazogY2FuR2V0TG9jayxcbiAgICAgIHRyeUdldExvY2s6IHRyeUdldExvY2ssXG4gICAgICBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkOiBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkLFxuICAgICAgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGU6IGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLFxuICAgICAgdHJ5UmVsZWFzZUxvY2s6IHRyeVJlbGVhc2VMb2NrLFxuICAgICAgaXNMb2NrQ2xhaW1lZDogaXNMb2NrQ2xhaW1lZFxuICAgIH07XG4gIH0sIFtjYW5HZXRMb2NrLCB0cnlHZXRMb2NrLCBmaW5kQ2xvc2VzdERyYWdnYWJsZUlkLCBmaW5kT3B0aW9uc0ZvckRyYWdnYWJsZSwgdHJ5UmVsZWFzZUxvY2ssIGlzTG9ja0NsYWltZWRdKTtcbiAgdXNlVmFsaWRhdGVTZW5zb3JIb29rcyh1c2VTZW5zb3JzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVzZVNlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB1c2VTZW5zb3JzW2ldKGFwaSk7XG4gIH1cbn1cblxudmFyIGNyZWF0ZVJlc3BvbmRlcnMgPSBmdW5jdGlvbiBjcmVhdGVSZXNwb25kZXJzKHByb3BzKSB7XG4gIHJldHVybiB7XG4gICAgb25CZWZvcmVDYXB0dXJlOiBwcm9wcy5vbkJlZm9yZUNhcHR1cmUsXG4gICAgb25CZWZvcmVEcmFnU3RhcnQ6IHByb3BzLm9uQmVmb3JlRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgICBvbkRyYWdFbmQ6IHByb3BzLm9uRHJhZ0VuZCxcbiAgICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U3RvcmUobGF6eVJlZikge1xuICAhbGF6eVJlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc3RvcmUgZnJvbSBsYXp5IHJlZicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxhenlSZWYuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gQXBwKHByb3BzKSB7XG4gIHZhciBjb250ZXh0SWQgPSBwcm9wcy5jb250ZXh0SWQsXG4gICAgICBzZXRDYWxsYmFja3MgPSBwcm9wcy5zZXRDYWxsYmFja3MsXG4gICAgICBzZW5zb3JzID0gcHJvcHMuc2Vuc29ycyxcbiAgICAgIG5vbmNlID0gcHJvcHMubm9uY2UsXG4gICAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMgPSBwcm9wcy5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM7XG4gIHZhciBsYXp5U3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZVN0YXJ0dXBWYWxpZGF0aW9uKCk7XG4gIHZhciBsYXN0UHJvcHNSZWYgPSB1c2VQcmV2aW91cyhwcm9wcyk7XG4gIHZhciBnZXRSZXNwb25kZXJzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVSZXNwb25kZXJzKGxhc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgfSwgW2xhc3RQcm9wc1JlZl0pO1xuICB2YXIgYW5ub3VuY2UgPSB1c2VBbm5vdW5jZXIoY29udGV4dElkKTtcbiAgdmFyIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkID0gdXNlSGlkZGVuVGV4dEVsZW1lbnQoe1xuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIHRleHQ6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9KTtcbiAgdmFyIHN0eWxlTWFyc2hhbCA9IHVzZVN0eWxlTWFyc2hhbChjb250ZXh0SWQsIG5vbmNlKTtcbiAgdmFyIGxhenlEaXNwYXRjaCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICBnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmRpc3BhdGNoKGFjdGlvbik7XG4gIH0sIFtdKTtcbiAgdmFyIG1hcnNoYWxDYWxsYmFja3MgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3JzKHtcbiAgICAgIHB1Ymxpc2hXaGlsZURyYWdnaW5nOiBwdWJsaXNoV2hpbGVEcmFnZ2luZyxcbiAgICAgIHVwZGF0ZURyb3BwYWJsZVNjcm9sbDogdXBkYXRlRHJvcHBhYmxlU2Nyb2xsLFxuICAgICAgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkOiB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkOiB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgICAgY29sbGVjdGlvblN0YXJ0aW5nOiBjb2xsZWN0aW9uU3RhcnRpbmdcbiAgICB9LCBsYXp5RGlzcGF0Y2gpO1xuICB9LCBbbGF6eURpc3BhdGNoXSk7XG4gIHZhciByZWdpc3RyeSA9IHVzZVJlZ2lzdHJ5KCk7XG4gIHZhciBkaW1lbnNpb25NYXJzaGFsID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURpbWVuc2lvbk1hcnNoYWwocmVnaXN0cnksIG1hcnNoYWxDYWxsYmFja3MpO1xuICB9LCBbcmVnaXN0cnksIG1hcnNoYWxDYWxsYmFja3NdKTtcbiAgdmFyIGF1dG9TY3JvbGxlciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVBdXRvU2Nyb2xsZXIoX2V4dGVuZHMoe1xuICAgICAgc2Nyb2xsV2luZG93OiBzY3JvbGxXaW5kb3csXG4gICAgICBzY3JvbGxEcm9wcGFibGU6IGRpbWVuc2lvbk1hcnNoYWwuc2Nyb2xsRHJvcHBhYmxlXG4gICAgfSwgYmluZEFjdGlvbkNyZWF0b3JzKHtcbiAgICAgIG1vdmU6IG1vdmVcbiAgICB9LCBsYXp5RGlzcGF0Y2gpKSk7XG4gIH0sIFtkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSwgbGF6eURpc3BhdGNoXSk7XG4gIHZhciBmb2N1c01hcnNoYWwgPSB1c2VGb2N1c01hcnNoYWwoY29udGV4dElkKTtcbiAgdmFyIHN0b3JlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN0b3JlKHtcbiAgICAgIGFubm91bmNlOiBhbm5vdW5jZSxcbiAgICAgIGF1dG9TY3JvbGxlcjogYXV0b1Njcm9sbGVyLFxuICAgICAgZGltZW5zaW9uTWFyc2hhbDogZGltZW5zaW9uTWFyc2hhbCxcbiAgICAgIGZvY3VzTWFyc2hhbDogZm9jdXNNYXJzaGFsLFxuICAgICAgZ2V0UmVzcG9uZGVyczogZ2V0UmVzcG9uZGVycyxcbiAgICAgIHN0eWxlTWFyc2hhbDogc3R5bGVNYXJzaGFsXG4gICAgfSk7XG4gIH0sIFthbm5vdW5jZSwgYXV0b1Njcm9sbGVyLCBkaW1lbnNpb25NYXJzaGFsLCBmb2N1c01hcnNoYWwsIGdldFJlc3BvbmRlcnMsIHN0eWxlTWFyc2hhbF0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGxhenlTdG9yZVJlZi5jdXJyZW50ICYmIGxhenlTdG9yZVJlZi5jdXJyZW50ICE9PSBzdG9yZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygndW5leHBlY3RlZCBzdG9yZSBjaGFuZ2UnKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICBsYXp5U3RvcmVSZWYuY3VycmVudCA9IHN0b3JlO1xuICB2YXIgdHJ5UmVzZXRTdG9yZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudCA9IGdldFN0b3JlKGxhenlTdG9yZVJlZik7XG4gICAgdmFyIHN0YXRlID0gY3VycmVudC5nZXRTdGF0ZSgpO1xuXG4gICAgaWYgKHN0YXRlLnBoYXNlICE9PSAnSURMRScpIHtcbiAgICAgIGN1cnJlbnQuZGlzcGF0Y2goZmx1c2goKSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHZhciBpc0RyYWdnaW5nID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJztcbiAgfSwgW10pO1xuICB2YXIgYXBwQ2FsbGJhY2tzID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsXG4gICAgICB0cnlBYm9ydDogdHJ5UmVzZXRTdG9yZVxuICAgIH07XG4gIH0sIFtpc0RyYWdnaW5nLCB0cnlSZXNldFN0b3JlXSk7XG4gIHNldENhbGxiYWNrcyhhcHBDYWxsYmFja3MpO1xuICB2YXIgZ2V0Q2FuTGlmdCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBjYW5TdGFydERyYWcoZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpLCBpZCk7XG4gIH0sIFtdKTtcbiAgdmFyIGdldElzTW92ZW1lbnRBbGxvd2VkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc01vdmVtZW50QWxsb3dlZChnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCkpO1xuICB9LCBbXSk7XG4gIHZhciBhcHBDb250ZXh0ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcnNoYWw6IGRpbWVuc2lvbk1hcnNoYWwsXG4gICAgICBmb2N1czogZm9jdXNNYXJzaGFsLFxuICAgICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgICBjYW5MaWZ0OiBnZXRDYW5MaWZ0LFxuICAgICAgaXNNb3ZlbWVudEFsbG93ZWQ6IGdldElzTW92ZW1lbnRBbGxvd2VkLFxuICAgICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQ6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgICAgcmVnaXN0cnk6IHJlZ2lzdHJ5XG4gICAgfTtcbiAgfSwgW2NvbnRleHRJZCwgZGltZW5zaW9uTWFyc2hhbCwgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsIGZvY3VzTWFyc2hhbCwgZ2V0Q2FuTGlmdCwgZ2V0SXNNb3ZlbWVudEFsbG93ZWQsIHJlZ2lzdHJ5XSk7XG4gIHVzZVNlbnNvck1hcnNoYWwoe1xuICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgIHN0b3JlOiBzdG9yZSxcbiAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgY3VzdG9tU2Vuc29yczogc2Vuc29ycyxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMgIT09IGZhbHNlXG4gIH0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnlSZXNldFN0b3JlO1xuICB9LCBbdHJ5UmVzZXRTdG9yZV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBcHBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwcENvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQcm92aWRlciwge1xuICAgIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgICBzdG9yZTogc3RvcmVcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn1cblxudmFyIGNvdW50JDEgPSAwO1xuZnVuY3Rpb24gcmVzZXQkMSgpIHtcbiAgY291bnQkMSA9IDA7XG59XG5mdW5jdGlvbiB1c2VJbnN0YW5jZUNvdW50KCkge1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiXCIgKyBjb3VudCQxKys7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTZXJ2ZXJDb250ZXh0KCkge1xuICByZXNldCQxKCk7XG4gIHJlc2V0KCk7XG59XG5mdW5jdGlvbiBEcmFnRHJvcENvbnRleHQocHJvcHMpIHtcbiAgdmFyIGNvbnRleHRJZCA9IHVzZUluc3RhbmNlQ291bnQoKTtcbiAgdmFyIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyA9IHByb3BzLmRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyB8fCBwcmVzZXQuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCBudWxsLCBmdW5jdGlvbiAoc2V0Q2FsbGJhY2tzKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwLCB7XG4gICAgICBub25jZTogcHJvcHMubm9uY2UsXG4gICAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICAgIHNldENhbGxiYWNrczogc2V0Q2FsbGJhY2tzLFxuICAgICAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zOiBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMsXG4gICAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMsXG4gICAgICBzZW5zb3JzOiBwcm9wcy5zZW5zb3JzLFxuICAgICAgb25CZWZvcmVDYXB0dXJlOiBwcm9wcy5vbkJlZm9yZUNhcHR1cmUsXG4gICAgICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gICAgICBvbkRyYWdTdGFydDogcHJvcHMub25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWdVcGRhdGU6IHByb3BzLm9uRHJhZ1VwZGF0ZSxcbiAgICAgIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kXG4gICAgfSwgcHJvcHMuY2hpbGRyZW4pO1xuICB9KTtcbn1cblxudmFyIGlzRXF1YWwkMSA9IGZ1bmN0aW9uIGlzRXF1YWwoYmFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGJhc2UgPT09IHZhbHVlO1xuICB9O1xufTtcblxudmFyIGlzU2Nyb2xsID0gaXNFcXVhbCQxKCdzY3JvbGwnKTtcbnZhciBpc0F1dG8gPSBpc0VxdWFsJDEoJ2F1dG8nKTtcbnZhciBpc1Zpc2libGUkMSA9IGlzRXF1YWwkMSgndmlzaWJsZScpO1xuXG52YXIgaXNFaXRoZXIgPSBmdW5jdGlvbiBpc0VpdGhlcihvdmVyZmxvdywgZm4pIHtcbiAgcmV0dXJuIGZuKG92ZXJmbG93Lm92ZXJmbG93WCkgfHwgZm4ob3ZlcmZsb3cub3ZlcmZsb3dZKTtcbn07XG5cbnZhciBpc0JvdGggPSBmdW5jdGlvbiBpc0JvdGgob3ZlcmZsb3csIGZuKSB7XG4gIHJldHVybiBmbihvdmVyZmxvdy5vdmVyZmxvd1gpICYmIGZuKG92ZXJmbG93Lm92ZXJmbG93WSk7XG59O1xuXG52YXIgaXNFbGVtZW50U2Nyb2xsYWJsZSA9IGZ1bmN0aW9uIGlzRWxlbWVudFNjcm9sbGFibGUoZWwpIHtcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgb3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBzdHlsZS5vdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZOiBzdHlsZS5vdmVyZmxvd1lcbiAgfTtcbiAgcmV0dXJuIGlzRWl0aGVyKG92ZXJmbG93LCBpc1Njcm9sbCkgfHwgaXNFaXRoZXIob3ZlcmZsb3csIGlzQXV0byk7XG59O1xuXG52YXIgaXNCb2R5U2Nyb2xsYWJsZSA9IGZ1bmN0aW9uIGlzQm9keVNjcm9sbGFibGUoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgIWh0bWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICBpZiAoIWlzRWxlbWVudFNjcm9sbGFibGUoYm9keSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaHRtbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG4gIHZhciBodG1sT3ZlcmZsb3cgPSB7XG4gICAgb3ZlcmZsb3dYOiBodG1sU3R5bGUub3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WTogaHRtbFN0eWxlLm92ZXJmbG93WVxuICB9O1xuXG4gIGlmIChpc0JvdGgoaHRtbE92ZXJmbG93LCBpc1Zpc2libGUkMSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKFwiXFxuICAgIFdlIGhhdmUgZGV0ZWN0ZWQgdGhhdCB5b3VyIDxib2R5PiBlbGVtZW50IG1pZ2h0IGJlIGEgc2Nyb2xsIGNvbnRhaW5lci5cXG4gICAgV2UgaGF2ZSBmb3VuZCBubyByZWxpYWJsZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgdGhlIDxib2R5PiBlbGVtZW50IGlzIGEgc2Nyb2xsIGNvbnRhaW5lci5cXG4gICAgVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIGEgPGJvZHk+IHNjcm9sbCBiYXIgd2lsbCBiZSBvbiB0aGUgPGh0bWw+IGVsZW1lbnQgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcXG5cXG4gICAgQmVjYXVzZSB3ZSBjYW5ub3QgZGV0ZXJtaW5lIGlmIHRoZSA8Ym9keT4gaXMgYSBzY3JvbGwgY29udGFpbmVyLCBhbmQgZ2VuZXJhbGx5IGl0IGlzIG5vdCBvbmUsXFxuICAgIHdlIHdpbGwgYmUgdHJlYXRpbmcgdGhlIDxib2R5PiBhcyAqbm90KiBhIHNjcm9sbCBjb250YWluZXJcXG5cXG4gICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2Jsb2IvbWFzdGVyL2RvY3MvZ3VpZGVzL2hvdy13ZS1kZXRlY3Qtc2Nyb2xsLWNvbnRhaW5lcnMubWRcXG4gIFwiKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGdldENsb3Nlc3RTY3JvbGxhYmxlID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFNjcm9sbGFibGUoZWwpIHtcbiAgaWYgKGVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBpc0JvZHlTY3JvbGxhYmxlKCkgPyBlbCA6IG51bGw7XG4gIH1cblxuICBpZiAoZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFpc0VsZW1lbnRTY3JvbGxhYmxlKGVsKSkge1xuICAgIHJldHVybiBnZXRDbG9zZXN0U2Nyb2xsYWJsZShlbC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMgPSAoZnVuY3Rpb24gKHNjcm9sbGFibGUpIHtcbiAgaWYgKCFzY3JvbGxhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFub3RoZXJTY3JvbGxQYXJlbnQgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZShzY3JvbGxhYmxlLnBhcmVudEVsZW1lbnQpO1xuXG4gIGlmICghYW5vdGhlclNjcm9sbFBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoXCJcXG4gICAgRHJvcHBhYmxlOiB1bnN1cHBvcnRlZCBuZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lciBkZXRlY3RlZC5cXG4gICAgQSBEcm9wcGFibGUgY2FuIG9ubHkgaGF2ZSBvbmUgc2Nyb2xsIHBhcmVudCAod2hpY2ggY2FuIGJlIGl0c2VsZilcXG4gICAgTmVzdGVkIHNjcm9sbCBjb250YWluZXJzIGFyZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cXG5cXG4gICAgV2UgaG9wZSB0byBzdXBwb3J0IG5lc3RlZCBzY3JvbGwgY29udGFpbmVycyBzb29uOiBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvaXNzdWVzLzEzMVxcbiAgXCIpIDogdm9pZCAwO1xufSk7XG5cbnZhciBnZXRTY3JvbGwkMSA9IChmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbC5zY3JvbGxMZWZ0LFxuICAgIHk6IGVsLnNjcm9sbFRvcFxuICB9O1xufSk7XG5cbnZhciBnZXRJc0ZpeGVkID0gZnVuY3Rpb24gZ2V0SXNGaXhlZChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG4gIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGdldElzRml4ZWQoZWwucGFyZW50RWxlbWVudCk7XG59O1xuXG52YXIgZ2V0RW52ID0gKGZ1bmN0aW9uIChzdGFydCkge1xuICB2YXIgY2xvc2VzdFNjcm9sbGFibGUgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZShzdGFydCk7XG4gIHZhciBpc0ZpeGVkT25QYWdlID0gZ2V0SXNGaXhlZChzdGFydCk7XG4gIHJldHVybiB7XG4gICAgY2xvc2VzdFNjcm9sbGFibGU6IGNsb3Nlc3RTY3JvbGxhYmxlLFxuICAgIGlzRml4ZWRPblBhZ2U6IGlzRml4ZWRPblBhZ2VcbiAgfTtcbn0pO1xuXG52YXIgZ2V0RHJvcHBhYmxlRGltZW5zaW9uID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gX3JlZi5kZXNjcmlwdG9yLFxuICAgICAgaXNFbmFibGVkID0gX3JlZi5pc0VuYWJsZWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkID0gX3JlZi5pc0NvbWJpbmVFbmFibGVkLFxuICAgICAgaXNGaXhlZE9uUGFnZSA9IF9yZWYuaXNGaXhlZE9uUGFnZSxcbiAgICAgIGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgICAgY2xpZW50ID0gX3JlZi5jbGllbnQsXG4gICAgICBwYWdlID0gX3JlZi5wYWdlLFxuICAgICAgY2xvc2VzdCA9IF9yZWYuY2xvc2VzdDtcblxuICB2YXIgZnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjbG9zZXN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc2Nyb2xsU2l6ZSA9IGNsb3Nlc3Quc2Nyb2xsU2l6ZSxcbiAgICAgICAgZnJhbWVDbGllbnQgPSBjbG9zZXN0LmNsaWVudDtcbiAgICB2YXIgbWF4U2Nyb2xsID0gZ2V0TWF4U2Nyb2xsKHtcbiAgICAgIHNjcm9sbEhlaWdodDogc2Nyb2xsU2l6ZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogc2Nyb2xsU2l6ZS5zY3JvbGxXaWR0aCxcbiAgICAgIGhlaWdodDogZnJhbWVDbGllbnQucGFkZGluZ0JveC5oZWlnaHQsXG4gICAgICB3aWR0aDogZnJhbWVDbGllbnQucGFkZGluZ0JveC53aWR0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlTWFyZ2luQm94OiBjbG9zZXN0LnBhZ2UubWFyZ2luQm94LFxuICAgICAgZnJhbWVDbGllbnQ6IGZyYW1lQ2xpZW50LFxuICAgICAgc2Nyb2xsU2l6ZTogc2Nyb2xsU2l6ZSxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiBjbG9zZXN0LnNob3VsZENsaXBTdWJqZWN0LFxuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIGluaXRpYWw6IGNsb3Nlc3Quc2Nyb2xsLFxuICAgICAgICBjdXJyZW50OiBjbG9zZXN0LnNjcm9sbCxcbiAgICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICAgIGRpZmY6IHtcbiAgICAgICAgICB2YWx1ZTogb3JpZ2luLFxuICAgICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGF4aXMgPSBkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgPyB2ZXJ0aWNhbCA6IGhvcml6b250YWw7XG4gIHZhciBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogcGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgYXhpczogYXhpcyxcbiAgICBmcmFtZTogZnJhbWVcbiAgfSk7XG4gIHZhciBkaW1lbnNpb24gPSB7XG4gICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICBpc0NvbWJpbmVFbmFibGVkOiBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2U6IGlzRml4ZWRPblBhZ2UsXG4gICAgYXhpczogYXhpcyxcbiAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcbiAgICBjbGllbnQ6IGNsaWVudCxcbiAgICBwYWdlOiBwYWdlLFxuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBzdWJqZWN0OiBzdWJqZWN0XG4gIH07XG4gIHJldHVybiBkaW1lbnNpb247XG59KTtcblxudmFyIGdldENsaWVudCA9IGZ1bmN0aW9uIGdldENsaWVudCh0YXJnZXRSZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gIHZhciBiYXNlID0gZ2V0Qm94KHRhcmdldFJlZik7XG5cbiAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgaWYgKHRhcmdldFJlZiAhPT0gY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHZhciB0b3AgPSBiYXNlLnBhZGRpbmdCb3gudG9wIC0gY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsVG9wO1xuICB2YXIgbGVmdCA9IGJhc2UucGFkZGluZ0JveC5sZWZ0IC0gY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsTGVmdDtcbiAgdmFyIGJvdHRvbSA9IHRvcCArIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodDtcbiAgdmFyIHJpZ2h0ID0gbGVmdCArIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbFdpZHRoO1xuICB2YXIgcGFkZGluZ0JveCA9IHtcbiAgICB0b3A6IHRvcCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgbGVmdDogbGVmdFxuICB9O1xuICB2YXIgYm9yZGVyQm94ID0gZXhwYW5kKHBhZGRpbmdCb3gsIGJhc2UuYm9yZGVyKTtcbiAgdmFyIGNsaWVudCA9IGNyZWF0ZUJveCh7XG4gICAgYm9yZGVyQm94OiBib3JkZXJCb3gsXG4gICAgbWFyZ2luOiBiYXNlLm1hcmdpbixcbiAgICBib3JkZXI6IGJhc2UuYm9yZGVyLFxuICAgIHBhZGRpbmc6IGJhc2UucGFkZGluZ1xuICB9KTtcbiAgcmV0dXJuIGNsaWVudDtcbn07XG5cbnZhciBnZXREaW1lbnNpb24gPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJlZiA9IF9yZWYucmVmLFxuICAgICAgZGVzY3JpcHRvciA9IF9yZWYuZGVzY3JpcHRvcixcbiAgICAgIGVudiA9IF9yZWYuZW52LFxuICAgICAgd2luZG93U2Nyb2xsID0gX3JlZi53aW5kb3dTY3JvbGwsXG4gICAgICBkaXJlY3Rpb24gPSBfcmVmLmRpcmVjdGlvbixcbiAgICAgIGlzRHJvcERpc2FibGVkID0gX3JlZi5pc0Ryb3BEaXNhYmxlZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQgPSBfcmVmLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdCA9IF9yZWYuc2hvdWxkQ2xpcFN1YmplY3Q7XG4gIHZhciBjbG9zZXN0U2Nyb2xsYWJsZSA9IGVudi5jbG9zZXN0U2Nyb2xsYWJsZTtcbiAgdmFyIGNsaWVudCA9IGdldENsaWVudChyZWYsIGNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgdmFyIHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcblxuICB2YXIgY2xvc2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVDbGllbnQgPSBnZXRCb3goY2xvc2VzdFNjcm9sbGFibGUpO1xuICAgIHZhciBzY3JvbGxTaXplID0ge1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGhcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50LFxuICAgICAgcGFnZTogd2l0aFNjcm9sbChmcmFtZUNsaWVudCwgd2luZG93U2Nyb2xsKSxcbiAgICAgIHNjcm9sbDogZ2V0U2Nyb2xsJDEoY2xvc2VzdFNjcm9sbGFibGUpLFxuICAgICAgc2Nyb2xsU2l6ZTogc2Nyb2xsU2l6ZSxcbiAgICAgIHNob3VsZENsaXBTdWJqZWN0OiBzaG91bGRDbGlwU3ViamVjdFxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgZGltZW5zaW9uID0gZ2V0RHJvcHBhYmxlRGltZW5zaW9uKHtcbiAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgIGlzRW5hYmxlZDogIWlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQ6IGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaXNGaXhlZE9uUGFnZTogZW52LmlzRml4ZWRPblBhZ2UsXG4gICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgY2xpZW50OiBjbGllbnQsXG4gICAgcGFnZTogcGFnZSxcbiAgICBjbG9zZXN0OiBjbG9zZXN0XG4gIH0pO1xuICByZXR1cm4gZGltZW5zaW9uO1xufSk7XG5cbnZhciBpbW1lZGlhdGUgPSB7XG4gIHBhc3NpdmU6IGZhbHNlXG59O1xudmFyIGRlbGF5ZWQgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG52YXIgZ2V0TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSA/IGltbWVkaWF0ZSA6IGRlbGF5ZWQ7XG59KTtcblxuZnVuY3Rpb24gdXNlUmVxdWlyZWRDb250ZXh0KENvbnRleHQpIHtcbiAgdmFyIHJlc3VsdCA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICFyZXN1bHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCByZXF1aXJlZCBjb250ZXh0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyA9IGZ1bmN0aW9uIGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpIHtcbiAgcmV0dXJuIGRyYWdnaW5nICYmIGRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSB8fCBudWxsO1xufTtcblxuZnVuY3Rpb24gdXNlRHJvcHBhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgdmFyIHdoaWxlRHJhZ2dpbmdSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBhcHBDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KEFwcENvbnRleHQpO1xuICB2YXIgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnZHJvcHBhYmxlJyk7XG4gIHZhciByZWdpc3RyeSA9IGFwcENvbnRleHQucmVnaXN0cnksXG4gICAgICBtYXJzaGFsID0gYXBwQ29udGV4dC5tYXJzaGFsO1xuICB2YXIgcHJldmlvdXNSZWYgPSB1c2VQcmV2aW91cyhhcmdzKTtcbiAgdmFyIGRlc2NyaXB0b3IgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGFyZ3MuZHJvcHBhYmxlSWQsXG4gICAgICB0eXBlOiBhcmdzLnR5cGUsXG4gICAgICBtb2RlOiBhcmdzLm1vZGVcbiAgICB9O1xuICB9LCBbYXJncy5kcm9wcGFibGVJZCwgYXJncy5tb2RlLCBhcmdzLnR5cGVdKTtcbiAgdmFyIHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYgPSB1c2VSZWYoZGVzY3JpcHRvcik7XG4gIHZhciBtZW1vaXplZFVwZGF0ZVNjcm9sbCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtZW1vaXplT25lKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgdXBkYXRlIHNjcm9sbCB3aGVuIGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIHNjcm9sbCA9IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlU2Nyb2xsKGRlc2NyaXB0b3IuaWQsIHNjcm9sbCk7XG4gICAgfSk7XG4gIH0sIFtkZXNjcmlwdG9yLmlkLCBtYXJzaGFsXSk7XG4gIHZhciBnZXRDbG9zZXN0U2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcblxuICAgIGlmICghZHJhZ2dpbmcgfHwgIWRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0U2Nyb2xsJDEoZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgfSwgW10pO1xuICB2YXIgdXBkYXRlU2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY3JvbGwgPSBnZXRDbG9zZXN0U2Nyb2xsKCk7XG4gICAgbWVtb2l6ZWRVcGRhdGVTY3JvbGwoc2Nyb2xsLngsIHNjcm9sbC55KTtcbiAgfSwgW2dldENsb3Nlc3RTY3JvbGwsIG1lbW9pemVkVXBkYXRlU2Nyb2xsXSk7XG4gIHZhciBzY2hlZHVsZVNjcm9sbFVwZGF0ZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWZTY2hkKHVwZGF0ZVNjcm9sbCk7XG4gIH0sIFt1cGRhdGVTY3JvbGxdKTtcbiAgdmFyIG9uQ2xvc2VzdFNjcm9sbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgdmFyIGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhKGRyYWdnaW5nICYmIGNsb3Nlc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc2Nyb2xsIG9wdGlvbnMgd2hpbGUgc2Nyb2xsaW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBvcHRpb25zID0gZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucztcblxuICAgIGlmIChvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSkge1xuICAgICAgdXBkYXRlU2Nyb2xsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZWR1bGVTY3JvbGxVcGRhdGUoKTtcbiAgfSwgW3NjaGVkdWxlU2Nyb2xsVXBkYXRlLCB1cGRhdGVTY3JvbGxdKTtcbiAgdmFyIGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHdpbmRvd1Njcm9sbCwgb3B0aW9ucykge1xuICAgICEhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbGxlY3QgYSBkcm9wcGFibGUgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgcHJldmlvdXMgPSBwcmV2aW91c1JlZi5jdXJyZW50O1xuICAgIHZhciByZWYgPSBwcmV2aW91cy5nZXREcm9wcGFibGVSZWYoKTtcbiAgICAhcmVmID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbGxlY3Qgd2l0aG91dCBhIGRyb3BwYWJsZSByZWYnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGVudiA9IGdldEVudihyZWYpO1xuICAgIHZhciBkcmFnZ2luZyA9IHtcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgIGVudjogZW52LFxuICAgICAgc2Nyb2xsT3B0aW9uczogb3B0aW9uc1xuICAgIH07XG4gICAgd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID0gZHJhZ2dpbmc7XG4gICAgdmFyIGRpbWVuc2lvbiA9IGdldERpbWVuc2lvbih7XG4gICAgICByZWY6IHJlZixcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICBlbnY6IGVudixcbiAgICAgIHdpbmRvd1Njcm9sbDogd2luZG93U2Nyb2xsLFxuICAgICAgZGlyZWN0aW9uOiBwcmV2aW91cy5kaXJlY3Rpb24sXG4gICAgICBpc0Ryb3BEaXNhYmxlZDogcHJldmlvdXMuaXNEcm9wRGlzYWJsZWQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkOiBwcmV2aW91cy5pc0NvbWJpbmVFbmFibGVkLFxuICAgICAgc2hvdWxkQ2xpcFN1YmplY3Q6ICFwcmV2aW91cy5pZ25vcmVDb250YWluZXJDbGlwcGluZ1xuICAgIH0pO1xuICAgIHZhciBzY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuXG4gICAgaWYgKHNjcm9sbGFibGUpIHtcbiAgICAgIHNjcm9sbGFibGUuc2V0QXR0cmlidXRlKHNjcm9sbENvbnRhaW5lci5jb250ZXh0SWQsIGFwcENvbnRleHQuY29udGV4dElkKTtcbiAgICAgIHNjcm9sbGFibGUuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25DbG9zZXN0U2Nyb2xsLCBnZXRMaXN0ZW5lck9wdGlvbnMoZHJhZ2dpbmcuc2Nyb2xsT3B0aW9ucykpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMoc2Nyb2xsYWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgfSwgW2FwcENvbnRleHQuY29udGV4dElkLCBkZXNjcmlwdG9yLCBvbkNsb3Nlc3RTY3JvbGwsIHByZXZpb3VzUmVmXSk7XG4gIHZhciBnZXRTY3JvbGxXaGlsZURyYWdnaW5nID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICB2YXIgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSByZWNvbGxlY3QgRHJvcHBhYmxlIGNsaWVudCBmb3IgRHJvcHBhYmxlcyB0aGF0IGhhdmUgYSBzY3JvbGwgY29udGFpbmVyJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJldHVybiBnZXRTY3JvbGwkMShjbG9zZXN0KTtcbiAgfSwgW10pO1xuICB2YXIgZHJhZ1N0b3BwZWQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzdG9wIGRyYWcgd2hlbiBubyBhY3RpdmUgZHJhZycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgIHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudCA9IG51bGw7XG5cbiAgICBpZiAoIWNsb3Nlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZS5jYW5jZWwoKTtcbiAgICBjbG9zZXN0LnJlbW92ZUF0dHJpYnV0ZShzY3JvbGxDb250YWluZXIuY29udGV4dElkKTtcbiAgICBjbG9zZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uQ2xvc2VzdFNjcm9sbCwgZ2V0TGlzdGVuZXJPcHRpb25zKGRyYWdnaW5nLnNjcm9sbE9wdGlvbnMpKTtcbiAgfSwgW29uQ2xvc2VzdFNjcm9sbCwgc2NoZWR1bGVTY3JvbGxVcGRhdGVdKTtcbiAgdmFyIHNjcm9sbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICB2YXIgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNjcm9sbCB3aGVuIHRoZXJlIGlzIG5vIGRyYWcnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhY2xvc2VzdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzY3JvbGwgYSBkcm9wcGFibGUgd2l0aCBubyBjbG9zZXN0IHNjcm9sbGFibGUnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgY2xvc2VzdC5zY3JvbGxUb3AgKz0gY2hhbmdlLnk7XG4gICAgY2xvc2VzdC5zY3JvbGxMZWZ0ICs9IGNoYW5nZS54O1xuICB9LCBbXSk7XG4gIHZhciBjYWxsYmFja3MgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGw6IGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsLFxuICAgICAgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZzogZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZyxcbiAgICAgIGRyYWdTdG9wcGVkOiBkcmFnU3RvcHBlZCxcbiAgICAgIHNjcm9sbDogc2Nyb2xsXG4gICAgfTtcbiAgfSwgW2RyYWdTdG9wcGVkLCBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCwgZ2V0U2Nyb2xsV2hpbGVEcmFnZ2luZywgc2Nyb2xsXSk7XG4gIHZhciBlbnRyeSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB1bmlxdWVJZDogdW5pcXVlSWQsXG4gICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgY2FsbGJhY2tzOiBjYWxsYmFja3NcbiAgICB9O1xuICB9LCBbY2FsbGJhY2tzLCBkZXNjcmlwdG9yLCB1bmlxdWVJZF0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQgPSBlbnRyeS5kZXNjcmlwdG9yO1xuICAgIHJlZ2lzdHJ5LmRyb3BwYWJsZS5yZWdpc3RlcihlbnRyeSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnVW5zdXBwb3J0ZWQ6IGNoYW5naW5nIHRoZSBkcm9wcGFibGVJZCBvciB0eXBlIG9mIGEgRHJvcHBhYmxlIGR1cmluZyBhIGRyYWcnKSA6IHZvaWQgMDtcbiAgICAgICAgZHJhZ1N0b3BwZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmVnaXN0cnkuZHJvcHBhYmxlLnVucmVnaXN0ZXIoZW50cnkpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFja3MsIGRlc2NyaXB0b3IsIGRyYWdTdG9wcGVkLCBlbnRyeSwgbWFyc2hhbCwgcmVnaXN0cnkuZHJvcHBhYmxlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQocHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50LmlkLCAhYXJncy5pc0Ryb3BEaXNhYmxlZCk7XG4gIH0sIFthcmdzLmlzRHJvcERpc2FibGVkLCBtYXJzaGFsXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkKHB1Ymxpc2hlZERlc2NyaXB0b3JSZWYuY3VycmVudC5pZCwgYXJncy5pc0NvbWJpbmVFbmFibGVkKTtcbiAgfSwgW2FyZ3MuaXNDb21iaW5lRW5hYmxlZCwgbWFyc2hhbF0pO1xufVxuXG5mdW5jdGlvbiBub29wJDIoKSB7fVxuXG52YXIgZW1wdHkgPSB7XG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIG1hcmdpbjogbm9TcGFjaW5nXG59O1xuXG52YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUoX3JlZikge1xuICB2YXIgaXNBbmltYXRpbmdPcGVuT25Nb3VudCA9IF9yZWYuaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgICAgIHBsYWNlaG9sZGVyID0gX3JlZi5wbGFjZWhvbGRlcixcbiAgICAgIGFuaW1hdGUgPSBfcmVmLmFuaW1hdGU7XG5cbiAgaWYgKGlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cblxuICBpZiAoYW5pbWF0ZSA9PT0gJ2Nsb3NlJykge1xuICAgIHJldHVybiBlbXB0eTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LmhlaWdodCxcbiAgICB3aWR0aDogcGxhY2Vob2xkZXIuY2xpZW50LmJvcmRlckJveC53aWR0aCxcbiAgICBtYXJnaW46IHBsYWNlaG9sZGVyLmNsaWVudC5tYXJnaW5cbiAgfTtcbn07XG5cbnZhciBnZXRTdHlsZSA9IGZ1bmN0aW9uIGdldFN0eWxlKF9yZWYyKSB7XG4gIHZhciBpc0FuaW1hdGluZ09wZW5Pbk1vdW50ID0gX3JlZjIuaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgICAgIHBsYWNlaG9sZGVyID0gX3JlZjIucGxhY2Vob2xkZXIsXG4gICAgICBhbmltYXRlID0gX3JlZjIuYW5pbWF0ZTtcbiAgdmFyIHNpemUgPSBnZXRTaXplKHtcbiAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50OiBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LFxuICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICBhbmltYXRlOiBhbmltYXRlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6IHBsYWNlaG9sZGVyLmRpc3BsYXksXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICBtYXJnaW5Ub3A6IHNpemUubWFyZ2luLnRvcCxcbiAgICBtYXJnaW5SaWdodDogc2l6ZS5tYXJnaW4ucmlnaHQsXG4gICAgbWFyZ2luQm90dG9tOiBzaXplLm1hcmdpbi5ib3R0b20sXG4gICAgbWFyZ2luTGVmdDogc2l6ZS5tYXJnaW4ubGVmdCxcbiAgICBmbGV4U2hyaW5rOiAnMCcsXG4gICAgZmxleEdyb3c6ICcwJyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgdHJhbnNpdGlvbjogYW5pbWF0ZSAhPT0gJ25vbmUnID8gdHJhbnNpdGlvbnMucGxhY2Vob2xkZXIgOiBudWxsXG4gIH07XG59O1xuXG5mdW5jdGlvbiBQbGFjZWhvbGRlcihwcm9wcykge1xuICB2YXIgYW5pbWF0ZU9wZW5UaW1lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpO1xuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IG51bGw7XG4gIH0sIFtdKTtcbiAgdmFyIGFuaW1hdGUgPSBwcm9wcy5hbmltYXRlLFxuICAgICAgb25UcmFuc2l0aW9uRW5kID0gcHJvcHMub25UcmFuc2l0aW9uRW5kLFxuICAgICAgb25DbG9zZSA9IHByb3BzLm9uQ2xvc2UsXG4gICAgICBjb250ZXh0SWQgPSBwcm9wcy5jb250ZXh0SWQ7XG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHByb3BzLmFuaW1hdGUgPT09ICdvcGVuJyksXG4gICAgICBpc0FuaW1hdGluZ09wZW5Pbk1vdW50ID0gX3VzZVN0YXRlWzBdLFxuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudCA9IF91c2VTdGF0ZVsxXTtcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgICAgcmV0dXJuIG5vb3AkMjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZSAhPT0gJ29wZW4nKSB7XG4gICAgICB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIoKTtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgICAgcmV0dXJuIG5vb3AkMjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm4gbm9vcCQyO1xuICAgIH1cblxuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXI7XG4gIH0sIFthbmltYXRlLCBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXJdKTtcbiAgdmFyIG9uU2l6ZUNoYW5nZUVuZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICdoZWlnaHQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb25UcmFuc2l0aW9uRW5kKCk7XG5cbiAgICBpZiAoYW5pbWF0ZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgb25DbG9zZSgpO1xuICAgIH1cbiAgfSwgW2FuaW1hdGUsIG9uQ2xvc2UsIG9uVHJhbnNpdGlvbkVuZF0pO1xuICB2YXIgc3R5bGUgPSBnZXRTdHlsZSh7XG4gICAgaXNBbmltYXRpbmdPcGVuT25Nb3VudDogaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgICBhbmltYXRlOiBwcm9wcy5hbmltYXRlLFxuICAgIHBsYWNlaG9sZGVyOiBwcm9wcy5wbGFjZWhvbGRlclxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHMucGxhY2Vob2xkZXIudGFnTmFtZSwge1xuICAgIHN0eWxlOiBzdHlsZSxcbiAgICAnZGF0YS1yYmQtcGxhY2Vob2xkZXItY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uU2l6ZUNoYW5nZUVuZCxcbiAgICByZWY6IHByb3BzLmlubmVyUmVmXG4gIH0pO1xufVxuXG52YXIgUGxhY2Vob2xkZXIkMSA9IFJlYWN0Lm1lbW8oUGxhY2Vob2xkZXIpO1xuXG52YXIgRHJvcHBhYmxlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIGNoZWNrSXNWYWxpZElubmVyUmVmKGVsKSB7XG4gICEoZWwgJiYgaXNIdG1sRWxlbWVudChlbCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIlxcbiAgICBwcm92aWRlZC5pbm5lclJlZiBoYXMgbm90IGJlZW4gcHJvdmlkZWQgd2l0aCBhIEhUTUxFbGVtZW50LlxcblxcbiAgICBZb3UgY2FuIGZpbmQgYSBndWlkZSBvbiB1c2luZyB0aGUgaW5uZXJSZWYgY2FsbGJhY2sgZnVuY3Rpb25zIGF0OlxcbiAgICBodHRwczovL2dpdGh1Yi5jb20vYXRsYXNzaWFuL3JlYWN0LWJlYXV0aWZ1bC1kbmQvYmxvYi9tYXN0ZXIvZG9jcy9ndWlkZXMvdXNpbmctaW5uZXItcmVmLm1kXFxuICBcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5mdW5jdGlvbiBydW5DaGVja3MoYXJncywgY2hlY2tzKSB7XG4gIGNoZWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGVjaykge1xuICAgIHJldHVybiBjaGVjayhhcmdzKTtcbiAgfSk7XG59XG5cbnZhciBzaGFyZWQgPSBbZnVuY3Rpb24gcmVxdWlyZWQoX3JlZikge1xuICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAhcHJvcHMuZHJvcHBhYmxlSWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIERyb3BwYWJsZSByZXF1aXJlcyBhIGRyb3BwYWJsZUlkIHByb3AnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICEodHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiQSBEcm9wcGFibGUgcmVxdWlyZXMgYSBbc3RyaW5nXSBkcm9wcGFibGVJZC4gUHJvdmlkZWQ6IFtcIiArIHR5cGVvZiBwcm9wcy5kcm9wcGFibGVJZCArIFwiXVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBfYm9vbGVhbihfcmVmMikge1xuICB2YXIgcHJvcHMgPSBfcmVmMi5wcm9wcztcbiAgIWlzQm9vbGVhbihwcm9wcy5pc0Ryb3BEaXNhYmxlZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0Ryb3BEaXNhYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgIWlzQm9vbGVhbihwcm9wcy5pc0NvbWJpbmVFbmFibGVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ2lzQ29tYmluZUVuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICFpc0Jvb2xlYW4ocHJvcHMuaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcgbXVzdCBiZSBhIGJvb2xlYW4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiByZWYoX3JlZjMpIHtcbiAgdmFyIGdldERyb3BwYWJsZVJlZiA9IF9yZWYzLmdldERyb3BwYWJsZVJlZjtcbiAgY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZ2V0RHJvcHBhYmxlUmVmKCkpO1xufV07XG52YXIgc3RhbmRhcmQgPSBbZnVuY3Rpb24gcGxhY2Vob2xkZXIoX3JlZjQpIHtcbiAgdmFyIHByb3BzID0gX3JlZjQucHJvcHMsXG4gICAgICBnZXRQbGFjZWhvbGRlclJlZiA9IF9yZWY0LmdldFBsYWNlaG9sZGVyUmVmO1xuXG4gIGlmICghcHJvcHMucGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVmID0gZ2V0UGxhY2Vob2xkZXJSZWYoKTtcblxuICBpZiAocmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhcIlxcbiAgICAgIERyb3BwYWJsZSBzZXR1cCBpc3N1ZSBbZHJvcHBhYmxlSWQ6IFxcXCJcIiArIHByb3BzLmRyb3BwYWJsZUlkICsgXCJcXFwiXTpcXG4gICAgICBEcm9wcGFibGVQcm92aWRlZCA+IHBsYWNlaG9sZGVyIGNvdWxkIG5vdCBiZSBmb3VuZC5cXG5cXG4gICAgICBQbGVhc2UgYmUgc3VyZSB0byBhZGQgdGhlIHtwcm92aWRlZC5wbGFjZWhvbGRlcn0gUmVhY3QgTm9kZSBhcyBhIGNoaWxkIG9mIHlvdXIgRHJvcHBhYmxlLlxcbiAgICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9hdGxhc3NpYW4vcmVhY3QtYmVhdXRpZnVsLWRuZC9ibG9iL21hc3Rlci9kb2NzL2FwaS9kcm9wcGFibGUubWRcXG4gICAgXCIpIDogdm9pZCAwO1xufV07XG52YXIgdmlydHVhbCA9IFtmdW5jdGlvbiBoYXNDbG9uZShfcmVmNSkge1xuICB2YXIgcHJvcHMgPSBfcmVmNS5wcm9wcztcbiAgIXByb3BzLnJlbmRlckNsb25lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBwcm92aWRlIGEgY2xvbmUgcmVuZGVyIGZ1bmN0aW9uIChyZW5kZXJDbG9uZSkgZm9yIHZpcnR1YWwgbGlzdHMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG59LCBmdW5jdGlvbiBoYXNOb1BsYWNlaG9sZGVyKF9yZWY2KSB7XG4gIHZhciBnZXRQbGFjZWhvbGRlclJlZiA9IF9yZWY2LmdldFBsYWNlaG9sZGVyUmVmO1xuICAhIWdldFBsYWNlaG9sZGVyUmVmKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB2aXJ0dWFsIGxpc3QgdG8gbm90IGhhdmUgYSBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbn1dO1xuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbihhcmdzKSB7XG4gIHVzZURldlNldHVwV2FybmluZyhmdW5jdGlvbiAoKSB7XG4gICAgcnVuQ2hlY2tzKGFyZ3MsIHNoYXJlZCk7XG5cbiAgICBpZiAoYXJncy5wcm9wcy5tb2RlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgc3RhbmRhcmQpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLnByb3BzLm1vZGUgPT09ICd2aXJ0dWFsJykge1xuICAgICAgcnVuQ2hlY2tzKGFyZ3MsIHZpcnR1YWwpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBBbmltYXRlSW5PdXQgPSBmdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQW5pbWF0ZUluT3V0LCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQW5pbWF0ZUluT3V0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRQdXJlQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JFB1cmVDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4oX3RoaXMucHJvcHMub24pLFxuICAgICAgZGF0YTogX3RoaXMucHJvcHMub24sXG4gICAgICBhbmltYXRlOiBfdGhpcy5wcm9wcy5zaG91bGRBbmltYXRlICYmIF90aGlzLnByb3BzLm9uID8gJ29wZW4nIDogJ25vbmUnXG4gICAgfTtcblxuICAgIF90aGlzLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUuYW5pbWF0ZSAhPT0gJ2Nsb3NlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNWaXNpYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEFuaW1hdGVJbk91dC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKCFwcm9wcy5zaG91bGRBbmltYXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4ocHJvcHMub24pLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ25vbmUnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5vbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ29wZW4nXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgZGF0YTogc3RhdGUuZGF0YSxcbiAgICAgICAgYW5pbWF0ZTogJ2Nsb3NlJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGFuaW1hdGU6ICdjbG9zZScsXG4gICAgICBkYXRhOiBudWxsXG4gICAgfTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gQW5pbWF0ZUluT3V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwcm92aWRlZCA9IHtcbiAgICAgIG9uQ2xvc2U6IHRoaXMub25DbG9zZSxcbiAgICAgIGRhdGE6IHRoaXMuc3RhdGUuZGF0YSxcbiAgICAgIGFuaW1hdGU6IHRoaXMuc3RhdGUuYW5pbWF0ZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4ocHJvdmlkZWQpO1xuICB9O1xuXG4gIHJldHVybiBBbmltYXRlSW5PdXQ7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG52YXIgekluZGV4T3B0aW9ucyA9IHtcbiAgZHJhZ2dpbmc6IDUwMDAsXG4gIGRyb3BBbmltYXRpbmc6IDQ1MDBcbn07XG5cbnZhciBnZXREcmFnZ2luZ1RyYW5zaXRpb24gPSBmdW5jdGlvbiBnZXREcmFnZ2luZ1RyYW5zaXRpb24oc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCwgZHJvcHBpbmcpIHtcbiAgaWYgKGRyb3BwaW5nKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25zLmRyb3AoZHJvcHBpbmcuZHVyYXRpb24pO1xuICB9XG5cbiAgaWYgKHNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbnMuc25hcDtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2l0aW9ucy5mbHVpZDtcbn07XG5cbnZhciBnZXREcmFnZ2luZ09wYWNpdHkgPSBmdW5jdGlvbiBnZXREcmFnZ2luZ09wYWNpdHkoaXNDb21iaW5pbmcsIGlzRHJvcEFuaW1hdGluZykge1xuICBpZiAoIWlzQ29tYmluaW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaXNEcm9wQW5pbWF0aW5nID8gY29tYmluZS5vcGFjaXR5LmRyb3AgOiBjb21iaW5lLm9wYWNpdHkuY29tYmluaW5nO1xufTtcblxudmFyIGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZSA9IGZ1bmN0aW9uIGdldFNob3VsZERyYWdnaW5nQW5pbWF0ZShkcmFnZ2luZykge1xuICBpZiAoZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlICE9IG51bGwpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlO1xuICB9XG5cbiAgcmV0dXJuIGRyYWdnaW5nLm1vZGUgPT09ICdTTkFQJztcbn07XG5cbmZ1bmN0aW9uIGdldERyYWdnaW5nU3R5bGUoZHJhZ2dpbmcpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IGRyYWdnaW5nLmRpbWVuc2lvbjtcbiAgdmFyIGJveCA9IGRpbWVuc2lvbi5jbGllbnQ7XG4gIHZhciBvZmZzZXQgPSBkcmFnZ2luZy5vZmZzZXQsXG4gICAgICBjb21iaW5lV2l0aCA9IGRyYWdnaW5nLmNvbWJpbmVXaXRoLFxuICAgICAgZHJvcHBpbmcgPSBkcmFnZ2luZy5kcm9wcGluZztcbiAgdmFyIGlzQ29tYmluaW5nID0gQm9vbGVhbihjb21iaW5lV2l0aCk7XG4gIHZhciBzaG91bGRBbmltYXRlID0gZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlKGRyYWdnaW5nKTtcbiAgdmFyIGlzRHJvcEFuaW1hdGluZyA9IEJvb2xlYW4oZHJvcHBpbmcpO1xuICB2YXIgdHJhbnNmb3JtID0gaXNEcm9wQW5pbWF0aW5nID8gdHJhbnNmb3Jtcy5kcm9wKG9mZnNldCwgaXNDb21iaW5pbmcpIDogdHJhbnNmb3Jtcy5tb3ZlVG8ob2Zmc2V0KTtcbiAgdmFyIHN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIHRvcDogYm94Lm1hcmdpbkJveC50b3AsXG4gICAgbGVmdDogYm94Lm1hcmdpbkJveC5sZWZ0LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBib3guYm9yZGVyQm94LndpZHRoLFxuICAgIGhlaWdodDogYm94LmJvcmRlckJveC5oZWlnaHQsXG4gICAgdHJhbnNpdGlvbjogZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uKHNob3VsZEFuaW1hdGUsIGRyb3BwaW5nKSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBvcGFjaXR5OiBnZXREcmFnZ2luZ09wYWNpdHkoaXNDb21iaW5pbmcsIGlzRHJvcEFuaW1hdGluZyksXG4gICAgekluZGV4OiBpc0Ryb3BBbmltYXRpbmcgPyB6SW5kZXhPcHRpb25zLmRyb3BBbmltYXRpbmcgOiB6SW5kZXhPcHRpb25zLmRyYWdnaW5nLFxuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICB9O1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGdldFNlY29uZGFyeVN0eWxlKHNlY29uZGFyeSkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtcy5tb3ZlVG8oc2Vjb25kYXJ5Lm9mZnNldCksXG4gICAgdHJhbnNpdGlvbjogc2Vjb25kYXJ5LnNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQgPyBudWxsIDogJ25vbmUnXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFN0eWxlJDEobWFwcGVkKSB7XG4gIHJldHVybiBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyA/IGdldERyYWdnaW5nU3R5bGUobWFwcGVkKSA6IGdldFNlY29uZGFyeVN0eWxlKG1hcHBlZCk7XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbiQxKGRlc2NyaXB0b3IsIGVsLCB3aW5kb3dTY3JvbGwpIHtcbiAgaWYgKHdpbmRvd1Njcm9sbCA9PT0gdm9pZCAwKSB7XG4gICAgd2luZG93U2Nyb2xsID0gb3JpZ2luO1xuICB9XG5cbiAgdmFyIGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgYm9yZGVyQm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBjbGllbnQgPSBjYWxjdWxhdGVCb3goYm9yZGVyQm94LCBjb21wdXRlZFN0eWxlcyk7XG4gIHZhciBwYWdlID0gd2l0aFNjcm9sbChjbGllbnQsIHdpbmRvd1Njcm9sbCk7XG4gIHZhciBwbGFjZWhvbGRlciA9IHtcbiAgICBjbGllbnQ6IGNsaWVudCxcbiAgICB0YWdOYW1lOiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgZGlzcGxheTogY29tcHV0ZWRTdHlsZXMuZGlzcGxheVxuICB9O1xuICB2YXIgZGlzcGxhY2VCeSA9IHtcbiAgICB4OiBjbGllbnQubWFyZ2luQm94LndpZHRoLFxuICAgIHk6IGNsaWVudC5tYXJnaW5Cb3guaGVpZ2h0XG4gIH07XG4gIHZhciBkaW1lbnNpb24gPSB7XG4gICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgZGlzcGxhY2VCeTogZGlzcGxhY2VCeSxcbiAgICBjbGllbnQ6IGNsaWVudCxcbiAgICBwYWdlOiBwYWdlXG4gIH07XG4gIHJldHVybiBkaW1lbnNpb247XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdnYWJsZVB1Ymxpc2hlcihhcmdzKSB7XG4gIHZhciB1bmlxdWVJZCA9IHVzZVVuaXF1ZUlkKCdkcmFnZ2FibGUnKTtcbiAgdmFyIGRlc2NyaXB0b3IgPSBhcmdzLmRlc2NyaXB0b3IsXG4gICAgICByZWdpc3RyeSA9IGFyZ3MucmVnaXN0cnksXG4gICAgICBnZXREcmFnZ2FibGVSZWYgPSBhcmdzLmdldERyYWdnYWJsZVJlZixcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzID0gYXJncy5jYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzID0gYXJncy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGlzRW5hYmxlZCA9IGFyZ3MuaXNFbmFibGVkO1xuICB2YXIgb3B0aW9ucyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50czogY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBpc0VuYWJsZWQ6IGlzRW5hYmxlZFxuICAgIH07XG4gIH0sIFtjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cywgaXNFbmFibGVkLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc10pO1xuICB2YXIgZ2V0RGltZW5zaW9uID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHdpbmRvd1Njcm9sbCkge1xuICAgIHZhciBlbCA9IGdldERyYWdnYWJsZVJlZigpO1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBnZXQgZGltZW5zaW9uIHdoZW4gbm8gcmVmIGlzIHNldCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCk7XG4gIH0sIFtkZXNjcmlwdG9yLCBnZXREcmFnZ2FibGVSZWZdKTtcbiAgdmFyIGVudHJ5ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXF1ZUlkOiB1bmlxdWVJZCxcbiAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgZ2V0RGltZW5zaW9uOiBnZXREaW1lbnNpb25cbiAgICB9O1xuICB9LCBbZGVzY3JpcHRvciwgZ2V0RGltZW5zaW9uLCBvcHRpb25zLCB1bmlxdWVJZF0pO1xuICB2YXIgcHVibGlzaGVkUmVmID0gdXNlUmVmKGVudHJ5KTtcbiAgdmFyIGlzRmlyc3RQdWJsaXNoUmVmID0gdXNlUmVmKHRydWUpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUucmVnaXN0ZXIocHVibGlzaGVkUmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVnaXN0cnkuZHJhZ2dhYmxlLnVucmVnaXN0ZXIocHVibGlzaGVkUmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtyZWdpc3RyeS5kcmFnZ2FibGVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQpIHtcbiAgICAgIGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHB1Ymxpc2hlZFJlZi5jdXJyZW50O1xuICAgIHB1Ymxpc2hlZFJlZi5jdXJyZW50ID0gZW50cnk7XG4gICAgcmVnaXN0cnkuZHJhZ2dhYmxlLnVwZGF0ZShlbnRyeSwgbGFzdCk7XG4gIH0sIFtlbnRyeSwgcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBwcmVmaXgoaWQpIHtcbiAgICAgIHJldHVybiBcIkRyYWdnYWJsZVtpZDogXCIgKyBpZCArIFwiXTogXCI7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gcHJvcHMuZHJhZ2dhYmxlSWQ7XG4gICAgIWlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIHJlcXVpcmVzIGEgZHJhZ2dhYmxlSWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJEcmFnZ2FibGUgcmVxdWlyZXMgYSBbc3RyaW5nXSBkcmFnZ2FibGVJZC5cXG4gICAgICBQcm92aWRlZDogW3R5cGU6IFwiICsgdHlwZW9mIGlkICsgXCJdICh2YWx1ZTogXCIgKyBpZCArIFwiKVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIWlzSW50ZWdlcihwcm9wcy5pbmRleCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIHByZWZpeChpZCkgKyBcIiByZXF1aXJlcyBhbiBpbnRlZ2VyIGluZGV4IHByb3BcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb3BzLm1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZ2V0UmVmKCkpO1xuXG4gICAgaWYgKHByb3BzLmlzRW5hYmxlZCkge1xuICAgICAgIWZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBwcmVmaXgoaWQpICsgXCIgVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGVcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VDbG9uZVByb3BWYWxpZGF0aW9uKGlzQ2xvbmUpIHtcbiAgdXNlRGV2KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5pdGlhbFJlZiA9IHVzZVJlZihpc0Nsb25lKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoZnVuY3Rpb24gKCkge1xuICAgICAgIShpc0Nsb25lID09PSBpbml0aWFsUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIGlzQ2xvbmUgcHJvcCB2YWx1ZSBjaGFuZ2VkIGR1cmluZyBjb21wb25lbnQgbGlmZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9LCBbaXNDbG9uZV0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJldmVudEh0bWw1RG5kKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmZ1bmN0aW9uIERyYWdnYWJsZShwcm9wcykge1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgc2V0UmVmID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgfSwgW10pO1xuICB2YXIgZ2V0UmVmID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgfSwgW10pO1xuXG4gIHZhciBfdXNlUmVxdWlyZWRDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KEFwcENvbnRleHQpLFxuICAgICAgY29udGV4dElkID0gX3VzZVJlcXVpcmVkQ29udGV4dC5jb250ZXh0SWQsXG4gICAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCA9IF91c2VSZXF1aXJlZENvbnRleHQuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsXG4gICAgICByZWdpc3RyeSA9IF91c2VSZXF1aXJlZENvbnRleHQucmVnaXN0cnk7XG5cbiAgdmFyIF91c2VSZXF1aXJlZENvbnRleHQyID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpLFxuICAgICAgdHlwZSA9IF91c2VSZXF1aXJlZENvbnRleHQyLnR5cGUsXG4gICAgICBkcm9wcGFibGVJZCA9IF91c2VSZXF1aXJlZENvbnRleHQyLmRyb3BwYWJsZUlkO1xuXG4gIHZhciBkZXNjcmlwdG9yID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwcm9wcy5kcmFnZ2FibGVJZCxcbiAgICAgIGluZGV4OiBwcm9wcy5pbmRleCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBkcm9wcGFibGVJZDogZHJvcHBhYmxlSWRcbiAgICB9O1xuICB9LCBbcHJvcHMuZHJhZ2dhYmxlSWQsIHByb3BzLmluZGV4LCB0eXBlLCBkcm9wcGFibGVJZF0pO1xuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIGRyYWdnYWJsZUlkID0gcHJvcHMuZHJhZ2dhYmxlSWQsXG4gICAgICBpc0VuYWJsZWQgPSBwcm9wcy5pc0VuYWJsZWQsXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyA9IHByb3BzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgPSBwcm9wcy5jYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICAgIGlzQ2xvbmUgPSBwcm9wcy5pc0Nsb25lLFxuICAgICAgbWFwcGVkID0gcHJvcHMubWFwcGVkLFxuICAgICAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uID0gcHJvcHMuZHJvcEFuaW1hdGlvbkZpbmlzaGVkO1xuICB1c2VWYWxpZGF0aW9uJDEocHJvcHMsIGNvbnRleHRJZCwgZ2V0UmVmKTtcbiAgdXNlQ2xvbmVQcm9wVmFsaWRhdGlvbihpc0Nsb25lKTtcblxuICBpZiAoIWlzQ2xvbmUpIHtcbiAgICB2YXIgZm9yUHVibGlzaGVyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgICByZWdpc3RyeTogcmVnaXN0cnksXG4gICAgICAgIGdldERyYWdnYWJsZVJlZjogZ2V0UmVmLFxuICAgICAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50czogY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgICAgaXNFbmFibGVkOiBpc0VuYWJsZWRcbiAgICAgIH07XG4gICAgfSwgW2Rlc2NyaXB0b3IsIHJlZ2lzdHJ5LCBnZXRSZWYsIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLCBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcywgaXNFbmFibGVkXSk7XG4gICAgdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGZvclB1Ymxpc2hlcik7XG4gIH1cblxuICB2YXIgZHJhZ0hhbmRsZVByb3BzID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzRW5hYmxlZCA/IHtcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgcm9sZTogJ2J1dHRvbicsXG4gICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgICAgJ2RhdGEtcmJkLWRyYWctaGFuZGxlLWRyYWdnYWJsZS1pZCc6IGRyYWdnYWJsZUlkLFxuICAgICAgJ2RhdGEtcmJkLWRyYWctaGFuZGxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWQsXG4gICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgb25EcmFnU3RhcnQ6IHByZXZlbnRIdG1sNURuZFxuICAgIH0gOiBudWxsO1xuICB9LCBbY29udGV4dElkLCBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCwgZHJhZ2dhYmxlSWQsIGlzRW5hYmxlZF0pO1xuICB2YXIgb25Nb3ZlRW5kID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKG1hcHBlZC50eXBlICE9PSAnRFJBR0dJTkcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFtYXBwZWQuZHJvcHBpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJvcGVydHlOYW1lICE9PSAndHJhbnNmb3JtJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbigpO1xuICB9LCBbZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uLCBtYXBwZWRdKTtcbiAgdmFyIHByb3ZpZGVkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gZ2V0U3R5bGUkMShtYXBwZWQpO1xuICAgIHZhciBvblRyYW5zaXRpb25FbmQgPSBtYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJyAmJiBtYXBwZWQuZHJvcHBpbmcgPyBvbk1vdmVFbmQgOiBudWxsO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBpbm5lclJlZjogc2V0UmVmLFxuICAgICAgZHJhZ2dhYmxlUHJvcHM6IHtcbiAgICAgICAgJ2RhdGEtcmJkLWRyYWdnYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgICAgICAnZGF0YS1yYmQtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kOiBvblRyYW5zaXRpb25FbmRcbiAgICAgIH0sXG4gICAgICBkcmFnSGFuZGxlUHJvcHM6IGRyYWdIYW5kbGVQcm9wc1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW2NvbnRleHRJZCwgZHJhZ0hhbmRsZVByb3BzLCBkcmFnZ2FibGVJZCwgbWFwcGVkLCBvbk1vdmVFbmQsIHNldFJlZl0pO1xuICB2YXIgcnVicmljID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRyYWdnYWJsZUlkOiBkZXNjcmlwdG9yLmlkLFxuICAgICAgdHlwZTogZGVzY3JpcHRvci50eXBlLFxuICAgICAgc291cmNlOiB7XG4gICAgICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgICAgICBkcm9wcGFibGVJZDogZGVzY3JpcHRvci5kcm9wcGFibGVJZFxuICAgICAgfVxuICAgIH07XG4gIH0sIFtkZXNjcmlwdG9yLmRyb3BwYWJsZUlkLCBkZXNjcmlwdG9yLmlkLCBkZXNjcmlwdG9yLmluZGV4LCBkZXNjcmlwdG9yLnR5cGVdKTtcbiAgcmV0dXJuIGNoaWxkcmVuKHByb3ZpZGVkLCBtYXBwZWQuc25hcHNob3QsIHJ1YnJpYyk7XG59XG5cbnZhciBpc1N0cmljdEVxdWFsID0gKGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufSk7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQgPSAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICB2YXIgY29tYmluZSA9IHJlc3VsdC5jb21iaW5lLFxuICAgICAgZGVzdGluYXRpb24gPSByZXN1bHQuZGVzdGluYXRpb247XG5cbiAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uLmRyb3BwYWJsZUlkO1xuICB9XG5cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gY29tYmluZS5kcm9wcGFibGVJZDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSk7XG5cbnZhciBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQgPSBmdW5jdGlvbiBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQuY29tYmluZSA/IHJlc3VsdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5cbnZhciBnZXRDb21iaW5lV2l0aEZyb21JbXBhY3QgPSBmdW5jdGlvbiBnZXRDb21iaW5lV2l0aEZyb21JbXBhY3QoaW1wYWN0KSB7XG4gIHJldHVybiBpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyA/IGltcGFjdC5hdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGdldERyYWdnYWJsZVNlbGVjdG9yKCkge1xuICB2YXIgbWVtb2l6ZWRPZmZzZXQgPSBtZW1vaXplT25lKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfSk7XG4gIHZhciBnZXRNZW1vaXplZFNuYXBzaG90ID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgZHJvcHBpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICAgIGlzQ2xvbmU6IGlzQ2xvbmUsXG4gICAgICBpc0Ryb3BBbmltYXRpbmc6IEJvb2xlYW4oZHJvcHBpbmcpLFxuICAgICAgZHJvcEFuaW1hdGlvbjogZHJvcHBpbmcsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgZHJhZ2dpbmdPdmVyOiBkcmFnZ2luZ092ZXIsXG4gICAgICBjb21iaW5lV2l0aDogY29tYmluZVdpdGgsXG4gICAgICBjb21iaW5lVGFyZ2V0Rm9yOiBudWxsXG4gICAgfTtcbiAgfSk7XG4gIHZhciBnZXRNZW1vaXplZFByb3BzID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAob2Zmc2V0LCBtb2RlLCBkaW1lbnNpb24sIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIGZvcmNlU2hvdWxkQW5pbWF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXBwZWQ6IHtcbiAgICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgICAgZHJvcHBpbmc6IG51bGwsXG4gICAgICAgIGRyYWdnaW5nT3ZlcjogZHJhZ2dpbmdPdmVyLFxuICAgICAgICBjb21iaW5lV2l0aDogY29tYmluZVdpdGgsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBkaW1lbnNpb246IGRpbWVuc2lvbixcbiAgICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBmb3JjZVNob3VsZEFuaW1hdGUsXG4gICAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KG1vZGUsIGlzQ2xvbmUsIGRyYWdnaW5nT3ZlciwgY29tYmluZVdpdGgsIG51bGwpXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgaWYgKHN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIGlmIChzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0ID0gc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0O1xuICAgICAgdmFyIGRpbWVuc2lvbiA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tvd25Qcm9wcy5kcmFnZ2FibGVJZF07XG4gICAgICB2YXIgZHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KTtcbiAgICAgIHZhciBjb21iaW5lV2l0aCA9IGdldENvbWJpbmVXaXRoRnJvbUltcGFjdChzdGF0ZS5pbXBhY3QpO1xuICAgICAgdmFyIGZvcmNlU2hvdWxkQW5pbWF0ZSA9IHN0YXRlLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG1lbW9pemVkT2Zmc2V0KG9mZnNldC54LCBvZmZzZXQueSksIHN0YXRlLm1vdmVtZW50TW9kZSwgZGltZW5zaW9uLCBvd25Qcm9wcy5pc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBmb3JjZVNob3VsZEFuaW1hdGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcblxuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgIT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDbG9uZSA9IG93blByb3BzLmlzQ2xvbmU7XG4gICAgICB2YXIgX2RpbWVuc2lvbiA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tvd25Qcm9wcy5kcmFnZ2FibGVJZF07XG4gICAgICB2YXIgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIHZhciBtb2RlID0gcmVzdWx0Lm1vZGU7XG5cbiAgICAgIHZhciBfZHJhZ2dpbmdPdmVyID0gd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KHJlc3VsdCk7XG5cbiAgICAgIHZhciBfY29tYmluZVdpdGggPSBnZXRDb21iaW5lV2l0aEZyb21SZXN1bHQocmVzdWx0KTtcblxuICAgICAgdmFyIGR1cmF0aW9uID0gc3RhdGUuZHJvcER1cmF0aW9uO1xuICAgICAgdmFyIGRyb3BwaW5nID0ge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGN1cnZlOiBjdXJ2ZXMuZHJvcCxcbiAgICAgICAgbW92ZVRvOiBzdGF0ZS5uZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgICAgICBvcGFjaXR5OiBfY29tYmluZVdpdGggPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IG51bGwsXG4gICAgICAgIHNjYWxlOiBfY29tYmluZVdpdGggPyBjb21iaW5lLnNjYWxlLmRyb3AgOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFwcGVkOiB7XG4gICAgICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgICAgICBvZmZzZXQ6IHN0YXRlLm5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgICAgZGltZW5zaW9uOiBfZGltZW5zaW9uLFxuICAgICAgICAgIGRyb3BwaW5nOiBkcm9wcGluZyxcbiAgICAgICAgICBkcmFnZ2luZ092ZXI6IF9kcmFnZ2luZ092ZXIsXG4gICAgICAgICAgY29tYmluZVdpdGg6IF9jb21iaW5lV2l0aCxcbiAgICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogbnVsbCxcbiAgICAgICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChtb2RlLCBpc0Nsb25lLCBfZHJhZ2dpbmdPdmVyLCBfY29tYmluZVdpdGgsIGRyb3BwaW5nKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U25hcHNob3QoY29tYmluZVRhcmdldEZvcikge1xuICByZXR1cm4ge1xuICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgIGlzRHJvcEFuaW1hdGluZzogZmFsc2UsXG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgZHJvcEFuaW1hdGlvbjogbnVsbCxcbiAgICBtb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nT3ZlcjogbnVsbCxcbiAgICBjb21iaW5lVGFyZ2V0Rm9yOiBjb21iaW5lVGFyZ2V0Rm9yLFxuICAgIGNvbWJpbmVXaXRoOiBudWxsXG4gIH07XG59XG5cbnZhciBhdFJlc3QgPSB7XG4gIG1hcHBlZDoge1xuICAgIHR5cGU6ICdTRUNPTkRBUlknLFxuICAgIG9mZnNldDogb3JpZ2luLFxuICAgIGNvbWJpbmVUYXJnZXRGb3I6IG51bGwsXG4gICAgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudDogdHJ1ZSxcbiAgICBzbmFwc2hvdDogZ2V0U2Vjb25kYXJ5U25hcHNob3QobnVsbClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U2VsZWN0b3IoKSB7XG4gIHZhciBtZW1vaXplZE9mZnNldCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9KTtcbiAgdmFyIGdldE1lbW9pemVkU25hcHNob3QgPSBtZW1vaXplT25lKGdldFNlY29uZGFyeVNuYXBzaG90KTtcbiAgdmFyIGdldE1lbW9pemVkUHJvcHMgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHNob3VsZEFuaW1hdGVEaXNwbGFjZW1lbnQpIHtcbiAgICBpZiAoY29tYmluZVRhcmdldEZvciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb21iaW5lVGFyZ2V0Rm9yID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWFwcGVkOiB7XG4gICAgICAgIHR5cGU6ICdTRUNPTkRBUlknLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgY29tYmluZVRhcmdldEZvcjogY29tYmluZVRhcmdldEZvcixcbiAgICAgICAgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudDogc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCxcbiAgICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QoY29tYmluZVRhcmdldEZvcilcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICB2YXIgZ2V0RmFsbGJhY2sgPSBmdW5jdGlvbiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVUYXJnZXRGb3IgPyBnZXRNZW1vaXplZFByb3BzKG9yaWdpbiwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSkgOiBudWxsO1xuICB9O1xuXG4gIHZhciBnZXRQcm9wcyA9IGZ1bmN0aW9uIGdldFByb3BzKG93bklkLCBkcmFnZ2luZ0lkLCBpbXBhY3QsIGFmdGVyQ3JpdGljYWwpIHtcbiAgICB2YXIgdmlzdWFsRGlzcGxhY2VtZW50ID0gaW1wYWN0LmRpc3BsYWNlZC52aXNpYmxlW293bklkXTtcbiAgICB2YXIgaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCA9IEJvb2xlYW4oYWZ0ZXJDcml0aWNhbC5pblZpcnR1YWxMaXN0ICYmIGFmdGVyQ3JpdGljYWwuZWZmZWN0ZWRbb3duSWRdKTtcbiAgICB2YXIgY29tYmluZSA9IHRyeUdldENvbWJpbmUoaW1wYWN0KTtcbiAgICB2YXIgY29tYmluZVRhcmdldEZvciA9IGNvbWJpbmUgJiYgY29tYmluZS5kcmFnZ2FibGVJZCA9PT0gb3duSWQgPyBkcmFnZ2luZ0lkIDogbnVsbDtcblxuICAgIGlmICghdmlzdWFsRGlzcGxhY2VtZW50KSB7XG4gICAgICBpZiAoIWlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKGNvbWJpbmVUYXJnZXRGb3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW1wYWN0LmRpc3BsYWNlZC5pbnZpc2libGVbb3duSWRdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlID0gbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpO1xuXG4gICAgICB2YXIgX29mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGNoYW5nZS54LCBjaGFuZ2UueSk7XG5cbiAgICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKF9vZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0KSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soY29tYmluZVRhcmdldEZvcik7XG4gICAgfVxuXG4gICAgdmFyIGRpc3BsYWNlQnkgPSBpbXBhY3QuZGlzcGxhY2VkQnkucG9pbnQ7XG4gICAgdmFyIG9mZnNldCA9IG1lbW9pemVkT2Zmc2V0KGRpc3BsYWNlQnkueCwgZGlzcGxhY2VCeS55KTtcbiAgICByZXR1cm4gZ2V0TWVtb2l6ZWRQcm9wcyhvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IsIHZpc3VhbERpc3BsYWNlbWVudC5zaG91bGRBbmltYXRlKTtcbiAgfTtcblxuICB2YXIgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRQcm9wcyhvd25Qcm9wcy5kcmFnZ2FibGVJZCwgc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkLCBzdGF0ZS5pbXBhY3QsIHN0YXRlLmFmdGVyQ3JpdGljYWwpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcblxuICAgICAgaWYgKGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgPT09IG93blByb3BzLmRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0UHJvcHMob3duUHJvcHMuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5pbXBhY3QsIGNvbXBsZXRlZC5hZnRlckNyaXRpY2FsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gc2VsZWN0b3I7XG59XG5cbnZhciBtYWtlTWFwU3RhdGVUb1Byb3BzID0gZnVuY3Rpb24gbWFrZU1hcFN0YXRlVG9Qcm9wcygpIHtcbiAgdmFyIGRyYWdnaW5nU2VsZWN0b3IgPSBnZXREcmFnZ2FibGVTZWxlY3RvcigpO1xuICB2YXIgc2Vjb25kYXJ5U2VsZWN0b3IgPSBnZXRTZWNvbmRhcnlTZWxlY3RvcigpO1xuXG4gIHZhciBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykge1xuICAgIHJldHVybiBkcmFnZ2luZ1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykgfHwgc2Vjb25kYXJ5U2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBhdFJlc3Q7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbnZhciBtYXBEaXNwYXRjaFRvUHJvcHMgPSB7XG4gIGRyb3BBbmltYXRpb25GaW5pc2hlZDogZHJvcEFuaW1hdGlvbkZpbmlzaGVkXG59O1xudmFyIENvbm5lY3RlZERyYWdnYWJsZSA9IGNvbm5lY3QobWFrZU1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBudWxsLCB7XG4gIGNvbnRleHQ6IFN0b3JlQ29udGV4dCxcbiAgcHVyZTogdHJ1ZSxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsOiBpc1N0cmljdEVxdWFsXG59KShEcmFnZ2FibGUpO1xuXG5mdW5jdGlvbiBQcml2YXRlRHJhZ2dhYmxlKHByb3BzKSB7XG4gIHZhciBkcm9wcGFibGVDb250ZXh0ID0gdXNlUmVxdWlyZWRDb250ZXh0KERyb3BwYWJsZUNvbnRleHQpO1xuICB2YXIgaXNVc2luZ0Nsb25lRm9yID0gZHJvcHBhYmxlQ29udGV4dC5pc1VzaW5nQ2xvbmVGb3I7XG5cbiAgaWYgKGlzVXNpbmdDbG9uZUZvciA9PT0gcHJvcHMuZHJhZ2dhYmxlSWQgJiYgIXByb3BzLmlzQ2xvbmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbm5lY3RlZERyYWdnYWJsZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gUHVibGljRHJhZ2dhYmxlKHByb3BzKSB7XG4gIHZhciBpc0VuYWJsZWQgPSB0eXBlb2YgcHJvcHMuaXNEcmFnRGlzYWJsZWQgPT09ICdib29sZWFuJyA/ICFwcm9wcy5pc0RyYWdEaXNhYmxlZCA6IHRydWU7XG4gIHZhciBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyA9IEJvb2xlYW4ocHJvcHMuZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nKTtcbiAgdmFyIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzID0gQm9vbGVhbihwcm9wcy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGlzQ2xvbmU6IGZhbHNlLFxuICAgIGlzRW5hYmxlZDogaXNFbmFibGVkLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3NcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBEcm9wcGFibGUocHJvcHMpIHtcbiAgdmFyIGFwcENvbnRleHQgPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICAhYXBwQ29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIGFwcCBjb250ZXh0JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgY29udGV4dElkID0gYXBwQ29udGV4dC5jb250ZXh0SWQsXG4gICAgICBpc01vdmVtZW50QWxsb3dlZCA9IGFwcENvbnRleHQuaXNNb3ZlbWVudEFsbG93ZWQ7XG4gIHZhciBkcm9wcGFibGVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBkcm9wcGFibGVJZCA9IHByb3BzLmRyb3BwYWJsZUlkLFxuICAgICAgdHlwZSA9IHByb3BzLnR5cGUsXG4gICAgICBtb2RlID0gcHJvcHMubW9kZSxcbiAgICAgIGRpcmVjdGlvbiA9IHByb3BzLmRpcmVjdGlvbixcbiAgICAgIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nID0gcHJvcHMuaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcsXG4gICAgICBpc0Ryb3BEaXNhYmxlZCA9IHByb3BzLmlzRHJvcERpc2FibGVkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZCA9IHByb3BzLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBzbmFwc2hvdCA9IHByb3BzLnNuYXBzaG90LFxuICAgICAgdXNlQ2xvbmUgPSBwcm9wcy51c2VDbG9uZSxcbiAgICAgIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsID0gcHJvcHMudXBkYXRlVmlld3BvcnRNYXhTY3JvbGwsXG4gICAgICBnZXRDb250YWluZXJGb3JDbG9uZSA9IHByb3BzLmdldENvbnRhaW5lckZvckNsb25lO1xuICB2YXIgZ2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkcm9wcGFibGVSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB2YXIgc2V0RHJvcHBhYmxlUmVmID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgZHJvcHBhYmxlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW10pO1xuICB2YXIgZ2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdmFyIHNldFBsYWNlaG9sZGVyUmVmID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIHVzZVZhbGlkYXRpb24oe1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICBnZXREcm9wcGFibGVSZWY6IGdldERyb3BwYWJsZVJlZixcbiAgICBnZXRQbGFjZWhvbGRlclJlZjogZ2V0UGxhY2Vob2xkZXJSZWZcbiAgfSk7XG4gIHZhciBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNNb3ZlbWVudEFsbG93ZWQoKSkge1xuICAgICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwoe1xuICAgICAgICBtYXhTY3JvbGw6IGdldE1heFdpbmRvd1Njcm9sbCgpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtpc01vdmVtZW50QWxsb3dlZCwgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGxdKTtcbiAgdXNlRHJvcHBhYmxlUHVibGlzaGVyKHtcbiAgICBkcm9wcGFibGVJZDogZHJvcHBhYmxlSWQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBtb2RlOiBtb2RlLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgIGlzRHJvcERpc2FibGVkOiBpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkOiBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nOiBpZ25vcmVDb250YWluZXJDbGlwcGluZyxcbiAgICBnZXREcm9wcGFibGVSZWY6IGdldERyb3BwYWJsZVJlZlxuICB9KTtcbiAgdmFyIHBsYWNlaG9sZGVyID0gUmVhY3QuY3JlYXRlRWxlbWVudChBbmltYXRlSW5PdXQsIHtcbiAgICBvbjogcHJvcHMucGxhY2Vob2xkZXIsXG4gICAgc2hvdWxkQW5pbWF0ZTogcHJvcHMuc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyXG4gIH0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG9uQ2xvc2UgPSBfcmVmLm9uQ2xvc2UsXG4gICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIGFuaW1hdGUgPSBfcmVmLmFuaW1hdGU7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhY2Vob2xkZXIkMSwge1xuICAgICAgcGxhY2Vob2xkZXI6IGRhdGEsXG4gICAgICBvbkNsb3NlOiBvbkNsb3NlLFxuICAgICAgaW5uZXJSZWY6IHNldFBsYWNlaG9sZGVyUmVmLFxuICAgICAgYW5pbWF0ZTogYW5pbWF0ZSxcbiAgICAgIGNvbnRleHRJZDogY29udGV4dElkLFxuICAgICAgb25UcmFuc2l0aW9uRW5kOiBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZFxuICAgIH0pO1xuICB9KTtcbiAgdmFyIHByb3ZpZGVkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlubmVyUmVmOiBzZXREcm9wcGFibGVSZWYsXG4gICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsXG4gICAgICBkcm9wcGFibGVQcm9wczoge1xuICAgICAgICAnZGF0YS1yYmQtZHJvcHBhYmxlLWlkJzogZHJvcHBhYmxlSWQsXG4gICAgICAgICdkYXRhLXJiZC1kcm9wcGFibGUtY29udGV4dC1pZCc6IGNvbnRleHRJZFxuICAgICAgfVxuICAgIH07XG4gIH0sIFtjb250ZXh0SWQsIGRyb3BwYWJsZUlkLCBwbGFjZWhvbGRlciwgc2V0RHJvcHBhYmxlUmVmXSk7XG4gIHZhciBpc1VzaW5nQ2xvbmVGb3IgPSB1c2VDbG9uZSA/IHVzZUNsb25lLmRyYWdnaW5nLmRyYWdnYWJsZUlkIDogbnVsbDtcbiAgdmFyIGRyb3BwYWJsZUNvbnRleHQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJvcHBhYmxlSWQ6IGRyb3BwYWJsZUlkLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlzVXNpbmdDbG9uZUZvcjogaXNVc2luZ0Nsb25lRm9yXG4gICAgfTtcbiAgfSwgW2Ryb3BwYWJsZUlkLCBpc1VzaW5nQ2xvbmVGb3IsIHR5cGVdKTtcblxuICBmdW5jdGlvbiBnZXRDbG9uZSgpIHtcbiAgICBpZiAoIXVzZUNsb25lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZHJhZ2dpbmcgPSB1c2VDbG9uZS5kcmFnZ2luZyxcbiAgICAgICAgcmVuZGVyID0gdXNlQ2xvbmUucmVuZGVyO1xuICAgIHZhciBub2RlID0gUmVhY3QuY3JlYXRlRWxlbWVudChQcml2YXRlRHJhZ2dhYmxlLCB7XG4gICAgICBkcmFnZ2FibGVJZDogZHJhZ2dpbmcuZHJhZ2dhYmxlSWQsXG4gICAgICBpbmRleDogZHJhZ2dpbmcuc291cmNlLmluZGV4LFxuICAgICAgaXNDbG9uZTogdHJ1ZSxcbiAgICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBmYWxzZSxcbiAgICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzOiB0cnVlXG4gICAgfSwgZnVuY3Rpb24gKGRyYWdnYWJsZVByb3ZpZGVkLCBkcmFnZ2FibGVTbmFwc2hvdCkge1xuICAgICAgcmV0dXJuIHJlbmRlcihkcmFnZ2FibGVQcm92aWRlZCwgZHJhZ2dhYmxlU25hcHNob3QsIGRyYWdnaW5nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKG5vZGUsIGdldENvbnRhaW5lckZvckNsb25lKCkpO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcHBhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkcm9wcGFibGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKHByb3ZpZGVkLCBzbmFwc2hvdCksIGdldENsb25lKCkpO1xufVxuXG52YXIgaXNNYXRjaGluZ1R5cGUgPSBmdW5jdGlvbiBpc01hdGNoaW5nVHlwZSh0eXBlLCBjcml0aWNhbCkge1xuICByZXR1cm4gdHlwZSA9PT0gY3JpdGljYWwuZHJvcHBhYmxlLnR5cGU7XG59O1xuXG52YXIgZ2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlKGNyaXRpY2FsLCBkaW1lbnNpb25zKSB7XG4gIHJldHVybiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbn07XG5cbnZhciBtYWtlTWFwU3RhdGVUb1Byb3BzJDEgPSBmdW5jdGlvbiBtYWtlTWFwU3RhdGVUb1Byb3BzKCkge1xuICB2YXIgaWRsZVdpdGhBbmltYXRpb24gPSB7XG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiB0cnVlLFxuICAgIHNuYXBzaG90OiB7XG4gICAgICBpc0RyYWdnaW5nT3ZlcjogZmFsc2UsXG4gICAgICBkcmFnZ2luZ092ZXJXaXRoOiBudWxsLFxuICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IG51bGwsXG4gICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IGZhbHNlXG4gICAgfSxcbiAgICB1c2VDbG9uZTogbnVsbFxuICB9O1xuXG4gIHZhciBpZGxlV2l0aG91dEFuaW1hdGlvbiA9IF9leHRlbmRzKHt9LCBpZGxlV2l0aEFuaW1hdGlvbiwge1xuICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogZmFsc2VcbiAgfSk7XG5cbiAgdmFyIGdldERyYWdnYWJsZVJ1YnJpYyA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKGRlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhZ2dhYmxlSWQ6IGRlc2NyaXB0b3IuaWQsXG4gICAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHZhciBnZXRNYXBQcm9wcyA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKGlkLCBpc0VuYWJsZWQsIGlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIsIGlzRHJhZ2dpbmdPdmVyRm9ySW1wYWN0LCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpIHtcbiAgICB2YXIgZHJhZ2dhYmxlSWQgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmlkO1xuICAgIHZhciBpc0hvbWUgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBpZDtcblxuICAgIGlmIChpc0hvbWUpIHtcbiAgICAgIHZhciB1c2VDbG9uZSA9IHJlbmRlckNsb25lID8ge1xuICAgICAgICByZW5kZXI6IHJlbmRlckNsb25lLFxuICAgICAgICBkcmFnZ2luZzogZ2V0RHJhZ2dhYmxlUnVicmljKGRyYWdnaW5nLmRlc2NyaXB0b3IpXG4gICAgICB9IDogbnVsbDtcbiAgICAgIHZhciBfc25hcHNob3QgPSB7XG4gICAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgICBkcmFnZ2luZ092ZXJXaXRoOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyID8gZHJhZ2dhYmxlSWQgOiBudWxsLFxuICAgICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZSxcbiAgICAgICAgc25hcHNob3Q6IF9zbmFwc2hvdCxcbiAgICAgICAgdXNlQ2xvbmU6IHVzZUNsb25lXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaXNFbmFibGVkKSB7XG4gICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgfVxuXG4gICAgaWYgKCFpc0RyYWdnaW5nT3ZlckZvckltcGFjdCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRoQW5pbWF0aW9uO1xuICAgIH1cblxuICAgIHZhciBzbmFwc2hvdCA9IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgIHNuYXBzaG90OiBzbmFwc2hvdCxcbiAgICAgIHVzZUNsb25lOiBudWxsXG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgdmFyIGlkID0gb3duUHJvcHMuZHJvcHBhYmxlSWQ7XG4gICAgdmFyIHR5cGUgPSBvd25Qcm9wcy50eXBlO1xuICAgIHZhciBpc0VuYWJsZWQgPSAhb3duUHJvcHMuaXNEcm9wRGlzYWJsZWQ7XG4gICAgdmFyIHJlbmRlckNsb25lID0gb3duUHJvcHMucmVuZGVyQ2xvbmU7XG5cbiAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdmFyIGNyaXRpY2FsID0gc3RhdGUuY3JpdGljYWw7XG5cbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlKGNyaXRpY2FsLCBzdGF0ZS5kaW1lbnNpb25zKTtcbiAgICAgIHZhciBpc0RyYWdnaW5nT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCkgPT09IGlkO1xuICAgICAgcmV0dXJuIGdldE1hcFByb3BzKGlkLCBpc0VuYWJsZWQsIGlzRHJhZ2dpbmdPdmVyLCBpc0RyYWdnaW5nT3ZlciwgZHJhZ2dpbmcsIHJlbmRlckNsb25lKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHZhciBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG5cbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgY29tcGxldGVkLmNyaXRpY2FsKSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBfZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY29tcGxldGVkLmNyaXRpY2FsLCBzdGF0ZS5kaW1lbnNpb25zKTtcblxuICAgICAgcmV0dXJuIGdldE1hcFByb3BzKGlkLCBpc0VuYWJsZWQsIHdoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdChjb21wbGV0ZWQucmVzdWx0KSA9PT0gaWQsIHdoYXRJc0RyYWdnZWRPdmVyKGNvbXBsZXRlZC5pbXBhY3QpID09PSBpZCwgX2RyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScgJiYgc3RhdGUuY29tcGxldGVkICYmICFzdGF0ZS5zaG91bGRGbHVzaCkge1xuICAgICAgdmFyIF9jb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG5cbiAgICAgIGlmICghaXNNYXRjaGluZ1R5cGUodHlwZSwgX2NvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2FzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKF9jb21wbGV0ZWQuaW1wYWN0KSA9PT0gaWQ7XG4gICAgICB2YXIgd2FzQ29tYmluaW5nID0gQm9vbGVhbihfY29tcGxldGVkLmltcGFjdC5hdCAmJiBfY29tcGxldGVkLmltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScpO1xuICAgICAgdmFyIGlzSG9tZSA9IF9jb21wbGV0ZWQuY3JpdGljYWwuZHJvcHBhYmxlLmlkID09PSBpZDtcblxuICAgICAgaWYgKHdhc092ZXIpIHtcbiAgICAgICAgcmV0dXJuIHdhc0NvbWJpbmluZyA/IGlkbGVXaXRoQW5pbWF0aW9uIDogaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hvbWUpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRoQW5pbWF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICB9O1xuXG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG52YXIgbWFwRGlzcGF0Y2hUb1Byb3BzJDEgPSB7XG4gIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsOiB1cGRhdGVWaWV3cG9ydE1heFNjcm9sbFxufTtcblxuZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgIWRvY3VtZW50LmJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdkb2N1bWVudC5ib2R5IGlzIG5vdCByZWFkeScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG59XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIG1vZGU6ICdzdGFuZGFyZCcsXG4gIHR5cGU6ICdERUZBVUxUJyxcbiAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICBpc0Ryb3BEaXNhYmxlZDogZmFsc2UsXG4gIGlzQ29tYmluZUVuYWJsZWQ6IGZhbHNlLFxuICBpZ25vcmVDb250YWluZXJDbGlwcGluZzogZmFsc2UsXG4gIHJlbmRlckNsb25lOiBudWxsLFxuICBnZXRDb250YWluZXJGb3JDbG9uZTogZ2V0Qm9keVxufTtcbnZhciBDb25uZWN0ZWREcm9wcGFibGUgPSBjb25uZWN0KG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSwgbWFwRGlzcGF0Y2hUb1Byb3BzJDEsIG51bGwsIHtcbiAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICBwdXJlOiB0cnVlLFxuICBhcmVTdGF0ZVByb3BzRXF1YWw6IGlzU3RyaWN0RXF1YWxcbn0pKERyb3BwYWJsZSk7XG5Db25uZWN0ZWREcm9wcGFibGUuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5leHBvcnQgeyBEcmFnRHJvcENvbnRleHQsIFB1YmxpY0RyYWdnYWJsZSBhcyBEcmFnZ2FibGUsIENvbm5lY3RlZERyb3BwYWJsZSBhcyBEcm9wcGFibGUsIHJlc2V0U2VydmVyQ29udGV4dCwgdXNlS2V5Ym9hcmRTZW5zb3IsIHVzZU1vdXNlU2Vuc29yLCB1c2VUb3VjaFNlbnNvciB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDb250ZXh0IiwiX2luaGVyaXRzTG9vc2UiLCJfZXh0ZW5kcyIsImNyZWF0ZVN0b3JlIiwiY3JlYXRlU3RvcmUkMSIsImFwcGx5TWlkZGxld2FyZSIsImNvbXBvc2UiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJQcm92aWRlciIsImNvbm5lY3QiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJnZXRSZWN0IiwiZXhwYW5kIiwib2Zmc2V0Iiwid2l0aFNjcm9sbCIsImdldEJveCIsImNyZWF0ZUJveCIsImNhbGN1bGF0ZUJveCIsIm1lbW9pemVPbmUiLCJyYWZTY2hkIiwiUmVhY3RET00iLCJpc1Byb2R1Y3Rpb24iLCJwcm9jZXNzIiwic3BhY2VzQW5kVGFicyIsImxpbmVTdGFydFdpdGhTcGFjZXMiLCJjbGVhbiIsInZhbHVlIiwicmVwbGFjZSIsInRyaW0iLCJnZXREZXZNZXNzYWdlIiwibWVzc2FnZSIsImdldEZvcm1hdHRlZE1lc3NhZ2UiLCJpc0Rpc2FibGVkRmxhZyIsImxvZyIsInR5cGUiLCJfY29uc29sZSIsIndpbmRvdyIsImNvbnNvbGUiLCJhcHBseSIsIndhcm5pbmciLCJiaW5kIiwiZXJyb3IiLCJub29wIiwiZ2V0T3B0aW9ucyIsInNoYXJlZCIsImZyb21CaW5kaW5nIiwiYmluZEV2ZW50cyIsImVsIiwiYmluZGluZ3MiLCJzaGFyZWRPcHRpb25zIiwidW5iaW5kaW5ncyIsIm1hcCIsImJpbmRpbmciLCJvcHRpb25zIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImZuIiwidW5iaW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVuYmluZEFsbCIsImZvckVhY2giLCJpc1Byb2R1Y3Rpb24kMSIsInByZWZpeCIsIlJiZEludmFyaWFudCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiRXJyb3JCb3VuZGFyeSIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGhpcyIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiY2FsbCIsImNvbmNhdCIsImNhbGxiYWNrcyIsIm9uV2luZG93RXJyb3IiLCJldmVudCIsImdldENhbGxiYWNrcyIsImlzRHJhZ2dpbmciLCJ0cnlBYm9ydCIsImVyciIsInByZXZlbnREZWZhdWx0IiwiRXJyb3IiLCJzZXRDYWxsYmFja3MiLCJfcHJvdG8iLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZENhdGNoIiwic2V0U3RhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJDb21wb25lbnQiLCJkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnMiLCJwb3NpdGlvbiIsImluZGV4Iiwib25EcmFnU3RhcnQiLCJzdGFydCIsInNvdXJjZSIsIndpdGhMb2NhdGlvbiIsImRlc3RpbmF0aW9uIiwiaXNJbkhvbWVMaXN0IiwiZHJvcHBhYmxlSWQiLCJzdGFydFBvc2l0aW9uIiwiZW5kUG9zaXRpb24iLCJ3aXRoQ29tYmluZSIsImlkIiwiY29tYmluZSIsImluSG9tZUxpc3QiLCJkcmFnZ2FibGVJZCIsIm9uRHJhZ1VwZGF0ZSIsInVwZGF0ZSIsImxvY2F0aW9uIiwicmV0dXJuZWRUb1N0YXJ0Iiwib25EcmFnRW5kIiwicmVzdWx0IiwicmVhc29uIiwicHJlc2V0Iiwib3JpZ2luIiwieCIsInkiLCJhZGQiLCJwb2ludDEiLCJwb2ludDIiLCJzdWJ0cmFjdCIsImlzRXF1YWwiLCJuZWdhdGUiLCJwb2ludCIsInBhdGNoIiwibGluZSIsIm90aGVyVmFsdWUiLCJfcmVmIiwiZGlzdGFuY2UiLCJNYXRoIiwic3FydCIsInBvdyIsImNsb3Nlc3QiLCJ0YXJnZXQiLCJwb2ludHMiLCJtaW4iLCJleGVjdXRlQ2xpcCIsImZyYW1lIiwic3ViamVjdCIsInRvcCIsIm1heCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0Iiwib2Zmc2V0QnlQb3NpdGlvbiIsInNwYWNpbmciLCJnZXRDb3JuZXJzIiwibm9TcGFjaW5nIiwic2Nyb2xsIiwiZGlmZiIsImRpc3BsYWNlbWVudCIsImluY3JlYXNlIiwiYXhpcyIsIndpdGhQbGFjZWhvbGRlciIsImluY3JlYXNlZEJ5IiwiX2V4dGVuZHMyIiwiZW5kIiwiY2xpcCIsInNob3VsZENsaXBTdWJqZWN0IiwicGFnZU1hcmdpbkJveCIsImdldFN1YmplY3QiLCJwYWdlIiwic2Nyb2xsZWQiLCJtYXJnaW5Cb3giLCJpbmNyZWFzZWQiLCJjbGlwcGVkIiwiYWN0aXZlIiwic2Nyb2xsRHJvcHBhYmxlIiwiZHJvcHBhYmxlIiwibmV3U2Nyb2xsIiwic2Nyb2xsYWJsZSIsInNjcm9sbERpZmYiLCJpbml0aWFsIiwic2Nyb2xsRGlzcGxhY2VtZW50IiwiY3VycmVudCIsImlzSW50ZWdlciIsIk51bWJlciIsImlzRmluaXRlIiwiZmxvb3IiLCJ2YWx1ZXMiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwiZmluZEluZGV4IiwibGlzdCIsInByZWRpY2F0ZSIsImkiLCJmaW5kIiwidW5kZWZpbmVkIiwidG9BcnJheSIsInNsaWNlIiwidG9Ecm9wcGFibGVNYXAiLCJkcm9wcGFibGVzIiwicmVkdWNlIiwicHJldmlvdXMiLCJkZXNjcmlwdG9yIiwidG9EcmFnZ2FibGVNYXAiLCJkcmFnZ2FibGVzIiwidG9Ecm9wcGFibGVMaXN0IiwidG9EcmFnZ2FibGVMaXN0IiwiZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZSIsImZpbHRlciIsImRyYWdnYWJsZSIsInNvcnQiLCJhIiwiYiIsInRyeUdldERlc3RpbmF0aW9uIiwiaW1wYWN0IiwiYXQiLCJ0cnlHZXRDb21iaW5lIiwicmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QiLCJyZW1vdmUiLCJpdGVtIiwibW92ZVRvTmV4dENvbWJpbmUiLCJpc01vdmluZ0ZvcndhcmQiLCJpbnNpZGVEZXN0aW5hdGlvbiIsInByZXZpb3VzSW1wYWN0IiwiaXNDb21iaW5lRW5hYmxlZCIsImdldEltcGFjdCIsImFsbCIsImRpc3BsYWNlZCIsImNsb3Nlc3RJZCIsIndpdGhvdXREcmFnZ2FibGUiLCJsYXN0IiwiaW5kZXhPZkNsb3Nlc3QiLCJkIiwicHJvcG9zZWRJbmRleCIsImJlZm9yZSIsImlzSG9tZU9mIiwibm9EaXNwbGFjZWRCeSIsImVtcHR5R3JvdXBzIiwiaW52aXNpYmxlIiwidmlzaWJsZSIsIm5vSW1wYWN0IiwiZGlzcGxhY2VkQnkiLCJpc1dpdGhpbiIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lIiwiaXNXaXRoaW5WZXJ0aWNhbCIsImlzV2l0aGluSG9yaXpvbnRhbCIsImlzQ29udGFpbmVkIiwiaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSIsImlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSIsImlzUGFydGlhbGx5Q29udGFpbmVkIiwiaXNCaWdnZXJWZXJ0aWNhbGx5IiwiaXNCaWdnZXJIb3Jpem9udGFsbHkiLCJpc1RhcmdldEJpZ2dlclRoYW5GcmFtZSIsImlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSIsInZlcnRpY2FsIiwiZGlyZWN0aW9uIiwiY3Jvc3NBeGlzTGluZSIsInNpemUiLCJjcm9zc0F4aXNTdGFydCIsImNyb3NzQXhpc0VuZCIsImNyb3NzQXhpc1NpemUiLCJob3Jpem9udGFsIiwiaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyIsImdldERyb3BwYWJsZURpc3BsYWNlZCIsImlzVmlzaWJsZUluRHJvcHBhYmxlIiwiaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4iLCJpc1Zpc2libGVJblZpZXdwb3J0Iiwidmlld3BvcnQiLCJpc1Zpc2libGUiLCJ0b0JlRGlzcGxhY2VkIiwid2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCIsImRpc3BsYWNlZFRhcmdldCIsImlzUGFydGlhbGx5VmlzaWJsZSIsImlzVG90YWxseVZpc2libGUiLCJpc1RvdGFsbHlWaXNpYmxlT25BeGlzIiwiZ2V0U2hvdWxkQW5pbWF0ZSIsImZvcmNlU2hvdWxkQW5pbWF0ZSIsInNob3VsZEFuaW1hdGUiLCJnZXRUYXJnZXQiLCJleHBhbmRCeSIsImdldERpc3BsYWNlbWVudEdyb3VwcyIsImFmdGVyRHJhZ2dpbmciLCJncm91cHMiLCJwdXNoIiwiZ2V0SW5kZXhPZkxhc3RJdGVtIiwiaW5kZXhPZkxhc3RJdGVtIiwiZ29BdEVuZCIsIm5ld0luZGV4IiwiY2FsY3VsYXRlUmVvcmRlckltcGFjdCIsIl9yZWYyIiwibWF0Y2giLCJ3aXRob3V0RHJhZ2dpbmciLCJzbGljZUZyb20iLCJpbmRleE9mIiwiaW1wYWN0ZWQiLCJkaWRTdGFydEFmdGVyQ3JpdGljYWwiLCJhZnRlckNyaXRpY2FsIiwiQm9vbGVhbiIsImVmZmVjdGVkIiwiZnJvbUNvbWJpbmUiLCJjb21iaW5lSWQiLCJjb21iaW5lV2l0aCIsImNvbWJpbmVXaXRoSW5kZXgiLCJkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCIsImZyb21SZW9yZGVyIiwiY3VycmVudEluZGV4IiwiZmlyc3RJbmRleCIsImxhc3RJbmRleCIsIm1vdmVUb05leHRJbmRleCIsIndhc0F0IiwiX25ld0luZGV4IiwiZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50IiwiaXNEaXNwbGFjZWQiLCJ3aGVuQ29tYmluaW5nIiwiY2VudGVyIiwiYm9yZGVyQm94IiwiZGlzcGxhY2VCeSIsImRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIiLCJib3giLCJtYXJnaW4iLCJkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciIsImdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciIsImlzTW92aW5nIiwiZ29BZnRlciIsIm1vdmVSZWxhdGl2ZVRvIiwiZ29CZWZvcmUiLCJnb0ludG9TdGFydCIsIl9yZWYzIiwibW92ZUludG8iLCJjb250ZW50Qm94Iiwid2hlblJlb3JkZXJpbmciLCJkcmFnZ2FibGVQYWdlIiwiY2xvc2VzdEFmdGVyIiwid2l0aERpc3BsYWNlbWVudCIsImdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQiLCJvcmlnaW5hbCIsImdldFBhZ2VCb3JkZXJCb3hDZW50ZXJGcm9tSW1wYWN0Iiwid2l0aG91dERpc3BsYWNlbWVudCIsInNjcm9sbFZpZXdwb3J0IiwidXBkYXRlZCIsImdldERyYWdnYWJsZXMiLCJpZHMiLCJ0cnlHZXRWaXNpYmxlIiwic3BlY3VsYXRpdmVseUluY3JlYXNlIiwibWF4U2Nyb2xsQ2hhbmdlIiwic2Nyb2xsZWRWaWV3cG9ydCIsInNjcm9sbGVkRHJvcHBhYmxlIiwid2l0aFZpZXdwb3J0U2Nyb2xsIiwid2l0aERyb3BwYWJsZVNjcm9sbCIsIm5ld0ltcGFjdCIsIndpdGhWaWV3cG9ydERpc3BsYWNlbWVudCIsImdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyIiwicGFnZUJvcmRlckJveENlbnRlciIsIndpdGhvdXRQYWdlU2Nyb2xsQ2hhbmdlIiwiY2xpZW50IiwiaXNUb3RhbGx5VmlzaWJsZUluTmV3TG9jYXRpb24iLCJuZXdQYWdlQm9yZGVyQm94Q2VudGVyIiwiX3JlZiRvbmx5T25NYWluQXhpcyIsIm9ubHlPbk1haW5BeGlzIiwiY2hhbmdlTmVlZGVkIiwic2hpZnRlZCIsIm1vdmVUb05leHRQbGFjZSIsInByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciIsInByZXZpb3VzQ2xpZW50U2VsZWN0aW9uIiwiaXNFbmFibGVkIiwiaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiIsImNsaWVudFNlbGVjdGlvbiIsInNjcm9sbEp1bXBSZXF1ZXN0IiwiY2F1dGlvdXMiLCJnZXRLbm93bkFjdGl2ZSIsInJlY3QiLCJnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlIiwiaXNCZXR3ZWVuU291cmNlQ2xpcHBlZCIsImNhbmRpZGF0ZXMiLCJhY3RpdmVPZlRhcmdldCIsImlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZCIsImZpcnN0Iiwic2Vjb25kIiwiYXJyYXkiLCJjb250YWlucyIsImlzV2l0aGluRHJvcHBhYmxlIiwiZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJnZXRDdXJyZW50UGFnZUJvcmRlckJveCIsImdldENsb3Nlc3REcmFnZ2FibGUiLCJzb3J0ZWQiLCJkaXN0YW5jZVRvQSIsImRpc3RhbmNlVG9CIiwiZ2V0RGlzcGxhY2VkQnkiLCJnZXRSZXF1aXJlZEdyb3d0aEZvclBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJTaXplIiwibW9kZSIsImF2YWlsYWJsZVNwYWNlIiwiaW5zaWRlRHJvcHBhYmxlIiwic3BhY2VVc2VkIiwic3VtIiwiZGltZW5zaW9uIiwicmVxdWlyZWRTcGFjZSIsIm5lZWRzVG9Hcm93QnkiLCJ3aXRoTWF4U2Nyb2xsIiwiYWRkUGxhY2Vob2xkZXIiLCJyZXF1aXJlZEdyb3d0aCIsImFkZGVkIiwib2xkRnJhbWVNYXhTY3JvbGwiLCJfc3ViamVjdCIsIm1heFNjcm9sbCIsIm5ld0ZyYW1lIiwicmVtb3ZlUGxhY2Vob2xkZXIiLCJfc3ViamVjdDIiLCJvbGRNYXhTY3JvbGwiLCJtb3ZlVG9OZXdEcm9wcGFibGUiLCJwcm9wb3NlZCIsInByb3Bvc2VkUGFnZUJvcmRlckJveENlbnRlciIsImlzR29pbmdCZWZvcmVUYXJnZXQiLCJyZWxhdGl2ZVRvIiwibW92ZUNyb3NzQXhpcyIsImlzT3ZlciIsIndoYXRJc0RyYWdnZWRPdmVyIiwiZ2V0RHJvcHBhYmxlT3ZlciIsIm1vdmVJbkRpcmVjdGlvbiIsInN0YXRlIiwiaXNBY3R1YWxseU92ZXIiLCJkaW1lbnNpb25zIiwiaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCIsImhvbWUiLCJjcml0aWNhbCIsImlzTW92aW5nT25NYWluQXhpcyIsImJvcmRlckJveENlbnRlciIsIl9zdGF0ZSRkaW1lbnNpb25zIiwic2VsZWN0aW9uIiwiaXNNb3ZlbWVudEFsbG93ZWQiLCJwaGFzZSIsImlzUG9zaXRpb25JbkZyYW1lIiwicnVuIiwiZ2V0SGFzT3ZlcmxhcCIsImdldEZ1cnRoZXN0QXdheSIsInBhZ2VCb3JkZXJCb3giLCJzdGFydENlbnRlciIsImNhbmRpZGF0ZSIsImdldERyb3BwYWJsZU92ZXIkMSIsImNoaWxkQ2VudGVyIiwiaXNTdGFydENvbnRhaW5lZCIsImlzRW5kQ29udGFpbmVkIiwib2Zmc2V0UmVjdEJ5UG9zaXRpb24iLCJhcmVhIiwiZ2V0SXNEaXNwbGFjZWQiLCJhdEluZGV4IiwiZ2V0UmVvcmRlckltcGFjdCIsInRhcmdldFJlY3QiLCJwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbCIsInRhcmdldFN0YXJ0IiwidGFyZ2V0RW5kIiwiY2hpbGQiLCJkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSIsImNvbWJpbmVUaHJlc2hvbGREaXZpc29yIiwiZ2V0Q29tYmluZUltcGFjdCIsImNoaWxkUmVjdCIsImNoaWxkU2l6ZSIsInRocmVzaG9sZCIsImdldERyYWdJbXBhY3QiLCJwYWdlT2Zmc2V0IiwiZGVzdGluYXRpb25JZCIsInBhdGNoRHJvcHBhYmxlTWFwIiwiY2xlYXJVbnVzZWRQbGFjZWhvbGRlciIsIm5vdyIsImxhc3REcm9wcGFibGUiLCJyZWNvbXB1dGVQbGFjZWhvbGRlcnMiLCJjbGVhbmVkIiwicGF0Y2hlZCIsImZvcmNlZENsaWVudFNlbGVjdGlvbiIsImZvcmNlZERpbWVuc2lvbnMiLCJmb3JjZWRWaWV3cG9ydCIsImZvcmNlZEltcGFjdCIsIndpdGhVcGRhdGVkUGxhY2Vob2xkZXJzIiwiZ2V0RHJhZ2dhYmxlcyQxIiwicmVjb21wdXRlIiwiZ2V0Q2xpZW50Qm9yZGVyQm94Q2VudGVyIiwicmVmcmVzaFNuYXAiLCJtb3ZlbWVudE1vZGUiLCJuZWVkc1Zpc2liaWxpdHlDaGVjayIsImdldEhvbWVMb2NhdGlvbiIsImdldExpZnRFZmZlY3QiLCJpbnNpZGVIb21lIiwicmF3SW5kZXgiLCJpblZpcnR1YWxMaXN0IiwicGF0Y2hEaW1lbnNpb25NYXAiLCJmaW5pc2giLCJvZmZzZXREcmFnZ2FibGUiLCJvZmZzZXQkMSIsImluaXRpYWxXaW5kb3dTY3JvbGwiLCJtb3ZlZCIsInBsYWNlaG9sZGVyIiwiZ2V0RnJhbWUiLCJhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzIiwiYWRkaXRpb25zIiwidXBkYXRlZERyb3BwYWJsZXMiLCJ3aW5kb3dTY3JvbGxDaGFuZ2UiLCJtb2RpZmllZCIsImRyb3BwYWJsZVNjcm9sbENoYW5nZSIsInRvdGFsQ2hhbmdlIiwicHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwiLCJwdWJsaXNoZWQiLCJ3aXRoU2Nyb2xsQ2hhbmdlIiwiZXhpc3RpbmciLCJ1cGRhdGVkQWRkaXRpb25zIiwicmVtb3ZhbHMiLCJ3YXNPdmVySWQiLCJ3YXNPdmVyIiwiX2dldExpZnRFZmZlY3QiLCJvbkxpZnRJbXBhY3QiLCJkcmFnZ2luZ1N0YXRlIiwiZHJvcFBlbmRpbmciLCJpc1dhaXRpbmciLCJpc1NuYXBwaW5nIiwicG9zdERyb3BwYWJsZUNoYW5nZSIsImlzRW5hYmxlZENoYW5naW5nIiwicmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3QiLCJpZGxlIiwiY29tcGxldGVkIiwic2hvdWxkRmx1c2giLCJyZWR1Y2VyIiwiYWN0aW9uIiwiX2FjdGlvbiRwYXlsb2FkIiwicGF5bG9hZCIsImlzV2luZG93U2Nyb2xsQWxsb3dlZCIsImV2ZXJ5IiwiaXNGaXhlZE9uUGFnZSIsIl9yZXN1bHQiLCJfY2xpZW50U2VsZWN0aW9uIiwiX2FjdGlvbiRwYXlsb2FkMiIsIl9hY3Rpb24kcGF5bG9hZDMiLCJfaWQiLCJfdGFyZ2V0IiwiU3RyaW5nIiwiX2FjdGlvbiRwYXlsb2FkNCIsIl9pZDIiLCJfdGFyZ2V0MiIsIl91cGRhdGVkIiwiX25ld1Njcm9sbCIsIl92aWV3cG9ydCIsIl9yZXN1bHQyIiwibmV3U3RhdGUiLCJfYWN0aW9uJHBheWxvYWQ1IiwiZHJvcER1cmF0aW9uIiwibmV3SG9tZUNsaWVudE9mZnNldCIsIl9yZXN1bHQzIiwiX2NvbXBsZXRlZCIsImJlZm9yZUluaXRpYWxDYXB0dXJlIiwibGlmdCIsImluaXRpYWxQdWJsaXNoIiwicHVibGlzaFdoaWxlRHJhZ2dpbmciLCJjb2xsZWN0aW9uU3RhcnRpbmciLCJ1cGRhdGVEcm9wcGFibGVTY3JvbGwiLCJ1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQiLCJ1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkIiwibW92ZSIsIm1vdmVCeVdpbmRvd1Njcm9sbCIsInVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsIiwibW92ZVVwIiwibW92ZURvd24iLCJtb3ZlUmlnaHQiLCJtb3ZlTGVmdCIsImZsdXNoIiwiYW5pbWF0ZURyb3AiLCJjb21wbGV0ZURyb3AiLCJkcm9wIiwiZHJvcEFuaW1hdGlvbkZpbmlzaGVkIiwiY2hlY2tJbmRleGVzIiwiaW5kZXhlcyIsImVycm9ycyIsImZvcm1hdHRlZCIsImhhc0Vycm9yIiwiam9pbiIsInZhbGlkYXRlRGltZW5zaW9ucyIsImxpZnQkMSIsIm1hcnNoYWwiLCJnZXRTdGF0ZSIsImRpc3BhdGNoIiwibmV4dCIsInNjcm9sbE9wdGlvbnMiLCJzaG91bGRQdWJsaXNoSW1tZWRpYXRlbHkiLCJyZXF1ZXN0IiwiX21hcnNoYWwkc3RhcnRQdWJsaXNoIiwic3RhcnRQdWJsaXNoaW5nIiwic3R5bGUiLCJkcmFnZ2luZyIsImRyb3BwaW5nIiwicmVzdGluZyIsImN1cnZlcyIsIm91dE9mVGhlV2F5Iiwib3BhY2l0eSIsImNvbWJpbmluZyIsInNjYWxlIiwidGltaW5ncyIsIm1pbkRyb3BUaW1lIiwibWF4RHJvcFRpbWUiLCJvdXRPZlRoZVdheVRpbWluZyIsInRyYW5zaXRpb25zIiwiZmx1aWQiLCJzbmFwIiwiZHVyYXRpb24iLCJ0aW1pbmciLCJtb3ZlVG8iLCJ0cmFuc2Zvcm1zIiwiaXNDb21iaW5pbmciLCJ0cmFuc2xhdGUiLCJkcm9wVGltZVJhbmdlIiwibWF4RHJvcFRpbWVBdERpc3RhbmNlIiwiY2FuY2VsRHJvcE1vZGlmaWVyIiwiZ2V0RHJvcER1cmF0aW9uIiwiZGlzdGFuY2UkMSIsInBlcmNlbnRhZ2UiLCJ3aXRoRHVyYXRpb24iLCJ0b0ZpeGVkIiwiZ2V0TmV3SG9tZUNsaWVudE9mZnNldCIsIm5ld0NsaWVudENlbnRlciIsImdldERyb3BJbXBhY3QiLCJsYXN0SW1wYWN0IiwicmVjb21wdXRlZEhvbWVJbXBhY3QiLCJkaWREcm9wSW5zaWRlRHJvcHBhYmxlIiwid2l0aG91dE1vdmVtZW50IiwiZHJvcCQxIiwiaXNXYWl0aW5nRm9yRHJvcCIsIl9nZXREcm9wSW1wYWN0IiwiaXNBbmltYXRpb25SZXF1aXJlZCIsImdldFdpbmRvd1Njcm9sbCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCaW5kaW5nIiwicGFzc2l2ZSIsImNhcHR1cmUiLCJkb2N1bWVudCIsImdldFNjcm9sbExpc3RlbmVyIiwib25XaW5kb3dTY3JvbGwiLCJ1cGRhdGVTY3JvbGwiLCJzY2hlZHVsZWQiLCJpc0FjdGl2ZSIsInN0b3AiLCJjYW5jZWwiLCJzaG91bGRFbmQiLCJzY3JvbGxMaXN0ZW5lciIsInN0b3JlIiwibGlzdGVuZXIiLCJnZXRFeHBpcmluZ0Fubm91bmNlIiwiYW5ub3VuY2UiLCJ3YXNDYWxsZWQiLCJpc0V4cGlyZWQiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2V0QXN5bmNNYXJzaGFsIiwiZW50cmllcyIsImV4ZWN1dGUiLCJ0aW1lcklkIiwiX2VudHJpZXMkc3BsaWNlIiwic3BsaWNlIiwiZW50cnkiLCJjYWxsYmFjayIsInNoYWxsb3ciLCJhcmVMb2NhdGlvbnNFcXVhbCIsImlzQ29tYmluZUVxdWFsIiwiaXNDcml0aWNhbEVxdWFsIiwiaXNEcmFnZ2FibGVFcXVhbCIsImlzRHJvcHBhYmxlRXF1YWwiLCJ3aXRoVGltaW5ncyIsImdldERyYWdTdGFydCIsInJlc3BvbmRlciIsImRhdGEiLCJnZXREZWZhdWx0TWVzc2FnZSIsIndpbGxFeHBpcmUiLCJwcm92aWRlZCIsImdldFB1Ymxpc2hlciIsImdldFJlc3BvbmRlcnMiLCJhc3luY01hcnNoYWwiLCJiZWZvcmVDYXB0dXJlIiwib25CZWZvcmVDYXB0dXJlIiwiYmVmb3JlU3RhcnQiLCJvbkJlZm9yZURyYWdTdGFydCIsImxhc3RDcml0aWNhbCIsImxhc3RMb2NhdGlvbiIsImxhc3RDb21iaW5lIiwiaGFzQ3JpdGljYWxDaGFuZ2VkIiwiaGFzTG9jYXRpb25DaGFuZ2VkIiwiaGFzR3JvdXBpbmdDaGFuZ2VkIiwiYWJvcnQiLCJyZXNwb25kZXJzIiwicHVibGlzaGVyIiwiZHJvcEFuaW1hdGlvbkZpbmlzaCIsImRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsIiwiZnJhbWVJZCIsImNsZWFyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJvbmNlIiwiZmx1c2hEcm9wQW5pbWF0aW9uIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZGltZW5zaW9uTWFyc2hhbFN0b3BwZXIiLCJzdG9wUHVibGlzaGluZyIsImZvY3VzIiwiaXNXYXRjaGluZyIsInRyeVJlY29yZEZvY3VzIiwidHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQiLCJ0cnlTaGlmdFJlY29yZCIsInNob3VsZFN0b3AiLCJhdXRvU2Nyb2xsIiwiYXV0b1Njcm9sbGVyIiwicGVuZGluZ0Ryb3AiLCJwb3N0QWN0aW9uU3RhdGUiLCJjb21wb3NlRW5oYW5jZXJzIiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwibmFtZSIsImRpbWVuc2lvbk1hcnNoYWwiLCJmb2N1c01hcnNoYWwiLCJzdHlsZU1hcnNoYWwiLCJjbGVhbiQxIiwiY3JlYXRlUHVibGlzaGVyIiwicmVnaXN0cnkiLCJzdGFnaW5nIiwiY29sbGVjdCIsIl9zdGFnaW5nIiwiZ2V0QnlJZCIsImdldERpbWVuc2lvbiIsImdldFNjcm9sbFdoaWxlRHJhZ2dpbmciLCJwdWJsaXNoIiwiZ2V0TWF4U2Nyb2xsIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJhZGp1c3RlZE1heFNjcm9sbCIsImdldERvY3VtZW50RWxlbWVudCIsImRvYyIsImRvY3VtZW50RWxlbWVudCIsImdldE1heFdpbmRvd1Njcm9sbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0Vmlld3BvcnQiLCJnZXRJbml0aWFsUHVibGlzaCIsIndpbmRvd1Njcm9sbCIsImdldEFsbEJ5VHlwZSIsImdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsIiwic2hvdWxkUHVibGlzaFVwZGF0ZSIsImNyZWF0ZURpbWVuc2lvbk1hcnNoYWwiLCJjb2xsZWN0aW9uIiwiZXhpc3RzIiwiY2hhbmdlIiwiZHJhZ1N0b3BwZWQiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5TdGFydERyYWciLCJzY3JvbGxXaW5kb3ciLCJzY3JvbGxCeSIsImdldFNjcm9sbGFibGVEcm9wcGFibGVzIiwiZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIiLCJtYXliZSIsImdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlIiwiX2RpbWVuc2lvbiIsImNvbmZpZyIsInN0YXJ0RnJvbVBlcmNlbnRhZ2UiLCJtYXhTY3JvbGxBdFBlcmNlbnRhZ2UiLCJtYXhQaXhlbFNjcm9sbCIsImVhc2UiLCJkdXJhdGlvbkRhbXBlbmluZyIsInN0b3BEYW1wZW5pbmdBdCIsImFjY2VsZXJhdGVBdCIsImdldERpc3RhbmNlVGhyZXNob2xkcyIsImNvbnRhaW5lciIsInN0YXJ0U2Nyb2xsaW5nRnJvbSIsIm1heFNjcm9sbFZhbHVlQXQiLCJ0aHJlc2hvbGRzIiwiZ2V0UGVyY2VudGFnZSIsInN0YXJ0T2ZSYW5nZSIsImVuZE9mUmFuZ2UiLCJyYW5nZSIsImN1cnJlbnRJblJhbmdlIiwibWluU2Nyb2xsIiwiZ2V0VmFsdWVGcm9tRGlzdGFuY2UiLCJkaXN0YW5jZVRvRWRnZSIsInBlcmNlbnRhZ2VGcm9tTWF4U2Nyb2xsVmFsdWVBdCIsInBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tIiwiY2VpbCIsInN0b3BBdCIsImRhbXBlblZhbHVlQnlUaW1lIiwicHJvcG9zZWRTY3JvbGwiLCJkcmFnU3RhcnRUaW1lIiwiRGF0ZSIsInJ1blRpbWUiLCJiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSIsImdldFZhbHVlIiwic2hvdWxkVXNlVGltZURhbXBlbmluZyIsImdldFNjcm9sbE9uQXhpcyIsImRpc3RhbmNlVG9FZGdlcyIsImlzQ2xvc2VyVG9FbmQiLCJhZGp1c3RGb3JTaXplTGltaXRzIiwiaXNUb29CaWdWZXJ0aWNhbGx5IiwiaXNUb29CaWdIb3Jpem9udGFsbHkiLCJjbGVhbiQyIiwiZ2V0U2Nyb2xsIiwicmVxdWlyZWQiLCJsaW1pdGVkIiwic21hbGxlc3RTaWduZWQiLCJnZXRPdmVybGFwIiwiZ2V0UmVtYWluZGVyIiwidGFyZ2V0U2Nyb2xsIiwib3ZlcmxhcCIsImNhblBhcnRpYWxseVNjcm9sbCIsInJhd01heCIsInNtYWxsZXN0Q2hhbmdlIiwiY2FuU2Nyb2xsV2luZG93IiwiZ2V0V2luZG93T3ZlcmxhcCIsImNhblNjcm9sbERyb3BwYWJsZSIsImdldERyb3BwYWJsZU92ZXJsYXAiLCJnZXRXaW5kb3dTY3JvbGxDaGFuZ2UiLCJnZXREcm9wcGFibGVTY3JvbGxDaGFuZ2UiLCJzY3JvbGwkMSIsIl9jaGFuZ2UiLCJjcmVhdGVGbHVpZFNjcm9sbGVyIiwic2NoZWR1bGVXaW5kb3dTY3JvbGwiLCJzY2hlZHVsZURyb3BwYWJsZVNjcm9sbCIsInRyeVNjcm9sbCIsIl9kcmFnZ2luZyIsInN0YXJ0JDEiLCJ3YXNTY3JvbGxOZWVkZWQiLCJmYWtlU2Nyb2xsQ2FsbGJhY2siLCJjcmVhdGVKdW1wU2Nyb2xsZXIiLCJtb3ZlQnlPZmZzZXQiLCJzY3JvbGxEcm9wcGFibGVBc011Y2hBc0l0Q2FuIiwid2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCIsInJlbWFpbmRlciIsInNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4iLCJ3aGF0VGhlV2luZG93Q2FuU2Nyb2xsIiwianVtcFNjcm9sbGVyIiwiZHJvcHBhYmxlUmVtYWluZGVyIiwid2luZG93UmVtYWluZGVyIiwiY3JlYXRlQXV0b1Njcm9sbGVyIiwiZmx1aWRTY3JvbGxlciIsImp1bXBTY3JvbGwiLCJzY3JvbGxlciIsInByZWZpeCQxIiwiZHJhZ0hhbmRsZSIsImJhc2UiLCJjb250ZXh0SWQiLCJzY3JvbGxDb250YWluZXIiLCJtYWtlR2V0U2VsZWN0b3IiLCJjb250ZXh0IiwiYXR0cmlidXRlIiwiZ2V0U3R5bGVzIiwicnVsZXMiLCJwcm9wZXJ0eSIsInJ1bGUiLCJzdHlsZXMiLCJzZWxlY3RvciIsIm5vUG9pbnRlckV2ZW50cyIsImdldFN0eWxlcyQxIiwiZ2V0U2VsZWN0b3IiLCJkcmFnSGFuZGxlJDEiLCJncmFiQ3Vyc29yIiwiYWx3YXlzIiwiZHJvcEFuaW1hdGluZyIsImRyYWdnYWJsZSQxIiwidHJhbnNpdGlvbiIsInVzZXJDYW5jZWwiLCJkcm9wcGFibGUkMSIsImJvZHkiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsImdldEhlYWQiLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZVN0eWxlRWwiLCJub25jZSIsInNldEF0dHJpYnV0ZSIsInVzZVN0eWxlTWFyc2hhbCIsImFsd2F5c1JlZiIsImR5bmFtaWNSZWYiLCJzZXREeW5hbWljU3R5bGUiLCJ0ZXh0Q29udGVudCIsInNldEFsd2F5c1N0eWxlIiwiZHluYW1pYyIsImFwcGVuZENoaWxkIiwicmVmIiwicmVtb3ZlQ2hpbGQiLCJnZXRXaW5kb3dGcm9tRWwiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0h0bWxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJmaW5kRHJhZ0hhbmRsZSIsInBvc3NpYmxlIiwicXVlcnlTZWxlY3RvckFsbCIsImhhbmRsZSIsImdldEF0dHJpYnV0ZSIsInVzZUZvY3VzTWFyc2hhbCIsImVudHJpZXNSZWYiLCJyZWNvcmRSZWYiLCJyZXN0b3JlRm9jdXNGcmFtZVJlZiIsImlzTW91bnRlZFJlZiIsInJlZ2lzdGVyIiwidW5yZWdpc3RlciIsInRyeUdpdmVGb2N1cyIsInRyeUdpdmVGb2N1c1RvIiwiYWN0aXZlRWxlbWVudCIsInJlZGlyZWN0VG8iLCJyZWNvcmQiLCJmb2N1c2VkIiwiY2xlYXJGcmFtZU9uVW5tb3VudCIsImNyZWF0ZVJlZ2lzdHJ5Iiwic3Vic2NyaWJlcnMiLCJjYiIsIm5vdGlmeSIsImZpbmREcmFnZ2FibGVCeUlkIiwiZ2V0RHJhZ2dhYmxlQnlJZCIsImRyYWdnYWJsZUFQSSIsInVuaXF1ZUlkIiwiZmluZEJ5SWQiLCJmaW5kRHJvcHBhYmxlQnlJZCIsImdldERyb3BwYWJsZUJ5SWQiLCJkcm9wcGFibGVBUEkiLCJ1c2VSZWdpc3RyeSIsInVubW91bnQiLCJTdG9yZUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiZ2V0Qm9keUVsZW1lbnQiLCJ2aXN1YWxseUhpZGRlbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImdldElkIiwidXNlQW5ub3VuY2VyIiwic2V0dXAiLCJjbGVhbnVwIiwiY291bnQiLCJkZWZhdWx0cyIsInNlcGFyYXRvciIsInJlc2V0IiwidXNlVW5pcXVlSWQiLCJnZXRFbGVtZW50SWQiLCJ1c2VIaWRkZW5UZXh0RWxlbWVudCIsInRleHQiLCJtb3VudCIsImRpc3BsYXkiLCJBcHBDb250ZXh0IiwicGVlckRlcGVuZGVuY2llcyIsInJlYWN0Iiwic2VtdmVyIiwiZ2V0VmVyc2lvbiIsImV4ZWMiLCJtYWpvciIsIm1pbm9yIiwicmF3IiwiaXNTYXRpc2ZpZWQiLCJleHBlY3RlZCIsImFjdHVhbCIsImNoZWNrUmVhY3RWZXJzaW9uIiwicGVlckRlcFZhbHVlIiwiYWN0dWFsVmFsdWUiLCJwZWVyRGVwIiwic3VmZml4IiwiY2hlY2tEb2N0eXBlIiwiZG9jdHlwZSIsInRvTG93ZXJDYXNlIiwicHVibGljSWQiLCJ1c2VEZXYiLCJ1c2VIb29rIiwidXNlRGV2U2V0dXBXYXJuaW5nIiwiaW5wdXRzIiwiZSIsInVzZVN0YXJ0dXBWYWxpZGF0aW9uIiwidmVyc2lvbiIsInVzZVByZXZpb3VzIiwiY3JlYXRlIiwibG9jayIsImlzQ2xhaW1lZCIsImNsYWltIiwiYWJhbmRvbiIsIm5ld0xvY2siLCJyZWxlYXNlIiwidHJ5QWJhbmRvbiIsInRhYiIsImVudGVyIiwiZXNjYXBlIiwic3BhY2UiLCJwYWdlVXAiLCJwYWdlRG93biIsImFycm93TGVmdCIsImFycm93VXAiLCJhcnJvd1JpZ2h0IiwiYXJyb3dEb3duIiwiX3ByZXZlbnRlZEtleXMiLCJwcmV2ZW50ZWRLZXlzIiwicHJldmVudFN0YW5kYXJkS2V5RXZlbnRzIiwia2V5Q29kZSIsInN1cHBvcnRlZEV2ZW50TmFtZSIsInN1cHBvcnRlZCIsInByaW1hcnlCdXR0b24iLCJzbG9wcHlDbGlja1RocmVzaG9sZCIsImlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZCIsImFicyIsImlkbGUkMSIsImdldENhcHR1cmVCaW5kaW5ncyIsImdldFBoYXNlIiwic2V0UGhhc2UiLCJidXR0b24iLCJjbGllbnRYIiwiY2xpZW50WSIsImFjdGlvbnMiLCJwZW5kaW5nIiwiZmx1aWRMaWZ0Iiwic2hvdWxkQmxvY2tOZXh0Q2xpY2siLCJzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyIsInVzZU1vdXNlU2Vuc29yIiwiYXBpIiwicGhhc2VSZWYiLCJ1bmJpbmRFdmVudHNSZWYiLCJzdGFydENhcHR1cmVCaW5kaW5nIiwib25Nb3VzZURvd24iLCJkZWZhdWx0UHJldmVudGVkIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsImZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQiLCJ0cnlHZXRMb2NrIiwic291cmNlRXZlbnQiLCJzdGFydFBlbmRpbmdEcmFnIiwicHJldmVudEZvcmNlUHJlc3NCaW5kaW5nIiwiZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUiLCJjYW5HZXRMb2NrIiwibGlzdGVuRm9yQ2FwdHVyZSIsImJpbmRDYXB0dXJpbmdFdmVudHMiLCJfc2Nyb2xsSnVtcEtleXMiLCJub29wJDEiLCJzY3JvbGxKdW1wS2V5cyIsImdldERyYWdnaW5nQmluZGluZ3MiLCJ1c2VLZXlib2FyZFNlbnNvciIsIm9uS2V5RG93biIsInByZURyYWciLCJpc0NhcHR1cmluZyIsInNuYXBMaWZ0IiwidHJ5U3RhcnRDYXB0dXJlIiwiaWRsZSQyIiwidGltZUZvckxvbmdQcmVzcyIsImZvcmNlUHJlc3NUaHJlc2hvbGQiLCJnZXRXaW5kb3dCaW5kaW5ncyIsImdldEhhbmRsZUJpbmRpbmdzIiwiaGFzTW92ZWQiLCJfZXZlbnQkdG91Y2hlcyQiLCJ0b3VjaGVzIiwidG91Y2giLCJpc0ZvcmNlUHJlc3MiLCJmb3JjZSIsInNob3VsZFJlc3BlY3QiLCJ1c2VUb3VjaFNlbnNvciIsIm9uVG91Y2hTdGFydCIsImxvbmdQcmVzc1RpbWVySWQiLCJ1bmJpbmRUYXJnZXQiLCJ1bmJpbmRXaW5kb3ciLCJzdGFydERyYWdnaW5nIiwid2Via2l0SGFjayIsInVzZVZhbGlkYXRlU2Vuc29ySG9va3MiLCJzZW5zb3JIb29rcyIsInByZXZpb3VzUmVmIiwiaW50ZXJhY3RpdmVUYWdOYW1lcyIsImlucHV0IiwidGV4dGFyZWEiLCJzZWxlY3QiLCJvcHRpb24iLCJvcHRncm91cCIsInZpZGVvIiwiYXVkaW8iLCJpc0FuSW50ZXJhY3RpdmVFbGVtZW50IiwicGFyZW50IiwiaGFzQW5JbnRlcmFjdGl2ZVRhZyIsInRhZ05hbWUiLCJwYXJlbnRFbGVtZW50IiwiaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50IiwiZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpc0VsZW1lbnQiLCJFbGVtZW50Iiwic3VwcG9ydGVkTWF0Y2hlc05hbWUiLCJjbG9zZXN0UG9ueWZpbGwiLCJjbG9zZXN0JDEiLCJmaW5kQ2xvc2VzdERyYWdIYW5kbGVGcm9tRXZlbnQiLCJ0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQiLCJmaW5kRHJhZ2dhYmxlIiwiX2lzQWN0aXZlIiwiaXNMb2NrQWN0aXZlIiwic2hvdWxkV2FybiIsImNhblN0YXJ0IiwibG9ja0FQSSIsInRyeVN0YXJ0IiwiZm9yY2VTZW5zb3JTdG9wIiwic2hvdWxkU3RhcnQiLCJjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyIsImdldFNob3VsZFJlc3BlY3RGb3JjZVByZXNzIiwidHJ5RGlzcGF0Y2giLCJnZXRBY3Rpb24iLCJ0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyIsImxpZnRBY3Rpb25BcmdzIiwibW92ZSQxIiwibW92ZVVwJDEiLCJtb3ZlUmlnaHQkMSIsIm1vdmVEb3duJDEiLCJtb3ZlTGVmdCQxIiwiYWJvcnRQcmVEcmFnIiwic2hvdWxkUmVsZWFzZSIsImRlZmF1bHRTZW5zb3JzIiwidXNlU2Vuc29yTWFyc2hhbCIsIl9yZWY0IiwiY3VzdG9tU2Vuc29ycyIsImVuYWJsZURlZmF1bHRTZW5zb3JzIiwidXNlU2Vuc29ycyIsInRyeUFiYW5kb25Mb2NrIiwibGlzdGVuVG9TdG9yZSIsImZvcmNlU3RvcCIsInRyeVJlbGVhc2VMb2NrIiwiaXNMb2NrQ2xhaW1lZCIsImNyZWF0ZVJlc3BvbmRlcnMiLCJnZXRTdG9yZSIsImxhenlSZWYiLCJBcHAiLCJzZW5zb3JzIiwibGF6eVN0b3JlUmVmIiwibGFzdFByb3BzUmVmIiwiZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQiLCJsYXp5RGlzcGF0Y2giLCJtYXJzaGFsQ2FsbGJhY2tzIiwidHJ5UmVzZXRTdG9yZSIsImFwcENhbGxiYWNrcyIsImdldENhbkxpZnQiLCJnZXRJc01vdmVtZW50QWxsb3dlZCIsImFwcENvbnRleHQiLCJjYW5MaWZ0IiwiY291bnQkMSIsInJlc2V0JDEiLCJ1c2VJbnN0YW5jZUNvdW50IiwicmVzZXRTZXJ2ZXJDb250ZXh0IiwiRHJhZ0Ryb3BDb250ZXh0IiwiaXNFcXVhbCQxIiwiaXNTY3JvbGwiLCJpc0F1dG8iLCJpc1Zpc2libGUkMSIsImlzRWl0aGVyIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiaXNCb3RoIiwiaXNFbGVtZW50U2Nyb2xsYWJsZSIsImdldENvbXB1dGVkU3R5bGUiLCJpc0JvZHlTY3JvbGxhYmxlIiwiaHRtbCIsImh0bWxTdHlsZSIsImh0bWxPdmVyZmxvdyIsImdldENsb3Nlc3RTY3JvbGxhYmxlIiwiY2hlY2tGb3JOZXN0ZWRTY3JvbGxDb250YWluZXJzIiwiYW5vdGhlclNjcm9sbFBhcmVudCIsImdldFNjcm9sbCQxIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImdldElzRml4ZWQiLCJnZXRFbnYiLCJjbG9zZXN0U2Nyb2xsYWJsZSIsImdldERyb3BwYWJsZURpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJmcmFtZUNsaWVudCIsInBhZGRpbmdCb3giLCJnZXRDbGllbnQiLCJ0YXJnZXRSZWYiLCJlbnYiLCJpc0Ryb3BEaXNhYmxlZCIsImltbWVkaWF0ZSIsImRlbGF5ZWQiLCJnZXRMaXN0ZW5lck9wdGlvbnMiLCJ1c2VSZXF1aXJlZENvbnRleHQiLCJDb250ZXh0IiwiZ2V0Q2xvc2VzdFNjcm9sbGFibGVGcm9tRHJhZyIsInVzZURyb3BwYWJsZVB1Ymxpc2hlciIsIndoaWxlRHJhZ2dpbmdSZWYiLCJwdWJsaXNoZWREZXNjcmlwdG9yUmVmIiwibWVtb2l6ZWRVcGRhdGVTY3JvbGwiLCJnZXRDbG9zZXN0U2Nyb2xsIiwic2NoZWR1bGVTY3JvbGxVcGRhdGUiLCJvbkNsb3Nlc3RTY3JvbGwiLCJnZXREcm9wcGFibGVSZWYiLCJpZ25vcmVDb250YWluZXJDbGlwcGluZyIsInJlbW92ZUF0dHJpYnV0ZSIsIm5vb3AkMiIsImVtcHR5IiwiZ2V0U2l6ZSIsImlzQW5pbWF0aW5nT3Blbk9uTW91bnQiLCJhbmltYXRlIiwiZ2V0U3R5bGUiLCJib3hTaXppbmciLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJmbGV4U2hyaW5rIiwiZmxleEdyb3ciLCJwb2ludGVyRXZlbnRzIiwiUGxhY2Vob2xkZXIiLCJhbmltYXRlT3BlblRpbWVyUmVmIiwidHJ5Q2xlYXJBbmltYXRlT3BlblRpbWVyIiwib25UcmFuc2l0aW9uRW5kIiwib25DbG9zZSIsIl91c2VTdGF0ZSIsInNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQiLCJvblNpemVDaGFuZ2VFbmQiLCJwcm9wZXJ0eU5hbWUiLCJpbm5lclJlZiIsIlBsYWNlaG9sZGVyJDEiLCJtZW1vIiwiRHJvcHBhYmxlQ29udGV4dCIsImNoZWNrSXNWYWxpZElubmVyUmVmIiwiaXNCb29sZWFuIiwicnVuQ2hlY2tzIiwiY2hlY2tzIiwiY2hlY2siLCJfYm9vbGVhbiIsInN0YW5kYXJkIiwiZ2V0UGxhY2Vob2xkZXJSZWYiLCJ2aXJ0dWFsIiwiaGFzQ2xvbmUiLCJfcmVmNSIsInJlbmRlckNsb25lIiwiaGFzTm9QbGFjZWhvbGRlciIsIl9yZWY2IiwidXNlVmFsaWRhdGlvbiIsIkFuaW1hdGVJbk91dCIsIl9SZWFjdCRQdXJlQ29tcG9uZW50Iiwib24iLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJQdXJlQ29tcG9uZW50IiwiekluZGV4T3B0aW9ucyIsImdldERyYWdnaW5nVHJhbnNpdGlvbiIsInNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQiLCJnZXREcmFnZ2luZ09wYWNpdHkiLCJpc0Ryb3BBbmltYXRpbmciLCJnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUiLCJnZXREcmFnZ2luZ1N0eWxlIiwidHJhbnNmb3JtIiwiekluZGV4IiwiZ2V0U2Vjb25kYXJ5U3R5bGUiLCJzZWNvbmRhcnkiLCJzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50IiwiZ2V0U3R5bGUkMSIsIm1hcHBlZCIsImdldERpbWVuc2lvbiQxIiwiY29tcHV0ZWRTdHlsZXMiLCJ1c2VEcmFnZ2FibGVQdWJsaXNoZXIiLCJnZXREcmFnZ2FibGVSZWYiLCJwdWJsaXNoZWRSZWYiLCJpc0ZpcnN0UHVibGlzaFJlZiIsInVzZVZhbGlkYXRpb24kMSIsImdldFJlZiIsInVzZUNsb25lUHJvcFZhbGlkYXRpb24iLCJpc0Nsb25lIiwiaW5pdGlhbFJlZiIsInByZXZlbnRIdG1sNURuZCIsIkRyYWdnYWJsZSIsInNldFJlZiIsIl91c2VSZXF1aXJlZENvbnRleHQiLCJfdXNlUmVxdWlyZWRDb250ZXh0MiIsImRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbiIsImZvclB1Ymxpc2hlciIsImRyYWdIYW5kbGVQcm9wcyIsInRhYkluZGV4Iiwicm9sZSIsIm9uTW92ZUVuZCIsImRyYWdnYWJsZVByb3BzIiwicnVicmljIiwic25hcHNob3QiLCJpc1N0cmljdEVxdWFsIiwid2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0IiwiZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0IiwiZ2V0Q29tYmluZVdpdGhGcm9tSW1wYWN0IiwiZ2V0RHJhZ2dhYmxlU2VsZWN0b3IiLCJtZW1vaXplZE9mZnNldCIsImdldE1lbW9pemVkU25hcHNob3QiLCJkcmFnZ2luZ092ZXIiLCJkcm9wQW5pbWF0aW9uIiwiY29tYmluZVRhcmdldEZvciIsImdldE1lbW9pemVkUHJvcHMiLCJvd25Qcm9wcyIsIl9kcmFnZ2luZ092ZXIiLCJfY29tYmluZVdpdGgiLCJjdXJ2ZSIsImdldFNlY29uZGFyeVNuYXBzaG90IiwiYXRSZXN0IiwiZ2V0U2Vjb25kYXJ5U2VsZWN0b3IiLCJnZXRGYWxsYmFjayIsImdldFByb3BzIiwib3duSWQiLCJkcmFnZ2luZ0lkIiwidmlzdWFsRGlzcGxhY2VtZW50IiwiaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCIsIl9vZmZzZXQiLCJtYWtlTWFwU3RhdGVUb1Byb3BzIiwiZHJhZ2dpbmdTZWxlY3RvciIsInNlY29uZGFyeVNlbGVjdG9yIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwiQ29ubmVjdGVkRHJhZ2dhYmxlIiwicHVyZSIsImFyZVN0YXRlUHJvcHNFcXVhbCIsIlByaXZhdGVEcmFnZ2FibGUiLCJkcm9wcGFibGVDb250ZXh0IiwiaXNVc2luZ0Nsb25lRm9yIiwiUHVibGljRHJhZ2dhYmxlIiwiaXNEcmFnRGlzYWJsZWQiLCJkaXNhYmxlSW50ZXJhY3RpdmVFbGVtZW50QmxvY2tpbmciLCJEcm9wcGFibGUiLCJkcm9wcGFibGVSZWYiLCJwbGFjZWhvbGRlclJlZiIsInVzZUNsb25lIiwiZ2V0Q29udGFpbmVyRm9yQ2xvbmUiLCJzZXREcm9wcGFibGVSZWYiLCJzZXRQbGFjZWhvbGRlclJlZiIsIm9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kIiwic2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyIiwiZHJvcHBhYmxlUHJvcHMiLCJnZXRDbG9uZSIsIm5vZGUiLCJkcmFnZ2FibGVQcm92aWRlZCIsImRyYWdnYWJsZVNuYXBzaG90IiwiY3JlYXRlUG9ydGFsIiwiaXNNYXRjaGluZ1R5cGUiLCJnZXREcmFnZ2FibGUiLCJtYWtlTWFwU3RhdGVUb1Byb3BzJDEiLCJpZGxlV2l0aEFuaW1hdGlvbiIsImlzRHJhZ2dpbmdPdmVyIiwiZHJhZ2dpbmdPdmVyV2l0aCIsImRyYWdnaW5nRnJvbVRoaXNXaXRoIiwiaXNVc2luZ1BsYWNlaG9sZGVyIiwiaWRsZVdpdGhvdXRBbmltYXRpb24iLCJnZXREcmFnZ2FibGVSdWJyaWMiLCJnZXRNYXBQcm9wcyIsImlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIiLCJpc0RyYWdnaW5nT3ZlckZvckltcGFjdCIsImlzSG9tZSIsIl9zbmFwc2hvdCIsIndhc0NvbWJpbmluZyIsIm1hcERpc3BhdGNoVG9Qcm9wcyQxIiwiZ2V0Qm9keSIsImRlZmF1bHRQcm9wcyIsIkNvbm5lY3RlZERyb3BwYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js\n");

/***/ })

};
;